<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Flutter第三讲]]></title>
    <url>%2F2019%2F04%2F03%2FFlutter%E7%AC%AC%E4%B8%89%E8%AE%B2%2F</url>
    <content type="text"><![CDATA[Flutter Bloc Package译文，原文地址，转载译文请注明出处。 [TOC] 在使用Flutter工作一段时间之后，我决定创建一个软件包以帮助我经常使用的东西：BLoC模式。对于那些不熟悉BLoC模式的人来说，它是一种设计模式，有助于将表示层与业务逻辑分开。你在这里了解更多。 使用BLoC模式可能具有挑战性,因为需要建立对Streams和Reactive Programming的理解。但它的核心是BLoC非常简单： BLoC 将event流作为输入，并将它们转换为state流作为输出。 我们现在可以在bloc的dart包的帮助下使用这种强大的设计模式。 该软件包抽象了模式的反应方面，允许开发人员专注于将事件(event)转换为状态(state)。 让我们从定义这些术语开始…… 词汇表Events 是Bloc的输入。它们通常是UI事件，例如按钮按下。Events被分发(dispatched)并且被转换为States。 States 是Bloc的输出。表示组件可以监听状态流 并根据给定状态重绘其自身的部分（BlocBuilder有关详细信息，请参阅参考资料）。 Transitions 发生在 调用mapEventToState之后 但在更新了bloc的state之前 调度了一个Event 现在我们了解事件和状态，我们可以看一下Bloc API。 BLOC APImapEventToState 当一个类继承Bloc时，必须实现 mapEventToState 方法， 该函数将传入事件作为参数。只要UI层触发一个事件，就会调用 mapEventToState。mapEventToState 必须将该event转换为新state，并以UI层消耗的Stream形式返回新状态。 dispatch dispatch 是一个 接受 event 并触发 mapEventToState 的方法。可以从表示层调用dispatch 或 从Bloc内部（见例子）并通知Bloc一个新 event。 initialState initialState是处理任何事件之前的状态（在mapEventToState被调用之前）。如果未实现，则为initialState null。 transform transform是一个 在调用mapEventToState之前 可以重写以转换 Stream .这允许使用distinct() 和 debounce() 的操作。 onTransition onTransition 是一个 每次 transform 发生时都可以重写以进行处理 的方法。调度新event 并调用mapEventToState时发生transition。onTransition 在更新 bloc 状态之前 被调用。这是添加特定于块的日志记录/分析的好地方 让我们创建一个counter bloc！ 123456789101112131415161718enum CounterEvent &#123; increment, decrement &#125;class CounterBloc extends Bloc&lt;CounterEvent, int&gt; &#123; @override int get initialState =&gt; 0; @override Stream&lt;int&gt; mapEventToState(CounterEvent event) async* &#123; switch (event) &#123; case CounterEvent.decrement: yield currentState - 1; break; case CounterEvent.increment: yield currentState + 1; break; &#125; &#125;&#125; 创建一个BLoC 需要作如下操作: 定义所有 event 和 state 继承Bloc 重写 initialState 和 mapEventToState 在这种情况下，我们的 events 是CounterEvents ,states 是 integers CounterBloc 转换 CounterEvents 为 integers。 我们可以通过 dispatch 来 通知CounterBloc 事件 123456void main() &#123; final counterBloc = CounterBloc(); counterBloc.dispatch(CounterEvent.increment); counterBloc.dispatch(CounterEvent.decrement);&#125; 为了观察状state 的 转换（Transitions），我们可以重写onTransition。1234567891011121314151617181920212223enum CounterEvent &#123; increment, decrement &#125;class CounterBloc extends Bloc&lt;CounterEvent, int&gt; &#123; @override int get initialState =&gt; 0; @override void onTransition(Transition&lt;CounterEvent, int&gt; transition) &#123; print(transition); &#125; @override Stream&lt;int&gt; mapEventToState(CounterEvent event) async* &#123; switch (event) &#123; case CounterEvent.decrement: yield currentState - 1; break; case CounterEvent.increment: yield currentState + 1; break; &#125; &#125;&#125; 现在，每当发出(dispatch)一个CounterEvent我们的Bloc将响应一个新的integer状态，我们将看到一个transition被输出到控制台。 现在让我们使用Flutter构建一个UI，并使用flutter_bloc 包将UI连接到我们的CounterBloc。 BlocBuilder BlocBuilder是一个Flutter小部件，它需要一个Bloc和一个构建器函数。BlocBuilder处理构建窗口小部件以响应新state。BlocBuilder与StreamBuilder非常相似，但它有一个更简单的API来减少所需的样板代码量。 BlocProvider BlocProvider是一个Flutter小部件，它通过 BlocProvider.of(context)为其子女提供了一个bloc。它用作依赖注入（DI）小部件, 这样一个bloc实例 可以被提供给子树中的多个小部件。 现在让我们构建 counter App1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class App extends StatefulWidget &#123; @override State&lt;StatefulWidget&gt; createState() =&gt; _AppState();&#125;class _AppState extends State&lt;App&gt; &#123; final CounterBloc _counterBloc = CounterBloc(); @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter Demo', home: BlocProvider&lt;CounterBloc&gt;( bloc: _counterBloc, child: CounterPage(), ), ); &#125; @override void dispose() &#123; _counterBloc.dispose(); super.dispose(); &#125;&#125;class CounterPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; final CounterBloc _counterBloc = BlocProvider.of&lt;CounterBloc&gt;(context); return Scaffold( appBar: AppBar(title: Text('Counter')), body: BlocBuilder&lt;CounterEvent, int&gt;( bloc: _counterBloc, builder: (BuildContext context, int count) &#123; return Center( child: Text( '$count', style: TextStyle(fontSize: 24.0), ), ); &#125;, ), floatingActionButton: Column( crossAxisAlignment: CrossAxisAlignment.end, mainAxisAlignment: MainAxisAlignment.end, children: &lt;Widget&gt;[ Padding( padding: EdgeInsets.symmetric(vertical: 5.0), child: FloatingActionButton( child: Icon(Icons.add), onPressed: () &#123; _counterBloc.dispatch(CounterEvent.increment); &#125;, ), ), Padding( padding: EdgeInsets.symmetric(vertical: 5.0), child: FloatingActionButton( child: Icon(Icons.remove), onPressed: () &#123; _counterBloc.dispatch(CounterEvent.decrement); &#125;, ), ), ], ), ); &#125;&#125; 该App小部件是StatefulWidget，负责创建和销毁 CounterBloc。它让 CounterBloc 使用 BlocProvider 小部件可用于 CounterPage 小部件。 CounterPage小部件是StatelessWidget， 它使用BlocBuilder重建UI以响应CounterBloc的状态变化。 此时，我们已经成功地将我们的表示层与业务逻辑层分开。请注意，CounterPage窗口小部件对用户点击按钮时发生的情况一无所知。小部件只是告诉CounterBloc用户按下了递增或递减按钮。 有关更多示例和详细文档，请查看官方集团文档。 相关链接： bloc dart包flutter_bloc包flutter_bloc使用官方文档]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter-BLoC-第二讲]]></title>
    <url>%2F2019%2F03%2F14%2FFlutter-BLoC-%E7%AC%AC%E4%BA%8C%E8%AE%B2%2F</url>
    <content type="text"><![CDATA[[译文]Reactive Programming - Streams - BLoC实际用例 原文 BLoC，Reactive Programming，Streams - 实际用例和有用模式。 [TOC]注：此处的”toc”应显示为目录，但是简书不支持，显示不出来。 介绍 在介绍了BLoC，Reactive Programming和Streams的概念后，我在一段时间之前做了一些介绍，尽管与我分享一些我经常使用并且个人觉得非常有用的模式（至少对我而言）可能会很有趣。这些模式使我在开发过程中节省了大量时间，并使我的代码更易于阅读和调试。 我要谈的话题是： 1.BLoC Provider and InheritedWidget 2.在哪里初始化BLoC？ 3.事件状态（允许根据事件响应状态转换） 4.表格验证（允许根据条目和验证控制表单的行为） 5.Part Of（允许Widget根据其在列表中的存在来调整其行为） 完整的源代码可以在GitHub上找到。 1.BLoC Provider and InheritedWidget我借此文章的机会介绍我的BlocProvider的另一个版本，它现在依赖于一个InheritedWidget。 使用InheritedWidget的优点是我们获得了性能。 1.1. 之前的实现我之前版本的BlocProvider实现为常规StatefulWidget，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839abstract class BlocBase &#123; void dispose();&#125;// Generic BLoC providerclass BlocProvider&lt;T extends BlocBase&gt; extends StatefulWidget &#123; BlocProvider(&#123; Key key, @required this.child, @required this.bloc, &#125;): super(key: key); final T bloc; final Widget child; @override _BlocProviderState&lt;T&gt; createState() =&gt; _BlocProviderState&lt;T&gt;(); static T of&lt;T extends BlocBase&gt;(BuildContext context)&#123; final type = _typeOf&lt;BlocProvider&lt;T&gt;&gt;(); BlocProvider&lt;T&gt; provider = context.ancestorWidgetOfExactType(type); return provider.bloc; &#125; static Type _typeOf&lt;T&gt;() =&gt; T;&#125;class _BlocProviderState&lt;T&gt; extends State&lt;BlocProvider&lt;BlocBase&gt;&gt;&#123; @override void dispose()&#123; widget.bloc.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context)&#123; return widget.child; &#125;&#125; 我使用StatefulWidget从dispose（）方法中受益，以确保在不再需要时释放BLoC分配的资源。 这很好用但从性能角度来看并不是最佳的。 context.ancestorWidgetOfExactType()是一个为时间复杂度为O(n)的函数，为了检索某种类型的祖先，它将对widget树 做向上导航，从上下文开始，一次递增一个父，直到完成。如果从上下文到祖先的距离很小（即O(n)结果很少），则可以接受对此函数的调用，否则应该避免。这是这个函数的代码。 12345678@overrideWidget ancestorWidgetOfExactType(Type targetType) &#123; assert(_debugCheckStateIsActiveForAncestorLookup()); Element ancestor = _parent; while (ancestor != null &amp;&amp; ancestor.widget.runtimeType != targetType) ancestor = ancestor._parent; return ancestor?.widget;&#125; 1.2. 新的实现新实现依赖于StatefulWidget，并结合InheritedWidget：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Type _typeOf&lt;T&gt;() =&gt; T;abstract class BlocBase &#123; void dispose();&#125;class BlocProvider&lt;T extends BlocBase&gt; extends StatefulWidget &#123; BlocProvider(&#123; Key key, @required this.child, @required this.bloc, &#125;): super(key: key); final Widget child; final T bloc; @override _BlocProviderState&lt;T&gt; createState() =&gt; _BlocProviderState&lt;T&gt;(); static T of&lt;T extends BlocBase&gt;(BuildContext context)&#123; final type = _typeOf&lt;_BlocProviderInherited&lt;T&gt;&gt;(); _BlocProviderInherited&lt;T&gt; provider = context.ancestorInheritedElementForWidgetOfExactType(type)?.widget; return provider?.bloc; &#125;&#125;class _BlocProviderState&lt;T extends BlocBase&gt; extends State&lt;BlocProvider&lt;T&gt;&gt;&#123; @override void dispose()&#123; widget.bloc?.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context)&#123; return new _BlocProviderInherited&lt;T&gt;( bloc: widget.bloc, child: widget.child, ); &#125;&#125;class _BlocProviderInherited&lt;T&gt; extends InheritedWidget &#123; _BlocProviderInherited(&#123; Key key, @required Widget child, @required this.bloc, &#125;) : super(key: key, child: child); final T bloc; @override bool updateShouldNotify(_BlocProviderInherited oldWidget) =&gt; false;&#125; 优点是这个解决方案是性能。 由于使用了InheritedWidget，它现在可以调用context.ancestorInheritedElementForWidgetOfExactType()函数，它是一个O（1），这意味着祖先的检索是立即的，如其源代码所示：12345678@overrideInheritedElement ancestorInheritedElementForWidgetOfExactType(Type targetType) &#123; assert(_debugCheckStateIsActiveForAncestorLookup()); final InheritedElement ancestor = _inheritedWidgets == null ? null : _inheritedWidgets[targetType]; return ancestor;&#125; 这来自于所有InheritedWidgets都由Framework记忆的事实。 为什么使用 ancestorInheritedElementForWidgetOfExactType ？ 您可能已经注意到我使用 ancestorInheritedElementForWidgetOfExactType 方法而不是通常的 inheritFromWidgetOfExactType 。 原因是我不希望上下文调用的BlocProvider被注册为InheritedWidget的依赖项，因为我不需要它。 1.3. 如何使用新的BlocProvider？1.3.1.注入BLoC123456Widget build(BuildContext context)&#123; return BlocProvider&lt;MyBloc&gt;&#123; bloc: myBloc, child: ... &#125;&#125; 1.3.2. 检索BLoC1234Widget build(BuildContext context)&#123; MyBloc myBloc = BlocProvider.of&lt;MyBloc&gt;(context); ...&#125; 2.在哪里初始化BLoC？要回答这个问题，您需要弄清楚其使用范围。 2.1.应用程序中随处可用假设您必须处理与用户身份验证/配置文件，用户首选项，购物篮相关的一些机制, 可从应用程序的任何可能部分(例如，从不同页面)获得获得BLoC(),存在两种方式使这个BLoC可访问。 2.1.1.使用全局单例123456789101112131415161718192021222324252627import 'package:rxdart/rxdart.dart';class GlobalBloc &#123; /// /// 与此BLoC相关的流 /// BehaviorSubject&lt;String&gt; _controller = BehaviorSubject&lt;String&gt;(); Function(String) get push =&gt; _controller.sink.add; Stream&lt;String&gt; get stream =&gt; _controller; /// /// Singleton工厂 /// static final GlobalBloc _bloc = new GlobalBloc._internal(); factory GlobalBloc()&#123; return _bloc; &#125; GlobalBloc._internal(); /// /// Resource disposal /// void dispose()&#123; _controller?.close();&#125;GlobalBloc globalBloc = GlobalBloc(); 要使用此BLoC，您只需导入该类并直接调用其方法，如下所示： 123456789import 'global_bloc.dart';class MyWidget extends StatelessWidget &#123; @override Widget build(BuildContext context)&#123; globalBloc.push('building MyWidget'); return Container(); &#125;&#125; 这是一个可以接受的解决方案，如果你需要有一个BLoC是唯一的，需要从应用程序内的任意位置访问。 这是非常容易使用; 它不依赖于任何BuildContext ; 没有必要通过任何BlocProvider去寻找 BLoC; 为了释放它的资源，只需确保将应用程序实现为StatefulWidget，并在应用程序Widget 的重写dispose（）方法中调用globalBloc.dispose（） 许多纯粹主义者反对这种解决方案。我不知道为什么，但是…所以让我们看看另一个…… 2.1.2. 把它放在一切之上在Flutter中，所有页面的祖先本身必须是MaterialApp的父级。这是由于这样的事实，一个页面（或路由）被包装在一个OverlayEntry，一个共同的孩子堆栈的所有页面。 换句话说，每个页面都有一个Buildcontext，它独立于任何其他页面。这就解释了为什么在不使用任何技巧的情况下，2页（路线）不可能有任何共同点。 因此，如果您需要在应用程序中的任何位置使用BLoC，则必须将其作为MaterialApp的父级，如下所示：1234567891011121314151617void main() =&gt; runApp(Application());class Application extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return BlocProvider&lt;AuthenticationBloc&gt;( bloc: AuthenticationBloc(), child: MaterialApp( title: 'BLoC Samples', theme: ThemeData( primarySwatch: Colors.blue, ), home: InitializationPage(), ), ); &#125;&#125; 2.2.可用于子树大多数情况下，您可能需要在应用程序的某些特定部分使用BLoC。 作为一个例子，我们可以想到的讨论主题，其中集团将用于 与服务器交互以检索，添加，更新帖子 列出要在特定页面中显示的线程 … 因此，如果您需要在应用程序中的任何位置使用BLoC，则必须将其作为MaterialApp的父级，如下所示：123456789101112131415161718192021class MyTree extends StatelessWidget &#123; @override Widget build(BuildContext context)&#123; return BlocProvider&lt;MyBloc&gt;( bloc: MyBloc(), child: Column( children: &lt;Widget&gt;[ MyChildWidget(), ], ), ); &#125;&#125;class MyChildWidget extends StatelessWidget &#123; @override Widget build(BuildContext context)&#123; MyBloc = BlocProvider.of&lt;MyBloc&gt;(context); return Container(); &#125;&#125; 这样一来，所有widgets都可以通过对呼叫BlocProvider.of方法 访问BLoC 附：如上所示的解决方案并不是最佳解决方案，因为它将在每次重建时实例化BLoC。后果： 您将丢失任何现有的BLoC内容 它会耗费CPU时间，因为它需要在每次构建时实例化它。 一个更好的办法，在这种情况下，是使用StatefulWidget从它的持久受益国，具体如下：12345678910111213141516171819202122232425262728293031class MyTree extends StatefulWidget &#123; @override _MyTreeState createState() =&gt; _MyTreeState();&#125;class _MyTreeState extends State&lt;MyTree&gt;&#123; MyBloc bloc; @override void initState()&#123; super.initState(); bloc = MyBloc(); &#125; @override void dispose()&#123; bloc?.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context)&#123; return BlocProvider&lt;MyBloc&gt;( bloc: bloc, child: Column( children: &lt;Widget&gt;[ MyChildWidget(), ], ), ); &#125;&#125; 使用这种方法，如果需要重建“ MyTree ”小部件，则不必重新实例化BLoC并直接重用现有实例。 2.3.仅适用于一个小部件这涉及BLoC仅由一个 Widget使用的情况。 在这种情况下，可以在Widget中实例化BLoC。 3.事件状态（允许根据事件响应状态转换）有时，处理一系列可能是顺序或并行，长或短，同步或异步以及可能导致各种结果的活动可能变得非常难以编程。您可能还需要更新显示以及进度或根据状态。 第一个用例旨在使这种情况更容易处理。 该解决方案基于以下原则： 发出一个事件; 此事件触发一些导致一个或多个状态的动作; 这些状态中的每一个都可以反过来发出其他事件或导致另一个状态; 然后，这些事件将根据活动状态触发其他操作; 等等… 为了说明这个概念，我们来看两个常见的例子： 应用初始化 假设您需要运行一系列操作来初始化应用程序。操作可能与服务器的交互相关联（例如，加载一些数据）。在此初始化过程中，您可能需要显示进度条和一系列图像以使用户等待。 认证 在启动时，应用程序可能需要用户进行身份验证或注册。用户通过身份验证后，将重定向到应用程序的主页面。然后，如果用户注销，则将其重定向到认证页面。 为了能够处理所有可能的情况，事件序列，但是如果我们认为可以在应用程序中的任何地方触发事件，这可能变得非常难以管理。 这就是BlocEventState，兼有BlocEventStateBuilder，可以帮助很多… 3.1. BlocEventStateBlocEventState背后的想法是定义一个BLoC： 接受事件作为输入; 当发出新事件时调用eventHandler; eventHandler 负责根据事件采取适当的行动并发出状态作为回应。 下图显示了这个想法： 这是这类的源代码。解释如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import 'package:blocs/bloc_helpers/bloc_provider.dart';import 'package:meta/meta.dart';import 'package:rxdart/rxdart.dart';abstract class BlocEvent extends Object &#123;&#125;abstract class BlocState extends Object &#123;&#125;abstract class BlocEventStateBase&lt;BlocEvent, BlocState&gt; implements BlocBase &#123; PublishSubject&lt;BlocEvent&gt; _eventController = PublishSubject&lt;BlocEvent&gt;(); BehaviorSubject&lt;BlocState&gt; _stateController = BehaviorSubject&lt;BlocState&gt;(); /// /// 要调用以发出事件 /// Function(BlocEvent) get emitEvent =&gt; _eventController.sink.add; /// /// 当前/新状态 /// Stream&lt;BlocState&gt; get state =&gt; _stateController.stream; /// /// 事件的外部处理 /// Stream&lt;BlocState&gt; eventHandler(BlocEvent event, BlocState currentState); /// /// initialState /// final BlocState initialState; // // 构造函数 // BlocEventStateBase(&#123; @required this.initialState, &#125;)&#123; // // 对于每个接收到的事件，我们调用[eventHandler]并发出任何结果的newState // _eventController.listen((BlocEvent event)&#123; BlocState currentState = _stateController.value ?? initialState; eventHandler(event, currentState).forEach((BlocState newState)&#123; _stateController.sink.add(newState); &#125;); &#125;); &#125; @override void dispose() &#123; _eventController.close(); _stateController.close(); &#125;&#125; 如您所见，这是一个需要扩展的抽象类，用于定义eventHandler方法的行为。 他公开： 一个Sink（emitEvent）来推送一个事件 ; 一个流（状态）来监听发射状态。 在初始化时（请参阅构造函数）： 一个初始化状态需要设置; 它创建了一个StreamSubscription听传入事件到 将它们发送到eventHandler 发出结果状态。 3.2. 专门的BlocEventState用于实现此类BlocEventState的模板在下面给出。之后，我们将实施真实的。1234567891011class TemplateEventStateBloc extends BlocEventStateBase&lt;BlocEvent, BlocState&gt; &#123; TemplateEventStateBloc() : super( initialState: BlocState.notInitialized(), ); @override Stream&lt;BlocState&gt; eventHandler( BlocEvent event, BlocState currentState) async* &#123; yield BlocState.notInitialized(); &#125;&#125; 如果这个模板不能编译，请不要担心……这是正常的，因为我们还没有定义BlocState.notInitialized（） ……这将在几分钟内出现。 此模板仅在初始化时提供initialState并覆盖eventHandler。 这里有一些非常有趣的事情需要注意。我们使用异步生成器：async * 和yield语句。 使用async *修饰符标记函数，将函数标识为异步生成器： 每次 yield 语句 被调用时，它增加了下面的表达式的结果 yield 输出stream。 这是非常有用的，如果我们需要发出一个序列的States，从一系列的行动所造成（我们将在后面看到，在实践中） 有关异步生成器的其他详细信息，请单击此链接。 3.3.BlocEvent和BlocState正如您所注意到的，我们已经定义了一个 BlocEvent 和 BlocState 抽象类。 这些类需要使用您要发出的特殊事件和状态进行扩展。 3.4. BlocEventStateBuilder小部件模式最后一部分的是BlocEventStateBuilder小部件，它允许你在响应State(s)，所发射的BlocEventState。 这是它的源代码：12345678910111213141516171819202122232425typedef Widget AsyncBlocEventStateBuilder&lt;BlocState&gt;(BuildContext context, BlocState state);class BlocEventStateBuilder&lt;BlocEvent,BlocState&gt; extends StatelessWidget &#123; const BlocEventStateBuilder(&#123; Key key, @required this.builder, @required this.bloc, &#125;): assert(builder != null), assert(bloc != null), super(key: key); final BlocEventStateBase&lt;BlocEvent,BlocState&gt; bloc; final AsyncBlocEventStateBuilder&lt;BlocState&gt; builder; @override Widget build(BuildContext context)&#123; return StreamBuilder&lt;BlocState&gt;( stream: bloc.state, initialData: bloc.initialState, builder: (BuildContext context, AsyncSnapshot&lt;BlocState&gt; snapshot)&#123; return builder(context, snapshot.data); &#125;, ); &#125;&#125; 这个Widget只是一个专门的StreamBuilder，它会在每次发出新的BlocState时调用builder输入参数。 好的。现在我们已经拥有了所有的部分，现在是时候展示我们可以用它们做些什么…… 3.5.案例1：应用程序初始化第一个示例说明了您需要应用程序在启动时执行某些任务的情况。 常见的用途是游戏最初显示启动画面（动画与否），同时从服务器获取一些文件，检查新的更新是否可用，尝试连接到任何游戏中心 ……在显示实际主屏幕之前。为了不给应用程序什么都不做的感觉，它可能会显示一个进度条并定期显示一些图片，同时它会完成所有初始化过程。 我要向您展示的实现非常简单。它只会在屏幕上显示一些竞争百分比，但这可以很容易地扩展到您的需求。 3.5.1。ApplicationInitializationEvent在这个例子中，我只考虑2个事件： start：此事件将触发初始化过程; stop：该事件可用于强制初始化进程停止。 这是定义代码实现：12345678910111213class ApplicationInitializationEvent extends BlocEvent &#123; final ApplicationInitializationEventType type; ApplicationInitializationEvent(&#123; this.type: ApplicationInitializationEventType.start, &#125;) : assert(type != null);&#125;enum ApplicationInitializationEventType &#123; start, stop,&#125; 3.5.2. ApplicationInitializationState 该类将提供与初始化过程相关的信息。 对于这个例子，我会考虑： 2标识：isInitialized指示初始化是否完成isInitializing以了解我们是否处于初始化过程的中间 进度完成率 这是它的源代码：1234567891011121314151617181920212223242526272829303132class ApplicationInitializationState extends BlocState &#123; ApplicationInitializationState(&#123; @required this.isInitialized, this.isInitializing: false, this.progress: 0, &#125;); final bool isInitialized; final bool isInitializing; final int progress; factory ApplicationInitializationState.notInitialized() &#123; return ApplicationInitializationState( isInitialized: false, ); &#125; factory ApplicationInitializationState.progressing(int progress) &#123; return ApplicationInitializationState( isInitialized: progress == 100, isInitializing: true, progress: progress, ); &#125; factory ApplicationInitializationState.initialized() &#123; return ApplicationInitializationState( isInitialized: true, progress: 100, ); &#125;&#125; 3.5.3. ApplicationInitializationBloc 该BLoC负责基于事件处理初始化过程。 这是代码：123456789101112131415161718192021222324252627class ApplicationInitializationBloc extends BlocEventStateBase&lt;ApplicationInitializationEvent, ApplicationInitializationState&gt; &#123; ApplicationInitializationBloc() : super( initialState: ApplicationInitializationState.notInitialized(), ); @override Stream&lt;ApplicationInitializationState&gt; eventHandler( ApplicationInitializationEvent event, ApplicationInitializationState currentState) async* &#123; if (!currentState.isInitialized)&#123; yield ApplicationInitializationState.notInitialized(); &#125; if (event.type == ApplicationInitializationEventType.start) &#123; for (int progress = 0; progress &lt; 101; progress += 10)&#123; await Future.delayed(const Duration(milliseconds: 300)); yield ApplicationInitializationState.progressing(progress); &#125; &#125; if (event.type == ApplicationInitializationEventType.stop)&#123; yield ApplicationInitializationState.initialized(); &#125; &#125;&#125; 一些解释： 当收到事件“ ApplicationInitializationEventType.start ”时，它从0开始计数到100(单位为10），并且对于每个值（0,10,20，……），它发出（通过yield）一个告诉的新状态初始化正在运行（isInitializing = true）及其进度值。 当收到事件”ApplicationInitializationEventType.stop”时，它认为初始化已完成。 正如你所看到的，我在计数器循环中放了一些延迟。这将向您展示如何使用任何Future（例如，您需要联系服务器的情况） 3.5.4. 将它们全部包装在一起现在，剩下的部分是显示显示计数器的伪Splash屏幕 …… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class InitializationPage extends StatefulWidget &#123; @override _InitializationPageState createState() =&gt; _InitializationPageState();&#125;class _InitializationPageState extends State&lt;InitializationPage&gt; &#123; ApplicationInitializationBloc bloc; @override void initState()&#123; super.initState(); bloc = ApplicationInitializationBloc(); bloc.emitEvent(ApplicationInitializationEvent()); &#125; @override void dispose()&#123; bloc?.dispose(); super.dispose(); &#125; @override Widget build(BuildContext pageContext) &#123; return SafeArea( child: Scaffold( body: Container( child: Center( child: BlocEventStateBuilder&lt;ApplicationInitializationEvent, ApplicationInitializationState&gt;( bloc: bloc, builder: (BuildContext context, ApplicationInitializationState state)&#123; if (state.isInitialized)&#123; // // Once the initialization is complete, let's move to another page // WidgetsBinding.instance.addPostFrameCallback((_)&#123; Navigator.of(context).pushReplacementNamed('/home'); &#125;); &#125; return Text('Initialization in progress... $&#123;state.progress&#125;%'); &#125;, ), ), ), ), ); &#125;&#125; 说明： 由于ApplicationInitializationBloc不需要在应用程序的任何地方使用，我们可以在StatefulWidget中初始化它; 我们直接发出ApplicationInitializationEventType.start事件来触发eventHandler 每次发出ApplicationInitializationState时，我们都会更新文本 初始化完成后，我们将用户重定向到主页。 特技 由于我们无法直接重定向到主页，在构建器内部，我们使用WidgetsBinding.instance.addPostFrameCallback（）方法请求Flutter 在渲染完成后立即执行方法 3.6. 案例2：应用程序身份验证和注销对于此示例，我将考虑以下用例： 在启动时，如果用户未经过身份验证，则会自动显示“ 身份验证/注册”页面; 在用户认证期间，显示CircularProgressIndicator ; 经过身份验证后，用户将被重定向到主页 ; 在应用程序的任何地方，用户都可以注销; 当用户注销时，用户将自动重定向到“ 身份验证”页面。 当然，很有可能以编程方式处理所有这些，但将所有这些委托给BLoC要容易得多。 下图解释了我要解释的解决方案： 名为“ DecisionPage ” 的中间页面将负责将用户自动重定向到“ 身份验证”页面或主页，具体取决于用户身份验证的状态。当然，此DecisionPage从不显示，也不应被视为页面。 3.6.1. AuthenticationEvent在这个例子中，我只考虑2个事件： login：当用户正确验证时发出此事件; logout：用户注销时发出的事件。 代码如下：1234567891011121314151617abstract class AuthenticationEvent extends BlocEvent &#123; final String name; AuthenticationEvent(&#123; this.name: '', &#125;);&#125;class AuthenticationEventLogin extends AuthenticationEvent &#123; AuthenticationEventLogin(&#123; String name, &#125;) : super( name: name, );&#125;class AuthenticationEventLogout extends AuthenticationEvent &#123;&#125; 3.6.2. AuthenticationState该类将提供与身份验证过程相关的信息。 对于这个例子，我会考虑： 3点：isAuthenticated指示身份验证是否完整isAuthenticating以了解我们是否处于身份验证过程的中间hasFailed表示身份验证失败 经过身份验证的用户名 这是它的源代码：1234567891011121314151617181920212223242526272829303132333435363738394041class AuthenticationState extends BlocState &#123; AuthenticationState(&#123; @required this.isAuthenticated, this.isAuthenticating: false, this.hasFailed: false, this.name: '', &#125;); final bool isAuthenticated; final bool isAuthenticating; final bool hasFailed; final String name; factory AuthenticationState.notAuthenticated() &#123; return AuthenticationState( isAuthenticated: false, ); &#125; factory AuthenticationState.authenticated(String name) &#123; return AuthenticationState( isAuthenticated: true, name: name, ); &#125; factory AuthenticationState.authenticating() &#123; return AuthenticationState( isAuthenticated: false, isAuthenticating: true, ); &#125; factory AuthenticationState.failure() &#123; return AuthenticationState( isAuthenticated: false, hasFailed: true, ); &#125;&#125; 3.6.3.AuthenticationBloc此BLoC负责根据事件处理身份验证过程。 这是代码： 12345678910111213141516171819202122232425262728293031class AuthenticationBloc extends BlocEventStateBase&lt;AuthenticationEvent, AuthenticationState&gt; &#123; AuthenticationBloc() : super( initialState: AuthenticationState.notAuthenticated(), ); @override Stream&lt;AuthenticationState&gt; eventHandler( AuthenticationEvent event, AuthenticationState currentState) async* &#123; if (event is AuthenticationEventLogin) &#123; //通知我们正在进行身份验证 yield AuthenticationState.authenticating(); //模拟对身份验证服务器的调用 await Future.delayed(const Duration(seconds: 2)); //告知我们是否已成功通过身份验证 if (event.name == "failure")&#123; yield AuthenticationState.failure(); &#125; else &#123; yield AuthenticationState.authenticated(event.name); &#125; &#125; if (event is AuthenticationEventLogout)&#123; yield AuthenticationState.notAuthenticated(); &#125; &#125;&#125; 一些解释： 当收到事件“ AuthenticationEventLogin ”时，它会（通过yield）发出一个新状态，告知身份验证正在运行（isAuthenticating = true）。 然后它运行身份验证，一旦完成，就会发出另一个状态，告知身份验证已完成。 当收到事件“ AuthenticationEventLogout ”时，它将发出一个新状态，告诉用户不再进行身份验证。 3.6.4. AuthenticationPage正如您将要看到的那样，为了便于解释，此页面非常基本且不会做太多。 这是代码。解释如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class AuthenticationPage extends StatelessWidget &#123; /// /// Prevents the use of the "back" button /// Future&lt;bool&gt; _onWillPopScope() async &#123; return false; &#125; @override Widget build(BuildContext context) &#123; AuthenticationBloc bloc = BlocProvider.of&lt;AuthenticationBloc&gt;(context); return WillPopScope( onWillPop: _onWillPopScope, child: SafeArea( child: Scaffold( appBar: AppBar( title: Text('Authentication Page'), leading: Container(), ), body: Container( child: BlocEventStateBuilder&lt;AuthenticationEvent, AuthenticationState&gt;( bloc: bloc, builder: (BuildContext context, AuthenticationState state) &#123; if (state.isAuthenticating) &#123; return PendingAction(); &#125; if (state.isAuthenticated)&#123; return Container(); &#125; List&lt;Widget&gt; children = &lt;Widget&gt;[]; // Button to fake the authentication (success) children.add( ListTile( title: RaisedButton( child: Text('Log in (success)'), onPressed: () &#123; bloc.emitEvent(AuthenticationEventLogin(name: 'Didier')); &#125;, ), ), ); // Button to fake the authentication (failure) children.add( ListTile( title: RaisedButton( child: Text('Log in (failure)'), onPressed: () &#123; bloc.emitEvent(AuthenticationEventLogin(name: 'failure')); &#125;, ), ), ); // Display a text if the authentication failed if (state.hasFailed)&#123; children.add( Text('Authentication failure!'), ); &#125; return Column( children: children, ); &#125;, ), ), ), ), ); &#125;&#125; 说明： 第11行：页面检索对AuthenticationBloc的引用 第24-70行：它监听发出的AuthenticationState： 如果身份验证正在进行中，它会显示一个CircularProgressIndicator，告诉用户正在进行某些操作并阻止用户访问该页面（第25-27行） 如果验证成功，我们不需要显示任何内容（第29-31行）。 如果用户未经过身份验证，则会显示2个按钮以模拟成功的身份验证和失败。 当我们点击其中一个按钮时，我们发出一个AuthenticationEventLogin事件，以及一些参数（通常由认证过程使用） 如果验证失败，我们会显示错误消息（第60-64行） 提示 您可能已经注意到，我将页面包装在WillPopScope中。理由是我不希望用户能够使用Android’后退’按钮，如此示例中所示，身份验证是一个必须的步骤，它阻止用户访问任何其他部分，除非经过正确的身份验证。 3.6.5. DecisionPage如前所述，我希望应用程序根据身份验证状态自动重定向到AuthenticationPage或HomePage。 以下是此DecisionPage的代码，说明如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243class DecisionPage extends StatefulWidget &#123; @override DecisionPageState createState() &#123; return new DecisionPageState(); &#125;&#125;class DecisionPageState extends State&lt;DecisionPage&gt; &#123; AuthenticationState oldAuthenticationState; @override Widget build(BuildContext context) &#123; AuthenticationBloc bloc = BlocProvider.of&lt;AuthenticationBloc&gt;(context); return BlocEventStateBuilder&lt;AuthenticationEvent, AuthenticationState&gt;( bloc: bloc, builder: (BuildContext context, AuthenticationState state) &#123; if (state != oldAuthenticationState)&#123; oldAuthenticationState = state; if (state.isAuthenticated)&#123; _redirectToPage(context, HomePage()); &#125; else if (state.isAuthenticating || state.hasFailed)&#123; //do nothing &#125; else &#123; _redirectToPage(context, AuthenticationPage()); &#125; &#125;//此页面不需要显示任何内容 //总是在任何活动页面后面提醒（因此“隐藏”）。 return Container(); &#125; ); &#125; void _redirectToPage(BuildContext context, Widget page)&#123; WidgetsBinding.instance.addPostFrameCallback((_)&#123; MaterialPageRoute newRoute = MaterialPageRoute( builder: (BuildContext context) =&gt; page ); Navigator.of(context).pushAndRemoveUntil(newRoute, ModalRoute.withName('/decision')); &#125;); &#125;&#125; 提醒 为了详细解释这一点，我们需要回到Flutter处理Pages（= Route）的方式。要处理路由，我们使用导航器，它创建一个叠加层。这个覆盖是一个堆栈的OverlayEntry，他们每个人的包含页面。当我们通过Navigator.of（上下文）推送，弹出，替换页面时，后者更新其重建的覆盖（因此堆栈）。当堆栈被重建，每个OverlayEntry（因此它的内容）也被重建。因此，当我们通过Navigator.of（上下文）进行操作时，所有剩余的页面都会重建！ 那么，为什么我将它实现为StatefulWidget？ 为了能够响应AuthenticationState的任何更改，此“ 页面 ”需要在应用程序的整个生命周期中保持存在。 这意味着，根据上面的提醒，每次Navigator.of（上下文）完成操作时，都会重建此页面。 因此，它的BlocEventStateBuilder也将重建，调用自己的构建器方法。 因为此构建器负责将用户重定向到与AuthenticationState对应的页面，所以如果我们每次重建页面时重定向用户，它将继续重定向，因为不断重建。 为了防止这种情况发生，我们只需要记住我们采取行动的最后一个AuthenticationState，并且只在收到另一个AuthenticationState时采取另一个动作。 这是如何运作的？ 如上所述，每次发出AuthenticationState时，BlocEventStateBuilder都会调用其构建器。 基于状态标志（isAuthenticated），我们知道我们需要向哪个页面重定向用户。 特技 由于我们无法直接从构建器重定向到另一个页面，因此我们使用WidgetsBinding.instance.addPostFrameCallback（）方法在呈现完成后请求Flutter执行方法 此外，由于我们需要在重定向用户之前删除任何现有页面，除了需要保留在所有情况下的此DecisionPage 之外，我们使用Navigator.of（context）.pushAndRemoveUntil（…）来实现此目的。 3.6.6、登出要让用户注销，您现在可以创建一个“ LogOutButton ”并将其放在应用程序的任何位置。 此按钮只需要发出AuthenticationEventLogout（）事件，这将导致以下自动操作链：1.它将由AuthenticationBloc处理2.反过来会发出一个AuthentiationState（isAuthenticated = false）3.这将由DecisionPage通过BlocEventStateBuilder处理4.这会将用户重定向到AuthenticationPage 3.6.7. AuthenticationBloc由于AuthenticationBloc需要提供给该应用程序的任何页面，我们也将注入它作为MaterialApp父母，如下所示1234567891011121314151617void main() =&gt; runApp(Application());class Application extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return BlocProvider&lt;AuthenticationBloc&gt;( bloc: AuthenticationBloc(), child: MaterialApp( title: 'BLoC Samples', theme: ThemeData( primarySwatch: Colors.blue, ), home: DecisionPage(), ), ); &#125;&#125; 4.表格验证（允许根据条目和验证控制表单的行为） BLoC的另一个有趣用途是当您需要验证表单时： 根据某些业务规则验证与TextField相关的条目; 根据规则显示验证错误消息; 根据业务规则自动化窗口小部件的可访问性。 我现在要做的一个例子是RegistrationForm，它由3个TextFields（电子邮件，密码，确认密码）和1个RaisedButton组成，以启动注册过程。 我想要实现的业务规则是： 该电子邮件必须是一个有效的电子邮件地址。如果不是，则需要显示消息。 该密码必须是有效的（必须包含至少8个字符，具有1个大写，小写1，图1和1个特殊字符）。如果无效，则需要显示消息。 在重新输入密码需要满足相同的验证规则和相同的密码。如果不相同，则需要显示消息。 在登记时，按钮可能只能激活所有的规则都是有效的。 4.1.RegistrationFormBloc该BLoC负责处理验证业务规则，如前所述。 源码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344class RegistrationFormBloc extends Object with EmailValidator, PasswordValidator implements BlocBase &#123; final BehaviorSubject&lt;String&gt; _emailController = BehaviorSubject&lt;String&gt;(); final BehaviorSubject&lt;String&gt; _passwordController = BehaviorSubject&lt;String&gt;(); final BehaviorSubject&lt;String&gt; _passwordConfirmController = BehaviorSubject&lt;String&gt;(); // // Inputs // Function(String) get onEmailChanged =&gt; _emailController.sink.add; Function(String) get onPasswordChanged =&gt; _passwordController.sink.add; Function(String) get onRetypePasswordChanged =&gt; _passwordConfirmController.sink.add; // // Validators // Stream&lt;String&gt; get email =&gt; _emailController.stream.transform(validateEmail); Stream&lt;String&gt; get password =&gt; _passwordController.stream.transform(validatePassword); Stream&lt;String&gt; get confirmPassword =&gt; _passwordConfirmController.stream.transform(validatePassword) .doOnData((String c)&#123; // If the password is accepted (after validation of the rules) // we need to ensure both password and retyped password match if (0 != _passwordController.value.compareTo(c))&#123; // If they do not match, add an error _passwordConfirmController.addError("No Match"); &#125; &#125;); // // Registration button Stream&lt;bool&gt; get registerValid =&gt; Observable.combineLatest3( email, password, confirmPassword, (e, p, c) =&gt; true ); @override void dispose() &#123; _emailController?.close(); _passwordController?.close(); _passwordConfirmController?.close(); &#125;&#125; 让我详细解释一下…… 我们首先初始化3个BehaviorSubject来处理表单的每个TextField的Streams。 我们公开了3个Function（String），它将用于接受来自TextFields的输入。 我们公开了3个Stream ，TextField将使用它来显示由它们各自的验证产生的潜在错误消息 我们公开了1个Stream ，它将被RaisedButton使用，以根据整个验证结果启用/禁用它。 好的，现在是时候深入了解更多细节…… 您可能已经注意到，此类的签名有点特殊。我们来回顾一下吧。 12345class RegistrationFormBloc extends Object with EmailValidator, PasswordValidator implements BlocBase &#123; ...&#125; with 关键字意味着这个类是使用混入(MIXINS)(在另一个类中重用一些类代码的一种方法)，为了能够使用with关键字，该类需要扩展Object类。这些mixin包含分别验证电子邮件和密码的代码。 有关详细信息，混入我建议你阅读从这篇大文章 Romain Rastel。 4.1.1. Validator Mixins我只会解释EmailValidator，因为PasswordValidator非常相似。 First, the code:1234567891011121314const String _kEmailRule = r"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$";class EmailValidator &#123; final StreamTransformer&lt;String,String&gt; validateEmail = StreamTransformer&lt;String,String&gt;.fromHandlers(handleData: (email, sink)&#123; final RegExp emailExp = new RegExp(_kEmailRule); if (!emailExp.hasMatch(email) || email.isEmpty)&#123; sink.addError('Entre a valid email'); &#125; else &#123; sink.add(email); &#125; &#125;);&#125; 该类公开了一个 final 函数（“ validateEmail ”），它是一个StreamTransformer。 提醒StreamTransformer被调用如下：stream.transform（StreamTransformer）。StreamTransformer通过transform方法从Stream引用它的输入。然后它处理此输入，并将转换后的输入重新注入初始Stream。 4.1.2. 为什么使用stream.transform（）？如前所述，如果验证成功，StreamTransformer会将输入重新注入Stream。为什么有用？ 以下是与Observable.combineLatest3（）相关的解释…此方法在它引用的所有Streams之前不会发出任何值，至少发出一个值。 让我们看看下面的图片来说明我们想要实现的目标。 如果用户输入电子邮件并且后者经过验证，它将由电子邮件流发出，该电子邮件流将是Observable.combineLatest3（）的一个输入;如果电子邮件地址无效，错误将被添加到流（和没有价值会流出流）;这同样适用于密码和重新输入密码 ;当所有这三个验证都成功时（意味着所有这三个流都会发出一个值），Observable.combineLatest3（）将依次发出一个真正的感谢“ （e，p，c）=&gt; true ”（见第35行）。 4.1.3. 验证2个密码我在互联网上看到了很多与这种比较有关的问题。存在几种解决方案，让我解释其中的两种。 4.1.3.1.基本解决方案 - 没有错误消息第一个解决方案可能是以下一个：123456Stream&lt;bool&gt; get registerValid =&gt; Observable.combineLatest3( email, password, confirmPassword, (e, p, c) =&gt; (0 == p.compareTo(c)) ); 这个解决方案只需验证两个密码，如果它们匹配，就会发出一个值（= true）。 我们很快就会看到，Register按钮的可访问性将取决于registerValid流。 如果两个密码不匹配，则该流不会发出任何值，并且“ 注册”按钮保持不活动状态，但用户不会收到任何错误消息以帮助他理解原因。 4.1.3.2。带错误消息的解决方案另一种解决方案包括扩展confirmPassword流的处理，如下所示： 123456789Stream&lt;String&gt; get confirmPassword =&gt; _passwordConfirmController.stream.transform(validatePassword) .doOnData((String c)&#123; //如果接受密码（在验证规则后） //我们需要确保密码和重新输入的密码匹配 if (0 != _passwordController.value.compareTo(c))&#123; //如果它们不匹配，请添加错误 _passwordConfirmController.addError("No Match"); &#125; &#125;); 一旦验证了重新输入密码，它就会被Stream发出，并且使用doOnData，我们可以直接获取此发出的值并将其与密码流的值进行比较。如果两者不匹配，我们现在可以发送错误消息。 4.2. The RegistrationForm现在让我们先解释一下RegistrationForm：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class RegistrationForm extends StatefulWidget &#123; @override _RegistrationFormState createState() =&gt; _RegistrationFormState();&#125;class _RegistrationFormState extends State&lt;RegistrationForm&gt; &#123; RegistrationFormBloc _registrationFormBloc; @override void initState() &#123; super.initState(); _registrationFormBloc = RegistrationFormBloc(); &#125; @override void dispose() &#123; _registrationFormBloc?.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Form( child: Column( children: &lt;Widget&gt;[ StreamBuilder&lt;String&gt;( stream: _registrationFormBloc.email, builder: (BuildContext context, AsyncSnapshot&lt;String&gt; snapshot) &#123; return TextField( decoration: InputDecoration( labelText: 'email', errorText: snapshot.error, ), onChanged: _registrationFormBloc.onEmailChanged, keyboardType: TextInputType.emailAddress, ); &#125;), StreamBuilder&lt;String&gt;( stream: _registrationFormBloc.password, builder: (BuildContext context, AsyncSnapshot&lt;String&gt; snapshot) &#123; return TextField( decoration: InputDecoration( labelText: 'password', errorText: snapshot.error, ), obscureText: false, onChanged: _registrationFormBloc.onPasswordChanged, ); &#125;), StreamBuilder&lt;String&gt;( stream: _registrationFormBloc.confirmPassword, builder: (BuildContext context, AsyncSnapshot&lt;String&gt; snapshot) &#123; return TextField( decoration: InputDecoration( labelText: 'retype password', errorText: snapshot.error, ), obscureText: false, onChanged: _registrationFormBloc.onRetypePasswordChanged, ); &#125;), StreamBuilder&lt;bool&gt;( stream: _registrationFormBloc.registerValid, builder: (BuildContext context, AsyncSnapshot&lt;bool&gt; snapshot) &#123; return RaisedButton( child: Text('Register'), onPressed: (snapshot.hasData &amp;&amp; snapshot.data == true) ? () &#123; // launch the registration process &#125; : null, ); &#125;), ], ), ); &#125;&#125; 说明： 由于RegisterFormBloc仅供此表单使用，因此适合在此处初始化它。 每个TextField都包装在StreamBuilder 中，以便能够响应验证过程的任何结果（请参阅errorText：snapshot.error） 每次对TextField的内容进行修改时，我们都会通过onChanged发送输入到BLoC进行验证：_registrationFormBloc.onEmailChanged（电子邮件输入的情况） 对于RegisterButton，后者也包含在StreamBuilder 中。 如果_registrationFormBloc.registerValid发出一个值，onPressed方法将执行某些操作 如果未发出任何值，则onPressed方法将被指定为null，这将取消激活该按钮。 而已！表单中没有任何业务规则，这意味着可以更改规则而无需对表单进行任何修改，这非常好！ 5.Part Of（允许Widget根据其在列表中的存在来调整其行为）有时，Widget知道它是否是驱动其行为的集合的一部分是有趣的。 对于本文的最后一个用例，我将考虑以下场景： 应用程序处理项目;用户可以选择放入购物篮的物品;一件商品只能放入购物篮一次;存放在购物篮中的物品可以从购物篮中取出;一旦被移除，就可以将其取回。 对于此示例，每个项目将显示一个按钮，该按钮将取决于购物篮中物品的存在。如果不是购物篮的一部分，该按钮将允许用户将其添加到购物篮中。如果是购物篮的一部分，该按钮将允许用户将其从篮子中取出。 为了更好地说明“ 部分 ”模式，我将考虑以下架构： 一个购物页面将显示所有可能的项目清单;购物页面中的每个商品都会显示一个按钮，用于将商品添加到购物篮或将其移除，具体取决于其在购物篮中的位置;如果一个项目在购物页被添加到篮，它的按钮将自动更新，以允许用户从所述篮（反之亦然）将其删除，而不必重新生成购物页另一页，购物篮，将列出篮子里的所有物品;可以从此页面中删除购物篮中的任何商品。 边注Part Of这个名字是我给的个人名字。这不是官方名称。 正如您现在可以想象的那样，我们需要考虑一个专门用于处理所有可能项目列表的BLoC，以及购物篮的一部分。 这个BLoC可能如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class ShoppingBloc implements BlocBase &#123; // 所有商品的清单，购物篮的一部分 Set&lt;ShoppingItem&gt; _shoppingBasket = Set&lt;ShoppingItem&gt;(); // 流到所有可能项目的列表 BehaviorSubject&lt;List&lt;ShoppingItem&gt;&gt; _itemsController = BehaviorSubject&lt;List&lt;ShoppingItem&gt;&gt;(); Stream&lt;List&lt;ShoppingItem&gt;&gt; get items =&gt; _itemsController; // Stream以列出购物篮中的项目部分 BehaviorSubject&lt;List&lt;ShoppingItem&gt;&gt; _shoppingBasketController = BehaviorSubject&lt;List&lt;ShoppingItem&gt;&gt;(seedValue: &lt;ShoppingItem&gt;[]); Stream&lt;List&lt;ShoppingItem&gt;&gt; get shoppingBasket =&gt; _shoppingBasketController; @override void dispose() &#123; _itemsController?.close(); _shoppingBasketController?.close(); &#125; //构造函数 ShoppingBloc() &#123; _loadShoppingItems(); &#125; void addToShoppingBasket(ShoppingItem item)&#123; _shoppingBasket.add(item); _postActionOnBasket(); &#125; void removeFromShoppingBasket(ShoppingItem item)&#123; _shoppingBasket.remove(item); _postActionOnBasket(); &#125; void _postActionOnBasket()&#123; // 使用新内容提供购物篮流 _shoppingBasketController.sink.add(_shoppingBasket.toList()); // 任何其他处理，如 // 计算篮子的总价 // 项目数量，篮子的一部分...... &#125; // //生成一系列购物项目 //通常这应该来自对服务器的调用 //但是对于这个样本，我们只是模拟 // void _loadShoppingItems() &#123; _itemsController.sink.add(List&lt;ShoppingItem&gt;.generate(50, (int index) &#123; return ShoppingItem( id: index, title: "Item $index", price: ((Random().nextDouble() * 40.0 + 10.0) * 100.0).roundToDouble() / 100.0, color: Color((Random().nextDouble() * 0xFFFFFF).toInt() &lt;&lt; 0) .withOpacity(1.0), ); &#125;)); &#125;&#125; 唯一可能需要解释的方法是_postActionOnBasket（）方法。每次在篮子中添加或删除项目时，我们都需要“刷新” _shoppingBasketController Stream 的内容，以便通知所有正在监听此Stream更改的Widgets并能够刷新/重建。 5.2. ShoppingPage此页面非常简单，只显示所有项目。 123456789101112131415161718192021222324252627282930313233343536373839class ShoppingPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; ShoppingBloc bloc = BlocProvider.of&lt;ShoppingBloc&gt;(context); return SafeArea( child: Scaffold( appBar: AppBar( title: Text('Shopping Page'), actions: &lt;Widget&gt;[ ShoppingBasket(), ], ), body: Container( child: StreamBuilder&lt;List&lt;ShoppingItem&gt;&gt;( stream: bloc.items, builder: (BuildContext context, AsyncSnapshot&lt;List&lt;ShoppingItem&gt;&gt; snapshot) &#123; if (!snapshot.hasData) &#123; return Container(); &#125; return GridView.builder( gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 3, childAspectRatio: 1.0, ), itemCount: snapshot.data.length, itemBuilder: (BuildContext context, int index) &#123; return ShoppingItemWidget( shoppingItem: snapshot.data[index], ); &#125;, ); &#125;, ), ), )); &#125;&#125; 说明： 所述AppBar显示按钮，： 显示出现在购物篮中的商品数量 单击时将用户重定向到ShoppingBasket页面 项目列表使用GridView构建，包含在StreamBuilder &lt;List &gt;中 每个项目对应一个ShoppingItemWidget 5.3.ShoppingBasketPage此页面与ShoppingPage非常相似，只是StreamBuilder现在正在侦听由ShoppingBloc公开的_shoppingBasket流的变体。 5.4. ShoppingItemWidget和ShoppingItemBlocPart Of 模式依赖于这两个元素的组合 该ShoppingItemWidget负责：显示项目和用于在购物篮中添加项目或从中取出项目的按钮 该ShoppingItemBloc负责告诉ShoppingItemWidget后者是否是购物篮的一部分，或者不是。让我们看看他们如何一起工作…… 5.4.1. ShoppingItemBlocShoppingItemBloc由每个ShoppingItemWidget实例化，赋予它“身份” 此BLoC侦听ShoppingBasket流的所有变体，并检查特定项目标识是否是篮子的一部分。 如果是，它会发出一个布尔值（= true），它将被ShoppingItemWidget捕获，以确定它是否是篮子的一部分。 这是BLoC的代码：123456789101112131415161718192021222324252627class ShoppingItemBloc implements BlocBase &#123; // Stream，如果ShoppingItemWidget是购物篮的一部分，则通知 BehaviorSubject&lt;bool&gt; _isInShoppingBasketController = BehaviorSubject&lt;bool&gt;(); Stream&lt;bool&gt; get isInShoppingBasket =&gt; _isInShoppingBasketController; //收到所有商品列表的流，购物篮的一部分 PublishSubject&lt;List&lt;ShoppingItem&gt;&gt; _shoppingBasketController = PublishSubject&lt;List&lt;ShoppingItem&gt;&gt;(); Function(List&lt;ShoppingItem&gt;) get shoppingBasket =&gt; _shoppingBasketController.sink.add; //具有shoppingItem的“标识”的构造方法 ShoppingItemBloc(ShoppingItem shoppingItem)&#123; //每次购物篮内容的变化 _shoppingBasketController.stream //我们检查这个shoppingItem是否是购物篮的一部分 .map((list) =&gt; list.any((ShoppingItem item) =&gt; item.id == shoppingItem.id)) // if it is part .listen((isInShoppingBasket) // we notify the ShoppingItemWidget =&gt; _isInShoppingBasketController.add(isInShoppingBasket)); &#125; @override void dispose() &#123; _isInShoppingBasketController?.close(); _shoppingBasketController?.close(); &#125;&#125; 5.4.2。ShoppingItemWidget此Widget负责： 创建ShoppingItemBloc的实例并将其自己的标识传递给BLoC 监听ShoppingBasket内容的任何变化并将其转移到BLoC 监听ShoppingItemBloc知道它是否是篮子的一部分 显示相应的按钮（添加/删除），具体取决于它在篮子中的存在 响应按钮的用户操作当用户点击添加按钮时，将自己添加到购物篮中当用户点击删除按钮时，将自己从篮子中移除。 让我们看看它是如何工作的（解释在代码中给出）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111class ShoppingItemWidget extends StatefulWidget &#123; ShoppingItemWidget(&#123; Key key, @required this.shoppingItem, &#125;) : super(key: key); final ShoppingItem shoppingItem; @override _ShoppingItemWidgetState createState() =&gt; _ShoppingItemWidgetState();&#125;class _ShoppingItemWidgetState extends State&lt;ShoppingItemWidget&gt; &#123; StreamSubscription _subscription; ShoppingItemBloc _bloc; ShoppingBloc _shoppingBloc; @override void didChangeDependencies() &#123; super.didChangeDependencies(); //由于不应在“initState（）”方法中使用上下文， //在需要时更喜欢使用“didChangeDependencies（）” //在初始化时引用上下文 _initBloc(); &#125; @override void didUpdateWidget(ShoppingItemWidget oldWidget) &#123; super.didUpdateWidget(oldWidget); //因为Flutter可能决定重新组织Widgets树 //最好重新创建链接 _disposeBloc(); _initBloc(); &#125; @override void dispose() &#123; _disposeBloc(); super.dispose(); &#125; //这个例程对于创建链接是可靠的 void _initBloc() &#123; //创建ShoppingItemBloc的实例 _bloc = ShoppingItemBloc(widget.shoppingItem); //检索处理购物篮内容的BLoC _shoppingBloc = BlocProvider.of&lt;ShoppingBloc&gt;(context); //传输购物内容的简单管道 //购物篮子到ShoppingItemBloc _subscription = _shoppingBloc.shoppingBasket.listen(_bloc.shoppingBasket); &#125; void _disposeBloc() &#123; _subscription?.cancel(); _bloc?.dispose(); &#125; Widget _buildButton() &#123; return StreamBuilder&lt;bool&gt;( stream: _bloc.isInShoppingBasket, initialData: false, builder: (BuildContext context, AsyncSnapshot&lt;bool&gt; snapshot) &#123; return snapshot.data ? _buildRemoveFromShoppingBasket() : _buildAddToShoppingBasket(); &#125;, ); &#125; Widget _buildAddToShoppingBasket()&#123; return RaisedButton( child: Text('Add...'), onPressed: ()&#123; _shoppingBloc.addToShoppingBasket(widget.shoppingItem); &#125;, ); &#125; Widget _buildRemoveFromShoppingBasket()&#123; return RaisedButton( child: Text('Remove...'), onPressed: ()&#123; _shoppingBloc.removeFromShoppingBasket(widget.shoppingItem); &#125;, ); &#125; @override Widget build(BuildContext context) &#123; return Card( child: GridTile( header: Center( child: Text(widget.shoppingItem.title), ), footer: Center( child: Text('$&#123;widget.shoppingItem.price&#125; €'), ), child: Container( color: widget.shoppingItem.color, child: Center( child: _buildButton(), ), ), ), ); &#125;&#125; 5.5. 这一切如何运作？下图显示了所有部分如何协同工作。 结论另一篇长篇文章，我希望我能缩短一点，但我认为值得一些解释。 正如我在介绍中所说，我个人在我的开发中经常使用这些“ 模式 ”。这让我节省了大量的时间和精力; 我的代码更易读，更容易调试。 此外，它有助于将业务与视图分离。 大多数肯定有其他方法可以做到这一点，甚至更好的方式，但它只对我有用，这就是我想与你分享的一切。 请继续关注新文章，同时祝您编程愉快。]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter-BLoC-第一讲]]></title>
    <url>%2F2019%2F03%2F14%2FFlutter-BLoC-%E7%AC%AC%E4%B8%80%E8%AE%B2%2F</url>
    <content type="text"><![CDATA[【译文】Reactive Programming - Streams - BLoC[toc]注：此处的”toc”应显示为目录，但是简书不支持，显示不出来。 本译文介绍Streams、Bloc 和 Reactive Programming 的概念。理论和实践范例。对于作者的个人note没有进行翻译，请自行翻阅原文地址 原文原码。和iOS开发中的RAC相似，本文推荐重点在 &lt;如何基于流出的数据构建Widge&gt;！ 难度：中级 本文纪实 本译文的原文是在学 BLoC 的 第三方框架 (框架的教程)而看到的推荐链接进入该文章，为了更好的实现Flutter的BLoC而进行的翻译学习，翻译完也到了文章底部竟然有推荐中文翻译 链接， 那本篇就孤芳自赏吧！也顺便记录下自己的第一篇国外技术译文吧！推荐读者结合原文 看译文效果会更佳。笔者本文学习目的： 解耦 什么是流？ 介绍 :为了便于想象Stream的概念，只需考虑一个带有两端的管道，只有一个允许在其中插入一些东西。当你将某物插入管道时，它会在管道内流动并从另一端流出。 在Flutter中 管道称为 Stream 通常(*)使用StreamController来控制Stream 为了插入东西到Stream中，StreamController公开了”入口”名为StreamSink，可以sink属性进行访问你 StreamController通过stream属性公开了Stream的出口 注意： (*)：我故意使用术语”通常”，因为很可能不使用任何StreamController。但是，正如你将在本文中阅读的那样，我将只使用StreamControllers。 Stream可以传递什么？所有类型值都可以通过流传递。从值，事件，对象，集合，映射，错误或甚至另一个流，可以由stream传达任何类型的数据。 我怎么知道Stream传递的东西？当你需要通知Stream传达某些内容时，你只需要监听StreamController 的stream属性。 定义监听器时，你会收到StreamSubscription对象。通过StreamSubscription对象，你将收到由Stream发生变化而触发通知。 只要有至少一个活动 监听器，Stream就会开始生成事件，以便每次都通知活动的 StreamSubscription对象： 一些数据来自流， 当一些错误发送到流时， 当流关闭时。 StreamSubscription对象也可以允许以下操作： 停止听 暂停， 恢复。 Stream只是一个简单的管道吗？不，Stream还允许在流出之前处理流入其中的数据。 为了控制Stream内部数据的处理，我们使用StreamTransformer，它只是 一个“捕获” Stream内部流动数据的函数 对数据做一些处理 这种转变的结果也是一个Stream 你将直接从该声明中了解到，可以按顺序使用多个StreamTransformer。 StreamTransformer可以用进行任何类型的处理，例如： 过滤(filtering)：根据任何类型的条件过滤数据， 重新组合(regrouping)：重新组合数据， 修改(modification)：对数据应用任何类型的修改， 将数据注入其他流， 缓冲， 处理(processing)：根据数据进行任何类型的操作/操作， … Stream流的类型 Stream有两种类型。 单订阅Stream这种类型的Stream只允许在该Stream的整个生命周期内使用单个监听器。 即在第一个订阅被取消后，也无法在此类流上收听两次。 广播流第二种类型的Stream允许任意数量的监听器。 可以随时向广播流添加监听器。新的监听器将在它开始收听Stream时收到事件。 基本的例子任何类型的数据第一个示例显示了“单订阅” 流，它只是打印输入的数据。你可能会看到无关紧要的数据类型。 streams_1.dart123456789101112131415161718192021222324252627import 'dart:async';void main() &#123; // // 初始化“单订阅”流控制器 // final StreamController ctrl = StreamController(); // //初始化一个只打印数据的监听器 //一收到它 // final StreamSubscription subscription = ctrl.stream.listen((data) =&gt; print('$data')); // // 我们在这里添加将会流进Stream中的数据 // ctrl.sink.add('my name'); ctrl.sink.add(1234); ctrl.sink.add(&#123;'a': 'element A', 'b': 'element B'&#125;); ctrl.sink.add(123.45); // // 我们发布了StreamController // ctrl.close();&#125; StreamTransformer第二个示例显示“ 广播 ” 流，它传达整数值并仅打印偶数。为此，我们应用StreamTransformer来过滤（第14行）值，只让偶数经过。 12345678910111213141516171819202122232425262728import 'dart:async';void main() &#123; // // Initialize a "Broadcast" Stream controller of integers // final StreamController&lt;int&gt; ctrl = StreamController&lt;int&gt;.broadcast(); // // Initialize a single listener which filters out the odd numbers and // only prints the even numbers // final StreamSubscription subscription = ctrl.stream .where((value) =&gt; (value % 2 == 0)) .listen((value) =&gt; print('$value')); // // We here add the data that will flow inside the stream // for(int i=1; i&lt;11; i++)&#123; ctrl.sink.add(i); &#125; // // We release the StreamController // ctrl.close();&#125; RxDart所述RxDart包是用于执行 Dart 所述的ReactiveX API，它扩展了原始达特流 API符合ReactiveX标准。由于它最初并未由Google定义，因此它使用不同的词汇表。下表给出了Dart和RxDart之间的相关性。 Dart RxDart Stream Observable StreamController Subject 正如刚才所说，RxDart 扩展了原始的Dart Streams API并提供了StreamController的 3个主要变体： PublishSubject PublishSubject是普通的广播 StreamController， 有一个例外：Stream返回一个Observable，而不是Stream。 如你所见，PublishSubject仅向监听器发送在订阅之后添加到Stream的事件。 BehaviorSubject 该BehaviorSubject也是广播 StreamController，它返回一个Observable，而不是Stream。 与PublishSubject的主要区别在于BehaviorSubject还将最后发送的事件发送给刚刚订阅的监听器。 ReplaySubject ReplaySubject 也是一个广播StreamController，它返回一个Observable，而不是Stream。 默认情况下，ReplaySubject将Stream已经发出的所有事件作为第一个事件发送给任何新的监听器。 关于资源的重要说明 经常释放不再需要的资源是一种非常好的做法。本声明适用于： StreamSubscription - 当你不再需要监听Stream时，取消订阅; StreamController - 当你不再需要StreamController时，关闭它; 这同样适用于RxDart主题，当你不再需要BehaviourSubject，PublishSubject …时，请将其关闭。 如何基于由Stream提供的数据构建Widget？（重点）Flutter提供了一个非常方便的StatefulWidget，名为StreamBuilder。 StreamBuilder监听Stream，每当某些数据输出Stream时，它会自动重建，调用其builder callback。 这是如何使用StreamBuilder： 1234567891011StreamBuilder&lt;T&gt;( key: ...optional, the unique ID of this Widget... stream: ...the stream to listen to... initialData: ...any initial data, in case the stream would initially be empty... builder: (BuildContext context, AsyncSnapshot&lt;T&gt; snapshot)&#123; if (snapshot.hasData)&#123; return ...the Widget to be built based on snapshot.data &#125; return ...the Widget to be built if no data is available &#125;,) 以下示例模仿默认的 “计数器” 应用程序，但使用Stream而不再使用任何setState。12345678910111213141516171819202122232425262728293031323334353637383940414243import 'dart:async';import 'package:flutter/material.dart';class CounterPage extends StatefulWidget &#123; @override _CounterPageState createState() =&gt; _CounterPageState();&#125;class _CounterPageState extends State&lt;CounterPage&gt; &#123; int _counter = 0; final StreamController&lt;int&gt; _streamController = StreamController&lt;int&gt;(); @override void dispose()&#123; _streamController.close(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(title: Text('Stream version of the Counter App')), body: Center( // 我们正在监听流，每次有一个新值流出这个流时，我们用该值更新Text ; child: StreamBuilder&lt;int&gt;( stream: _streamController.stream, initialData: _counter, builder: (BuildContext context, AsyncSnapshot&lt;int&gt; snapshot)&#123; return Text('You hit me: $&#123;snapshot.data&#125; times'); &#125; ), ), floatingActionButton: FloatingActionButton( child: const Icon(Icons.add), onPressed: ()&#123; //当我们点击FloatingActionButton时，增加计数器并通过sink将其发送到Stream； //事实上 注入到stream中值会导致监听它(stream)的StreamBuilder重建并 ‘刷新’计数器; _streamController.sink.add(++_counter); &#125;, ), ); &#125;&#125; 注意点： 24-30行： 我们不再需要state的概念，所有东西都通过Stream接受; 第35行：当我们点击FloatingActionButton时，我们递增计数器并通过接收器将其发送到Stream; 在流中注入值的事实导致侦听它的StreamBuilder重建并“刷新”计数器; 这是一个很大的改进，因为实际调用setState（）方法的，会强制整个 Widget（和任何子小部件）重建。这里，只有StreamBuilder被重建（当然它的子部件，被streamBuilder包裹的子控件）; 我们仍然在为页面使用StatefulWidget的唯一原因，仅仅是因为我们需要通过dispose方法第15行释放StreamController ; 什么是反应式编程？ 反应式编程是使用异步数据流进行编程。换句话说，任何东西比如从事件（例如点击），变量的变化，消息，……到构建请求，可能改变或发生的所有事件的所有内容都将被传送，由数据流触发。 很明显，所有这些意味着，通过反应式编程，应用程序： 变得异步 围绕Streams和listeners的概念进行架构 当某事发生在某处（事件，变量的变化……）时，会向Stream发送通知 如果 “某人” 监听该流（无论其在应用程序中的任何位置），它将被通知并将采取适当的行动. 组件之间不再存在紧密耦合。 简而言之，当Widget向Stream发送内容时，该Widget 不再需要知道： 接下来会发生什么 谁可能使用这些信息（没有一个，一个或几个小部件……） 可能使用此信息的地方（无处，同一屏幕，另一个，几个…） 当这些信息可能被使用时（几乎是直接，几秒钟之后，永远不会……） …… Widget只关心自己的事业，就是这样！ 乍一看，读到这个，这似乎会导致应用程序“ 无法控制 ”，但正如我们将看到的，情况正好相反。它给你： 构建仅负责特定活动的部分应用程序的机会 轻松模拟一些组件的行为，以允许更完整的测试覆盖 轻松重用组件（当前应用程序或其他应用程序中的其他位置）， 重新设计应用程序，并能够在不进行太多重构的情况下将组件从一个地方移动到另一个地方， 我们将很快看到优势……但在我需要介绍最后一个主题之前：BLoC模式。 BLoC 模式 BLoC模式由Paolo Soares 和 Cong Hui设计，并谷歌在2018的 DartConf 首次提出，可以在 YouTube 上观看。 BLoC表示为业务逻辑组件 (Business Logic Component) 简而言之， Business Logic需要： 转移到一个或几个BLoC， 尽可能从表示层(Presentation Layer)中删除。换句话说，UI组件应该只关心UI事物而不关心业务 依赖 Streams 独家使用输入（Sink）和输出（stream） 保持平台独立 保持环境独立 事实上，BLoC模式最初被设想为允许独立于平台重用相同的代码：Web应用程序，移动应用程序，后端。 它究竟意味着什么？ BLoC模式 是利用我们刚才上面所讨论的观念：Streams （流） Widgets 通过 Sinks 向 BLoC 发送事件(event) BLoC 通过流(stream)通知小部件(widgets) 由BLoC实现的业务逻辑不是他们关注的问题。 从这个声明中，我们可以直接看到一个巨大的好处。 由于业务逻辑与UI的分离： 我们可以随时更改业务逻辑，对应用程序的影响最小 我们可能会更改UI而不会对业务逻辑产生任何影响， 现在，测试业务逻辑变得更加容易。 如何将此 BLoC 模式应用于 Counter 应用程序示例中将 BLoC 模式应用于此计数器应用程序似乎有点矫枉过正，但让我先向你展示…… 代码： streams_4.dart12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: 'Streams Demo', theme: new ThemeData( primarySwatch: Colors.blue, ), home: BlocProvider&lt;IncrementBloc&gt;( bloc: IncrementBloc(), child: CounterPage(), ), ); &#125;&#125;class CounterPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; final IncrementBloc bloc = BlocProvider.of&lt;IncrementBloc&gt;(context); return Scaffold( appBar: AppBar(title: Text('Stream version of the Counter App')), body: Center( child: StreamBuilder&lt;int&gt;( stream: bloc.outCounter, initialData: 0, builder: (BuildContext context, AsyncSnapshot&lt;int&gt; snapshot)&#123; return Text('You hit me: $&#123;snapshot.data&#125; times'); &#125; ), ), floatingActionButton: FloatingActionButton( child: const Icon(Icons.add), onPressed: ()&#123; bloc.incrementCounter.add(null); &#125;, ), ); &#125;&#125;class IncrementBloc implements BlocBase &#123; int _counter; // // Stream来处理计数器 // StreamController&lt;int&gt; _counterController = StreamController&lt;int&gt;(); StreamSink&lt;int&gt; get _inAdd =&gt; _counterController.sink; Stream&lt;int&gt; get outCounter =&gt; _counterController.stream; // // Stream来处理计数器上的操作 // StreamController _actionController = StreamController(); StreamSink get incrementCounter =&gt; _actionController.sink; // // Constructor // IncrementBloc()&#123; _counter = 0; _actionController.stream .listen(_handleLogic); &#125; void dispose()&#123; _actionController.close(); _counterController.close(); &#125; void _handleLogic(data)&#123; _counter = _counter + 1; _inAdd.add(_counter); &#125;&#125; 我已经听到你说“ 哇……为什么这一切？这都是必要的吗？”。 第一 是责任分离12345678910如果你检查CounterPage（第21-45行），其中绝对没有任何业务逻辑。此页面现在仅负责：&gt; * 显示计数器，现在只在必要时刷新（即使没有页面必须知道它）&gt; * 提供按钮，当按下时，将会在counter面板上请求一个动作此外，整个业务逻辑集中在一个单独的类“ IncrementBloc”中。如果现在，你需要更改业务逻辑，你只需更新方法_handleLogic（第77-80行）。也许新的业务逻辑将要求做非常复杂的事情...... CounterPage永远不会知道它，这是非常好的！ 第二 可测试性123现在，测试业务逻辑变得更加容易。无需再通过用户界面测试业务逻辑。只需要测试IncrementBloc类。 第三 自由组织布局12345由于使用了Streams，你现在可以独立于业务逻辑组织布局。可以从应用程序中的任何位置启动任何操作：只需调用.incrementCounter sink即可。你可以在任何页面的任何位置显示计数器，只需听取.outCounter stream。 第四 减少“build”的次数123不使用setState（）而是使用StreamBuilder这一事实大大减少了“ 构建 ”的次数，只减少了所需的次数。从性能角度来看，这是一个巨大的进步。 只有一个约束…… BLoC的可访问性为了让所有这些工作，BLoC需要可访问。 有几种方法可以访问它： 通过全局单例这种方式很有简单，但不是真的推荐。此外，由于Dart中没有类析构函数，因此你永远无法正确释放资源。 作为局部变量(本地实例)你可以实例化BLoC的本地实例。在某些情况下，此解决方案完全符合某些需求。在这种情况下，你应该始终考虑在StatefulWidget中初始化，以便你可以利用dispose（）方法来释放它。 由父类提供使其可访问的最常见方式是通过祖先 Widget，实现为StatefulWidget。 以下代码显示了通用 BlocProvider的示例。代码： streams_51234567891011121314151617181920212223242526272829303132333435363738394041//所有BLoC的通用接口abstract class BlocBase &#123; void dispose();&#125;//通用BLoC提供商class BlocProvider&lt;T extends BlocBase&gt; extends StatefulWidget &#123; BlocProvider(&#123; Key key, @required this.child, @required this.bloc, &#125;): super(key: key); final T bloc; final Widget child; @override _BlocProviderState&lt;T&gt; createState() =&gt; _BlocProviderState&lt;T&gt;(); static T of&lt;T extends BlocBase&gt;(BuildContext context)&#123; final type = _typeOf&lt;BlocProvider&lt;T&gt;&gt;(); BlocProvider&lt;T&gt; provider = context.ancestorWidgetOfExactType(type); return provider.bloc; &#125; static Type _typeOf&lt;T&gt;() =&gt; T;&#125;class _BlocProviderState&lt;T&gt; extends State&lt;BlocProvider&lt;BlocBase&gt;&gt;&#123; @override /// 便于资源的释放 void dispose()&#123; widget.bloc.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context)&#123; return widget.child; &#125;&#125; 关于这种通用BlocProvider的一些解释首先，如何将其作为provider使用？ 如果你查看示例代码“ streams_4.dart ”，你将看到以下代码行（第12-15行） 1234home: BlocProvider&lt;IncrementBloc&gt;( bloc: IncrementBloc(), child: CounterPage(), ), 通过这些代码，我们只需实例化一个新的BlocProvider，它将处理一个IncrementBloc，并将CounterPage作为子项呈现。 从那一刻开始，从BlocProvider开始的子树的任何小部件部分都将能够通过以下代码访问IncrementBloc： 1IncrementBloc bloc = BlocProvider.of&lt;IncrementBloc&gt;(context); 可以使用多个BLoC吗？ 当然，这是非常可取的。建议是： （如果有任何业务逻辑）每页顶部有一个BLoC， 为什么不是ApplicationBloc来处理应用程序状态？ 每个“足够复杂的组件”都有相应的BLoC。 以下示例代码在整个应用程序的顶部显示ApplicationBloc，然后在CounterPage顶部显示IncrementBloc。 该示例还显示了如何检索两个blocs。 代码 streams_6.dart1234567891011121314151617181920212223242526272829void main() =&gt; runApp( BlocProvider&lt;ApplicationBloc&gt;( bloc: ApplicationBloc(), child: MyApp(), ));class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context)&#123; return MaterialApp( title: 'Streams Demo', home: BlocProvider&lt;IncrementBloc&gt;( bloc: IncrementBloc(), child: CounterPage(), ), ); &#125;&#125;class CounterPage extends StatelessWidget &#123; @override Widget build(BuildContext context)&#123; final IncrementBloc counterBloc = BlocProvider.of&lt;IncrementBloc&gt;(context); final ApplicationBloc appBloc = BlocProvider.of&lt;ApplicationBloc&gt;(context); ... &#125;&#125; 为什么不使用InheritedWidget？在与BLoC相关的大多数文章中，你会看到通过InheritedWidget实现Provider。 当然，没有什么能阻止这种类型的实现。然而， 一个InheritedWidget没有提供任何dispose方法，记住，在不再需要资源时总是释放资源是一个很好的做法。 当然，没有什么能阻止你将InheritedWidget包装在另一个StatefulWidget中，但是，使用 InheritedWidget 增加了什么呢？ 最后，如果不受控制，使用InheritedWidget经常会导致副作用（请参阅下面的InheritedWidget上的提醒）。 以上三点解释了我为什么选择通过StatefulWidget实现BlocProvider，这样做可以让我在Widget dispose时释放相关资源。 Flutter无法实例化泛型类型不幸的是，Flutter无法实例化泛型类型，我们必须将BLoC的实例传递给BlocProvider。为了在每个BLoC中强制执行dispose()方法，所有BLoC都必须实现BlocBase接口。 提醒InheritedWidget在使用InheritedWidget并通过context.inheritFromWidgetOfExactType（…）来获得指定类型最近的widget, 每次InheritedWidget的父级或者子布局发生变化时，这个方法会自动将当前“context”（= BuildContext）注册到要重建的widget当中。。 请注意，为了完全正确，我刚才解释的与InheritedWidget相关的问题只发生在我们将InheritedWidget与StatefulWidget结合使用时。当你只使用没有State的InheritedWidget时，问题就不会发生。但是……我将在下一篇文章 中回到这句话。 链接到BuildContext的Widget类型（Stateful或Stateless）无关紧要。 关于BLoC的个人建议与BLoC相关的第三条规则是：“依赖于Streams的输入（Sink）和输出（stream）的使用优势”。 我的个人经历稍微关系到这个说法……让我解释一下。 首先，BLoC模式被设想为跨平台共享相同的代码（AngularDart，……），并且从这个角度来看，该陈述完全有意义。 但是，如果你只打算开发一个Flutter应用程序，这是基于我的谦逊经验，有点矫枉过正。 如果我们坚持声明，没有可能的getter或setter，只有sink和stream。缺点是“所有这些都是异步的”。 让我们用2个样本来说明缺点： 你需要从BLoC中检索一些数据，以便将这些数据用作应该立即显示这些参数的页面的输入（例如，想一个参数页面），如果我们不得不依赖Streams，这使得页面的构建异步（这很复杂）。通过Streams使其工作的示例代码可能如下所示……很丑陋不是吗。 代码 streams_7.dart 如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class FiltersPage extends StatefulWidget &#123; @override FiltersPageState createState() =&gt; FiltersPageState();&#125;class FiltersPageState extends State&lt;FiltersPage&gt; &#123; MovieCatalogBloc _movieBloc; double _minReleaseDate; double _maxReleaseDate; MovieGenre _movieGenre; bool _isInit = false; @override void didChangeDependencies() &#123; super.didChangeDependencies(); // 作为initState（）级别尚未提供的上下文，如果尚未初始化，我们将获得过滤器参数列表 if (_isInit == false)&#123; _movieBloc = BlocProvider.of&lt;MovieCatalogBloc&gt;(context); _getFilterParameters(); &#125; &#125; @override Widget build(BuildContext context) &#123; return _isInit == false ? Container() : Scaffold( ... ); &#125; /// /// 非常棘手. /// /// 由于我们希望100％符合BLoC标准，我们需要使用Streams从BLoCs中检索所有内容...... /// /// 这很难看，但被视为一个研究案例。 /// void _getFilterParameters() &#123; StreamSubscription subscriptionFilters; subscriptionFilters = _movieBloc.outFilters.listen((MovieFilters filters) &#123; _minReleaseDate = filters.minReleaseDate.toDouble(); _maxReleaseDate = filters.maxReleaseDate.toDouble(); // 只需确保订阅已发布 subscriptionFilters.cancel(); // 现在我们有了所有参数，我们可以构建实际的页面 if (mounted)&#123; setState(()&#123; _isInit = true; &#125;); &#125; &#125;); &#125;); &#125;&#125; 在BLoC级别，您还需要转换某些数据的“假”注入，以触发提供您希望通过流接收的数据。使这项工作的示例代码可以是： 代码streams_8.dart1234567891011121314151617181920212223242526272829303132class ApplicationBloc implements BlocBase &#123; /// /// 同步流来处理提供的电影类型 /// StreamController&lt;List&lt;MovieGenre&gt;&gt; _syncController = StreamController&lt;List&lt;MovieGenre&gt;&gt;.broadcast(); Stream&lt;List&lt;MovieGenre&gt;&gt; get outMovieGenres =&gt; _syncController.stream; /// /// 流处理假命令以通过Stream触发提供MovieGenres列表 /// StreamController&lt;List&lt;MovieGenre&gt;&gt; _cmdController = StreamController&lt;List&lt;MovieGenre&gt;&gt;.broadcast(); StreamSink get getMovieGenres =&gt; _cmdController.sink; ApplicationBloc() &#123; // // 如果我们通过此接收器接收任何数据，我们只需将MovieGenre列表提供给输出流 // _cmdController.stream.listen((_)&#123; _syncController.sink.add(UnmodifiableListView&lt;MovieGenre&gt;(_genresList.genres)); &#125;); &#125; void dispose()&#123; _syncController.close(); _cmdController.close(); &#125; MovieGenresList _genresList;&#125;// Example of external callBlocProvider.of&lt;ApplicationBloc&gt;(context).getMovieGenres.add(null); 我不知道你的意见，但就个人而言，如果我没有任何与代码移植/共享相关的限制，我发现这太重了，我宁愿在需要时使用常规的getter / setter并使用Streams / Sinks来保持分离责任并在需要的地方广播信息，这很棒。 现在是时候在实践中看到这一切……正如本文开头所提到的，我构建了一个伪应用程序来展示如何使用所有这些概念。 完整的源代码可以在 Github 上找到。 请谅解，因为这段代码远非完美，可能更好和/或更好的架构，但唯一的目标只是向您展示这一切是如何工作的。 由于源代码太多很多，我只会解释主要的几条。 电影目录的来源我使用免费的TMDB API来获取所有电影的列表，以及海报，评级和描述。 为了能够运行此示例应用程序，您需要注册并获取API密钥（完全免费），然后将您的API密钥放在文件“/api/tmdb_api.dart”第15行。 应用程序的架构如下： 该应用程序使用到了： 3个主要的BLoC： ApplicationBloc（在所有内容之上），负责提供所有电影类型的列表; 2.FavoriteBloc（就在下面），负责处理“收藏夹”的概念; 3.MovieCatalogBloc（在2个主要页面之上），负责根据过滤器提供电影列表; 6个页面： 1.HomePage：登陆页面，允许导航到3个子页面; 2.ListPage：将电影列为GridView的页面，允许过滤，收藏夹选择，访问收藏夹以及在后续页面中显示电影详细信息; 3.ListOnePage：类似于ListPage，但电影列表显示为水平列表，下面是详细信息; FavoritesPage：列出收藏夹的页面，允许取消选择任何收藏夹; 5.* Filters：允许定义过滤器的EndDrawer：流派和最小/最大发布日期。从ListPage或ListOnePage调用此页面; Details*详细信息：页面仅由ListPage调用以显示电影的详细信息，但也允许选择/取消选择电影作为收藏; 1个子BLoC: 1.FavoriteMovieBloc，链接到MovieCardWidget或MovieDetailsWidget，以处理作为收藏的电影的选择/取消选择 5个主要Widget： 1.FavoriteButton：负责显示收藏夹的数量，实时，并在按下时重定向到FavoritesPage; 2.FavoriteWidget：负责显示一个喜欢的电影的细节并允许其取消选择; 3.FiltersSummary：负责显示当前定义的过滤器; 4.MovieCardWidget：负责将一部电影显示为卡片，电影海报，评级和名称，以及一个图标，表示该特定电影的选择是最喜欢的; 5.MovieDetailsWidget：负责显示与特定电影相关的详细信息，并允许其选择/取消选择作为收藏。 不同BLoCs / Streams的编排下图显示了如何使用主要3个BLoC： 在BLoC的左侧，哪些组件调用Sink 在右侧，哪些组件监听流 例如，当MovieDetailsWidget调用inAddFavorite Sink时，会触发2个stream： outTotalFavorites流强制重建FavoriteButton outFavorites流强制重建MovieDetailsWidget（“最喜欢的”图标）强制重建_buildMoieCard（“最喜欢的”图标）用于构建每个MovieDetailsWidget 观察大多数Widget和Page都是StatelessWidgets，这意味着： 强制重建的setState()几乎从未使用过。 例外情况是：在ListOnePage中,当用户点击MovieCard时，刷新MovieDetailsWidget。 这也可能是由一个stream驱动的……在FiltersPage中允许用户在接受筛选条件之前通过Sink更改过筛选条件。 应用程序不使用任何InheritedWidget 该应用程序几乎是100％BLoCs / Streams驱动，这意味着大多数小部件彼此独立，并且它们在应用程序中的位置 一个实际的例子是FavoriteButton，它显示徽章中所选收藏夹的数量。 该应用程序共有3个FavoriteButton实例，每个实例显示在3个不同的页面中。 显示电影列表（显示无限列表的技巧说明）要显示符合过滤条件的电影列表，我们使用GridView.builder（ListPage）或ListView.builder（ListOnePage）作为无限滚动列表。 电影是通过TMDB API获取的，每次拉取20个。 提醒一下，GridView.builder和ListView.builder都将itemCount作为输入，如果提供了item数量，则表示要根据itemCount的数量来显示列表。itemBuilder的index从0到itemCount - 1不等。 正如您将在代码中看到的那样，我随意为GridView.builder添加了30多个。 理由是，在这个例子中，我们正在操纵假定的无限数量的项目（这不是完全正确但是又有谁关心这个例子）。 这将强制GridView.builder请求显示“最多30个”项目。 此外，GridView.builder和ListView.builder只在认为必须在视口中呈现某个项目（索引）时才调用itemBuilder。 MovieCatalogBloc.outMoviesList返回一个List ，它被迭代以构建每个Movie Card。 第一次，这个List 是空的，但是由于itemCount：… + 30，我们欺骗系统，它将要求通过_buildMovieCard（…）呈现30个不存在的项目。 正如您将在代码中看到的，此例程对Sink进行了一次奇怪的调用：12//通知MovieCatalogBloc我们正在渲染MovieCard[index]movieBloc.inMovieIndex.add(index); 这个调用告诉MovieCatalogBloc我们要渲染MovieCard [index]。 然后_buildMovieCard(…)继续验证与MovieCard [index]相关的数据是否存在。 如果是，则渲染后者，否则显示CircularProgressIndicator。 对StreamCatalogBloc.inMovieIndex.add(index)的调用由StreamSubscription监听，StreamSubscription将索引转换为某个pageIndex数字（一页最多可计20部电影）。 如果尚未从TMDB API获取相应页面，则会调用API。 获取页面后，所有已获取电影的新列表将发送到_moviesController。 当GridView.builder监听该Stream（= movieBloc.outMoviesList）时，后者请求重建相应的MovieCard。 由于我们现在拥有数据，我们可以渲染它了。 名单和其他链接介绍PublishSubject，BehaviorSubject和ReplaySubject的图片由ReactiveX发布。其他一些有趣的文章值得一读： Fundamentals of Dart Streams [Thomas Burkhart] rx_command package [Thomas Burkhart] Build reactive mobile apps in Flutter - companion article [Filip Hracek] Flutter with Streams and RxDart [Brian Egan] 总结很长的文章，但还有更多的话要说，因为对我而言，这是展开Flutter应用程序的方法。 它提供了很大的灵活性。 很快就会继续关注新文章。 快乐写代码。 这篇文章也可以在 Medium -Flutter Community 找到。 本文源码 如需转载本译文，请注明出处.]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter之AppBar的部分定制]]></title>
    <url>%2F2019%2F03%2F14%2FFlutter%E4%B9%8BAppBar%E7%9A%84%E9%83%A8%E5%88%86%E5%AE%9A%E5%88%B6%2F</url>
    <content type="text"><![CDATA[代码 最终预览效果如下： 一、定制Title 目标：App导航栏title换成需要切换条（iOS中叫Segment）1、flutter提供的AppBar的title属性就是wigdet，所有我们可以直接把title设置为tabbar;2、需要相应的页面来进行联动，所以需要关联SingleTickerProviderStateMixin, 且把tabbar的controller 和 TabBarView的controller设置为同一个controller 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253final GlobalKey&lt;ScaffoldState&gt; _scaffoldKey = GlobalKey&lt;ScaffoldState&gt;();class MyHomePage extends StatefulWidget &#123; final String title; MyHomePage(&#123;Key key, this.title&#125;) : super(key: key); @override _MyHomePageState createState() =&gt; _MyHomePageState();&#125;class _MyHomePageState extends State&lt;MyHomePage&gt; with SingleTickerProviderStateMixin &#123; TabController _controller; @override void initState() &#123; super.initState(); _controller = TabController(length: 3, vsync: this); //初始化方法 &#125; @override Widget build(BuildContext context) &#123; return Scaffold( title: TabBar( controller: _controller, tabs: &lt;Widget&gt;[ Tab( icon: Icon(Icons.directions_car), ), Tab( icon: Icon(Icons.directions_transit), ), Tab( icon: Icon(Icons.directions_bike), ), ], ), ), body: TabBarView( controller: _controller, children: &lt;Widget&gt;[ HomePage( title: "设置11111", ), HomePage( title: "设置22222", ), HomePage( title: "设置33333", ), ], ), ); &#125; HomePage代码123456789101112131415class HomePage extends StatelessWidget &#123; final String title; final Widget child; HomePage(&#123;Key key, this.child, this.title&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Container( child: Center( child: Text(title), ), ); &#125;&#125; 二、侧滑抽屉效果1、方法一:系统自带（局限性，图片不能更改）仅仅设置Scaffold的drawer就好1drawer: _buildDrawer(context), 2、方法二:Builder123456leading: Builder( builder: (context) =&gt; IconButton( icon: new Icon(Icons.settings), onPressed: () =&gt; Scaffold.of(context).openDrawer(), ), ), 3、方法三:GlobalKey 1234567891011121314151617// 1.步奏一final GlobalKey&lt;ScaffoldState&gt; _scaffoldKey = GlobalKey&lt;ScaffoldState&gt;();Widget build(BuildContext context) &#123; return Scaffold( key: _scaffoldKey,// 2、步奏二 drawer: _buildDrawer(context), leading: IconButton( icon: Icon(Icons.account_box), onPressed: () &#123; // 3、步奏三 _scaffoldKey.currentState.openDrawer(); &#125;, ), ); &#125; 4、方法四:改变源码（不推荐） 123456789101112131415161718192021/// 到AppBar源码，修改的部分codeWidget leading = widget.leading;if (/*leading == null &amp;&amp; */widget.automaticallyImplyLeading) &#123; if (hasDrawer) &#123; leading = IconButton( icon: /*const Icon(Icons.menu)*/ leading ?? Icon(Icons.home), // 如果leading指定了widget那么 onPressed: _handleDrawerButton, tooltip: MaterialLocalizations.of(context).openAppDrawerTooltip, ); &#125; else &#123; if (canPop) leading = useCloseButton ? const CloseButton() : const BackButton(); &#125;&#125;if (leading != null) &#123; leading = ConstrainedBox( constraints: const BoxConstraints.tightFor(width: _kLeadingWidth), child: leading, );&#125; 附录:代码汇总1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677Widget _buildDrawer(BuildContext context) &#123; return Drawer( child: ListView( dragStartBehavior: DragStartBehavior.down, children: &lt;Widget&gt;[ // 1. 简单的头部 // const DrawerHeader( // child: Center( // child: Text('我是侧边栏'), // ), // ), // 2.复杂的用户头部 // UserAccountsDrawerHeader 不能用const来修饰 UserAccountsDrawerHeader( accountEmail: Text( '13456@qq.com', style: TextStyle(color: Colors.black), ), accountName: Text( 'HandsomeMen', style: TextStyle(color: Colors.black), ), currentAccountPicture: GestureDetector( onTap: () &#123; print('current user'); &#125;, child: CircleAvatar( backgroundImage: NetworkImage( 'http://m.360buyimg.com/pop/jfs/t25441/342/232745157/35324/69b79175/5b696c57N739592b8.jpg'), ), ), otherAccountsPictures: &lt;Widget&gt;[ GestureDetector( onTap: () =&gt; print('点击了otherAccountsPictures 111111'), child: CircleAvatar( backgroundImage: NetworkImage( 'https://pic.qqtn.com/up/2018-9/15367146917869444.jpg'), ), ), GestureDetector( onTap: () =&gt; print('点击了otherAccountsPictures 222222'), child: CircleAvatar( backgroundImage: NetworkImage( 'http://www.gx8899.com/uploads/allimg/160902/3-160Z2104544.jpg'), ), ), ], decoration: BoxDecoration( //装饰器提供背景图片 image: DecorationImage( fit: BoxFit.fill, //使用网络图片怎么有问题 image: NetworkImage( 'http://www.86ps.com/UpLoadFiles/jpg/2011-10/2011100912585215837.jpg') // image: new ExactAssetImage('images/bg.jpg'), ), ), ), const ListTile( leading: Icon(Icons.account_box), title: Text('选卡1'), ), Divider(), const ListTile( leading: Icon(Icons.account_box), title: Text('选卡1'), ), Divider(), const ListTile( leading: Icon(Icons.account_box), title: Text('选卡1'), ), ], ), ); &#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter 网络请求的三种简单实现]]></title>
    <url>%2F2019%2F02%2F23%2FFlutter-%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%89%E7%A7%8D%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[概述：本文主要讲解了flutter网络请求三种方式 flutter自带的HttpClient、 第三方库http 和 第三方库Dio 的简单实现 GET 和 POST请求，本文是笔者学习Flutter网络模块知识总结，若有问题还望不腻赐教。 本文Demo地址 一.系统自带HttpClient1.使用中温馨提示1.1.导入库12import 'dart:io'; // 网络请求import 'dart:convert'; // 数据解析 1.2.Uri的多种初始化方式123456// 方法1Uri uri = Uri(scheme: 'https', host: 'appbg.lcfarm.com', path: homeNoviceListUrl);// 方法2Uri uri = Uri.https('appbg.lcfarm.com', homeNoviceListUrl);// uri方法3Uri uri = Uri.parse(njqbaseUrl + homeNoviceListUrl); 2.简单使用2.1.GET请求123456789101112131415161718192021222324252627282930313233343536373839404142434445// 1.1 HttpClient - get （疑问？queryParameters仅仅用在get请求吗）void loadData_sys_get() async &#123;print('------loadData_sys_get--------');var httpClient = new HttpClient();var params = Map&lt;String, String&gt;();// uri方法1Uri uri = Uri(scheme: 'https', host: 'appbg.lcfarm.com', path: homeNoviceListUrl);// uri方法2// Uri uri = Uri.https(// 'appbg.lcfarm.com', homeNoviceListUrl);// uri方法3// Uri uri = Uri.parse(njqbaseUrl + homeNoviceListUrl);var request = await httpClient.getUrl(uri);var headers = Map&lt;String, String&gt;();headers['loginSource'] = 'IOS';headers['useVersion'] = '3.1.0';headers['isEncoded'] = '1';headers['bundleId'] = 'com.nongfadai.iospro';request.headers.add("loginSource", "IOS");request.headers.add("useVersion", "3.1.0");request.headers.add("isEncoded", "1");request.headers.add("bundleId", "com.nongfadai.iospro");var response = await request.close();var responseBody = await response.transform(Utf8Decoder()).join();if (response.statusCode == HttpStatus.ok) &#123; print('请求头：$&#123;response.headers&#125;'); print('111请求成功代发数据为:\n $responseBody'); print('--------------'); Map data = jsonDecode(responseBody); print('222请求成功代发数据为:\n $data');&#125; else &#123; print('\n\n\n11111==请求失败$&#123;response.statusCode&#125;');&#125;&#125; 2.2.POST请求注意点：请求参数需要编码后放在request中12345678910111213141516171819202122232425262728293031323334void loadData_sys_post() async &#123;print('------loadData_sys_post--------');HttpClient httpClient = new HttpClient();// queryParameters get请求的查询参数(适用于get请求？？？是吗？？？)// Uri uri = Uri(// scheme: "https", host: "appbg.lcfarm.com", path: homeRegularListUrl);// HttpClientRequest request = await httpClient.postUrl(uri);var url = njqbaseUrl + homeRegularListUrl;HttpClientRequest request = await httpClient.postUrl(Uri.parse(url));// 设置请求头request.headers.set("loginSource", "IOS");request.headers.set("useVersion", "3.1.0");request.headers.set("isEncoded", "1");request.headers.set("bundleId", "com.nongfadai.iospro");// Content-Type大小写都okrequest.headers.set('content-type', 'application/json');/// 添加请求体/// https://stackoverflow.com/questions/50278258/http-post-with-json-on-body-flutter-dart/50295533Map jsonMap = &#123;'currentPage': '1'&#125;;request.add(utf8.encode(json.encode(jsonMap)));HttpClientResponse response = await request.close();String responseBody = await response.transform(utf8.decoder).join();if (response.statusCode == HttpStatus.ok) &#123; print('请求成功'); print(response.headers); print(responseBody);&#125;&#125; 二.请求第三方库 http1.使用中温馨提示1.1.添加依赖12dependencies: http: ^0.12.0 #latest version 1.2.导入库1import 'package:http/http.dart' as http; //导入前需要配置 2.简单使用2.1. GET请求2.2.1. http - get1123456789101112131415void loadData_http_get() async &#123; print('------loadData_http_get--------'); var client = http.Client(); var uri = Uri.parse(njqbaseUrl + homeNoviceListUrl); http.Response response = await client.get(uri); if (response.statusCode == HttpStatus.ok) &#123; print(response.body); &#125; else &#123; print('请求失败 code 码为$&#123;response.statusCode&#125;'); &#125;&#125; 2.2. http - get简便方法（链式编程）12345678910111213void loadData_http_get_convenience() async &#123; print('------简便方法loadData_http_get_convenience--------'); var uri = Uri.parse(njqbaseUrl + homeNoviceListUrl); http.Client().get(uri).then((http.Response response) &#123; if (response.statusCode == HttpStatus.ok) &#123; print(response.body); &#125; else &#123; print('请求失败 code 码为$&#123;response.statusCode&#125;'); &#125; &#125;); &#125; 2.2. POST请求2.2.1. http - post1234567891011121314151617181920212223242526272829void loadData_http_post() async &#123; print('------ loadData_http_post --------'); var headers = Map&lt;String, String&gt;(); headers["loginSource"] = "IOS"; headers["useVersion"] = "3.1.0"; headers["isEncoded"] = "1"; headers["bundleId"] = "com.nongfadai.iospro"; headers["loginSource"] = "IOS"; headers["Content\-Type"] = "application/json"; Map params = &#123;'currentPage': '1'&#125;; // 嵌套两层都可以，但是具体哪个好还有待确认？？？？ var jsonParams = utf8.encode(json.encode(params)); // var jsonParams = json.encode(params); var httpClient = http.Client(); var uri = Uri.parse(njqbaseUrl + homeNoviceListUrl); http.Response response = await httpClient.post(uri, body: jsonParams, headers: headers); if (response.statusCode == HttpStatus.ok) &#123; print(response.body); &#125; else &#123; print('请求失败 code 码���$&#123;response.statusCode&#125;'); &#125;&#125; 2.2.2. http - Post简便方法（链式编程）1234567891011121314151617181920212223242526void loadData_http_post_convenience() async &#123; print('------ loadData_http_post --------'); var headers = Map&lt;String, String&gt;(); headers["loginSource"] = "IOS"; headers["useVersion"] = "3.1.0"; headers["isEncoded"] = "1"; headers["bundleId"] = "com.nongfadai.iospro"; headers["loginSource"] = "IOS"; headers["Content\-Type"] = "application/json"; Map params = &#123;'currentPage': '1'&#125;; // 嵌套两层都可以，但是具体哪个好还有待确认？？？？ var jsonParams = utf8.encode(json.encode(params)); // var jsonParams = json.encode(params); var httpClient = http.Client(); var url = njqbaseUrl + homeRegularListUrl; httpClient.post(url, body: jsonParams, headers: headers).then((response) &#123; print("Response status: $&#123;response.statusCode&#125;"); print("Response body: $&#123;response.body&#125;"); &#125;).whenComplete(httpClient.close);&#125; 三.请求第三方库 Dio1.使用中温馨提示1.1.添加依赖12dependencies: dio: ^2.0.11 #latest version 1.2.导入库1import 'package:dio/dio.dart'; 2.简单使用2.1. GET请求注意：Dio的get请求（baseUrl都是在dio.option.baseUrl设置的） 请求头可以在dio.option上设置，也可以在新建的option上设置,新建option是可选的12345678910111213141516171819void loadData_dio_get() async &#123; var headers = Map&lt;String, String&gt;(); headers['loginSource'] = 'IOS'; headers['useVersion'] = '3.1.0'; headers['isEncoded'] = '1'; headers['bundleId'] = 'com.nongfadai.iospro'; headers['Content-Type'] = 'application/json'; Dio dio = Dio(); dio.options.headers.addAll(headers); dio.options.baseUrl = njqbaseUrl; Response response = await dio.get(homeNoviceListUrl); if (response.statusCode == HttpStatus.ok) &#123; print(response.headers); print(response.data); &#125; &#125; 2.2. POST请求注意：12345678dio.options.method设置是无效Dio dio = Dio();dio.options.method = 'post';办法：新建一个Options对象，然后在发起请求的时候进行设置：Options option = Options(method:'post');Response response = await dio.request(homeRegularListUrl,data:&#123;"currentPage": "1"&#125;, options: option); 2.2.1. dio - 方式一（baseUrl都是在dio.option.baseUrl设置的）注意：直接在 dio.options设置除methods以外的 请求头参数123456789101112131415161718192021222324252627282930313233void loadData_dio_dioOfOptionsSetting() async &#123; debugPrint( ' \n post请求 ======================= 开始请求 =======================\n'); var headers = Map&lt;String, String&gt;(); headers['loginSource'] = 'IOS'; headers['useVersion'] = '3.1.0'; headers['isEncoded'] = '1'; headers['bundleId'] = 'com.nongfadai.iospro'; headers['Content-Type'] = 'application/json'; Dio dio = Dio(); dio.options.baseUrl = njqbaseUrl; dio.options.connectTimeout = 60000; dio.options.receiveTimeout = 60000; dio.options.headers.addAll(headers); dio.options.method = 'post'; Options option = Options(method: 'post'); // Response response = await dio.request(homeRegularListUrl, // data: &#123;"currentPage": "1"&#125;, options: option); Response response = await dio.post(homeRegularListUrl, data: &#123;"currentPage": "1"&#125;, options: option); if (response.statusCode == HttpStatus.ok) &#123; debugPrint('请求参数： $&#123;response.request.queryParameters&#125;'); debugPrint( '-------------------请求成功,请求结果如下:-----------------\n \n===请求求url: $&#123;response.request.uri.toString()&#125; \n \n===请求 ���: \n$&#123;response.headers&#125; \n \n===请求结果: \n$&#123;response.data&#125;\n'); debugPrint('-------------------请求成功,请求结果打印完毕----------------'); &#125; else &#123; print('请求失败'); &#125; &#125; 2.2.2. dio - 方式二（baseUrl都是在dio.option.baseUrl设置的）注意：在新建的option上设置请求头参数12345678910111213141516171819202122232425262728293031void loadData_dio_newOptionSetting() async &#123; debugPrint(' \n======================= 开始请求 =======================\n'); var headers = Map&lt;String, String&gt;(); headers['loginSource'] = 'IOS'; headers['useVersion'] = '3.1.0'; headers['isEncoded'] = '1'; headers['bundleId'] = 'com.nongfadai.iospro'; headers['Content-Type'] = 'application/json'; Options option = Options(method: 'post'); option.connectTimeout = 60000; option.receiveTimeout = 60000; option.headers.addAll(headers); Dio dio = Dio(); dio.options.baseUrl = njqbaseUrl; Response response = await dio.post(homeRegularListUrl, data: &#123;"currentPage": 1&#125;, options: option); // Response response = await dio.request(homeRegularListUrl, // data: &#123;"currentPage": 1&#125;, options: option); if (response.statusCode == HttpStatus.ok) &#123; debugPrint('请求参数： $&#123;response.request.queryParameters&#125;'); debugPrint( '-------------------请求成功,请求结果如下:-----------------\n \n===请求url: $&#123;response.request.uri.toString()&#125; \n \n===请求 头: \n$&#123;response.headers&#125; \n \n===请求结果: \n$&#123;response.data&#125;\n'); debugPrint('-------------------请求成功,请求结果打印完毕----------------'); &#125; else &#123; print('请求失败'); &#125; &#125; 本文Demo地址]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则替换url字符串中的值]]></title>
    <url>%2F2019%2F02%2F18%2F%E6%AD%A3%E5%88%99%E6%9B%BF%E6%8D%A2url%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%80%BC%2F</url>
    <content type="text"><![CDATA[1、方法一：键和值一起替换 1234567891011121314151617- (NSString *) paramValueOfUrl:(NSString *) url withParam:(NSString *) param value:(NSString *)value&#123; NSError *error; NSString *targetString = [NSString stringWithFormat:@&quot;%@=%@&quot;,param,value]; NSString *regTags = [[NSString alloc] initWithFormat:@&quot;%@=+([\\w]*)&quot;,param]; NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:regTags options:0 error:&amp;error]; NSString *string = [regex stringByReplacingMatchesInString:url options:0 range:NSMakeRange(0, [url length]) withTemplate:targetString]; return string;&#125; 2、方法二： 值替换 1234567891011121314151617181920212223242526/// 方法二：- (NSString *) paramValueOfUrl2:(NSString *) url withParam:(NSString *) param value:(NSString *)value&#123; NSError *error; // (^|&amp;|\\?|#)+%@=+([^&amp;|#]*)(#|&amp;|$) ： range 取 [match rangeAtIndex:2] // %@=+([^&amp;|#]*)(#|&amp;|$) ： range 取 [match rangeAtIndex:1] // 通过numberOfRanges获取结果数量，然后分别打印获取值 [url substringWithRange:[match rangeAtIndex:i]] NSString *regTags = [[NSString alloc] initWithFormat:@&quot;(^|&amp;|\\?|#)+%@=+([^&amp;|#]*)(#|&amp;|$)&quot;,param]; NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:regTags options:NSRegularExpressionCaseInsensitive error:&amp;error]; // 执行匹配的过程 NSArray *matches = [regex matchesInString:url options:0 range:NSMakeRange(0, [url length])]; for (NSTextCheckingResult *match in matches) &#123; NSRange range = [match rangeAtIndex:2]; NSString *tagValue = [url substringWithRange:range]; // 分组2所对应的串 if (![value isEqualToString:tagValue]) &#123; url = [url stringByReplacingCharactersInRange:range withString:value]; &#125; &#125; return url;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发工具攻略(一)]]></title>
    <url>%2F2018%2F08%2F07%2FSublime%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. Sublime安装插件报错解决办法 错误：There are no packages available for installation 解决办法：12345678910111213141516171819Step1:Preferences-&gt;PackageSettings-&gt;PackageControl-&gt;Settings-UserStep2:在文件里面添加如下代码：&quot;debug&quot;: true,&quot;downloader_precedence&quot;: &#123; &quot;windows&quot;: [&quot;wininet&quot;], &quot;osx&quot;: [&quot;curl&quot;, &quot;wget&quot;], &quot;linux&quot;: [&quot;urllib&quot;, &quot;curl&quot;, &quot;wget&quot;] &#125;,Step3: ⁃ command + shift + p 进行插件安装 首先的安装插件管理器： Install Package 然后输入要安装的插件名称 2. Github转移项目到Coding.net笔者的需求：个人博客部署系统代码不需要进行在github上进行公开，github私有项目又需要付费，感觉不值，所以有此次需求 参考 1. Coding.net上建立一个新的私有仓库（有就不用建立）2.Coding.net配置公钥,git操作需要权限1234567891011121314Step1command+shift+. 展示隐藏文件，然后cd到.ssh文件下面找到.pub结尾的文件(即公钥文件)，拷贝私钥Step2coding个人中心 - SSH公钥 - 新增公钥 添加就好ps:补充如何生成SSH公钥1. 根目录下 执行ssh-keygen确认保存公钥的位置（.ssh/id_rsa）重复一个密码两次，如果不想在使用公钥的时候输入密码，可以留空2. 获取公钥 cat ~/.ssh/id_rsa.pub 3. 把github上的代码clone到指定路径123git clone --bare https://github.com/***/******.gitps: --bare 创建的克隆版本库都不包含工作区，直接就是版本库的内容，这样的版本库称为裸版本库。 4.使用镜像推送的方式上传代码到新的服务器123456cd xxxx.gitgit push --mirror https://git.coding.net/cc412/xxxx.gitps: https://git.coding.net/cc412/xxxx.git 是coding.net仓库地址 如果https不行推荐用SSH 5.删除本地代码12cd ..//返回上一路径rm -rf xxxx.git //干掉 6.从新服务器clone下来，就是你想要的库了123git clone https://git.coding.net/cc412/xxxx.gitps： 如果https不行推荐用SSH 7. 码云 也是一样的操作,笔者验证码云https和SSH都OK，最终用哪个看自己需要，笔者最终选择了码云！]]></content>
      <categories>
        <category>开发工具攻略</category>
      </categories>
      <tags>
        <tag>攻略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next主题博客功能完善]]></title>
    <url>%2F2018%2F08%2F07%2FNext%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%96%84%2F</url>
    <content type="text"><![CDATA[前提为你已经搭建好hexo next博客如果没有，则参考搭建吧😝注意：下载next地址变了next新地址博客部署命令可以用&amp;&amp;操作： hexo clean &amp;&amp; hexo g &amp;&amp; hexo s hexo clean &amp;&amp; hexo g &amp;&amp; hexo d！！！很多插件安装，网上的如果不行，请直接参考插件官网，最官方 一、配置问题注意点1. 文章显示中文12根目录/_config.yml（不是next下面的哈）language: zh-CN # 是zh-CN 不是zh-Hans 2. 首页显示阅读全文12345themes/next/_config.ymlauto_excerpt: enable: true # 设置是否显示阅读全文，文章较多的话，有必要设置为 true length: 200 #预览展示多少文字 3. 分享功能ps:微信图片加载不出来，所以去掉了12345678910111213141516171819202122232425Step1source/libgit clone https://github.com/theme-next/theme-next-needmoreshare2 source/lib/needsharebuttonps：名字不是随便的needsharebuttonStep2needmoreshare2: enable: true postbottom: enable: true options: iconStyle: box boxForm: horizontal position: bottomCenter networks: Weibo,Douban,QQZone,Twitter,Facebook float: enable: true options: iconStyle: box boxForm: horizontal position: middleRight networks: Weibo,Douban,QQZone,Twitter,Facebook 4. 添加分类和标签官方链接参考链接 4.1. 添加分类12345678910111213141516171819202122232425262728293031323334353637Step1进入博客所在文件夹执行 ： hexo new page categories成功提示 ： INFO Created: ~/Documents/blog/source/categories/index.md根据上面的路径，找到index.md这个文件，打开后默认内容是这样的：---title: 文章分类date: 2017-05-27 13:47:40---添加type: &quot;categories&quot;到内容中，添加后是这样的：---title: 文章分类date: 2017-05-27 13:47:40type: &quot;categories&quot;---新建文章后 hexo new [post] 文章标题添加categories属性，再部署之后就可以在分类页看到分类了---title: hexo next 为文章添加分类date: 2016-03-16 08:12:43tags:categories: 前端---或则这样但是分类只能添加一个---title: hexo next 为文章添加分类date: 2016-03-16 08:12:43tags:categories: - 前端--- 4.2. 添加标签123456789101112131415161718192021222324252627282930313233Step1进入博客所在文件夹hexo new page tags成功后提示INFO Created: ~/Documents/blog/source/tags/index.md根据上面的路径，找到index.md这个文件，打开后默认内容是这样的：---title: 标签date: 2017-05-27 14:22:08---添加type: &quot;tags&quot;到内容中，添加后是这样的：---title: 文章分类date: 2017-05-27 13:47:40type: &quot;tags&quot;---Step2新建文章或者想给某个文件添加tags，则如下操作---title: jQuery对表单的操作及更多应用date: 2017-05-26 12:12:57categories: - web前端tags:- jQuery- 表格- 表单验证--- 注意： 1.只有添加了tags: xxx的文章才会被收录到首页的“标签”中。 2.在categories和tags的index.m文件里面添加 comments: false ，把评论关了 细心的朋友可能已经发现，这两个的设置几乎一模一样！是的，没错，思路都是一样的。所以我们可以打开scaffolds/post.md文件，在tages:上面加入categories:,保存后，之后执行hexo new 文章名命令生成的文件，页面里就有categories:项了。 scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。 5. 文章侧边栏控制123# 这个地方控制自动打开文章目录条# #sidebar: 注释掉则表示一打开详情页不会自动弹出sidebar sidebar: 6. 不要Next自动添加序号1234567891011themes/next/_config.yml 修改 number: falsetoc: enable: true # Automatically add list number to toc. # 不要next系统添加序号 number: false #true # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false 7.代码高亮主题色12需要写明语言才会真正有效果hexo next highlight_theme 设置 8. 安装与卸载插件8.1. 安装12npm install xxx –save做相应配置（官网） 8.2. 卸载123456npm uninstall 插件名称 --save去掉相应配置(安装时候配置的)例： 卸载hexo s上传图片到的七牛插件（个人安装又卸载了）npm uninstall hexo-qiniu-sync --save去掉根目录/_config.yml下配置 9.网页加载动画效果PS： next 已经集成好动画了，如果对速度有要求的话直接关闭，个人选择关闭,加载太慢了。123# 加载有点慢 关掉motion: enable: false #true 10. 如何在首页添加图片参考链接12345678910111213每篇文章里面添加photos: —&quot;图片链接&quot;---layout: &apos;[post]&apos;title: Next主题博客功能完善date: 2018-08-07 00:25:53tags:- 博客- 技巧categories: 博客搭建photos: - &quot;http://oz2tkq0zj.bkt.clouddn.com/17-11-9/52323298.jpg&quot;--- 二、 添加功能插件1. 图片浏览放大功能fancybox1234567891011Step1:cd next/source/libgit clone https://github.com/theme-next/theme-next-fancybox3 fancyboxps:注意fancybox和next/_config.uml里面的名字保持一致step2：更改next/_config.uml文件fancybox： true 2. 阅读次数ps: 仅限于博文详情页面显示阅读数，在首页不显示1234567891011step1更改next/_config.uml文件enable: true,如下：busuanzi_count: enable: true #false total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye post_views: true post_views_icon: eye 3. hexo s 顺便上传图片到七牛云服务器参考ps:这个插件感觉可添加也可不用添加，用到图片的时候自己上传到七牛服务器就好1234567891011121314151617181920212223242526272829303132333435363738394041424344454647step1:自己注册七牛服务器（目前笔者觉得够用了）step2:hexo主目录，下载插件npm install hexo-qiniu-sync --savestep3:配置next/_config.yml#七牛云存储设置##offline 是否离线. 离线状态将使用本地地址渲染##sync 是否同步##bucket 空间名称.##access_key 上传密钥AccessKey##secret_key 上传密钥SecretKey##secret_file 秘钥文件路径，可以将上述两个属性配置到文件内，防止泄露，json格式。绝对路径相对路径均可##dirPrefix 上传的资源子目录前缀.如设置，需与urlPrefix同步 ##urlPrefix 外链前缀.##up_host 上传服务器路径,如选择华北区域的话配置为http://up-z1.qiniu.com##local_dir 本地目录.##update_exist 是否更新已经上传过的文件(仅文件大小不同或在上次上传后进行更新的才会重新上传)##image/js/css 子参数folder为不同静态资源种类的目录名称，一般不需要改动##image.extend 这是个特殊参数，用于生成缩略图或加水印等操作。具体请参考http://developer.qiniu.com/docs/v6/api/reference/fop/image/ ## 可使用基本图片处理、高级图片处理、图片水印处理这3个接口。例如 ?imageView2/2/w/500 即生成宽度最多500px的缩略图qiniu: offline: false sync: true bucket: bucket_name secret_file: sec/qn.json or C: access_key: AccessKey secret_key: SecretKey dirPrefix: static urlPrefix: http://bucket_name.qiniudn.com/static up_host: http://upload.qiniu.com local_dir: static update_exist: true image: folder: images extend: js: folder: js css: folder: css step4:在hexo目录下,运行一下hexo s，图片直接上传到七牛云存储上去了 注意:备份发布系统代码不会上传hexo-qiniu-sync，不过在重新下载了部署系统，则直接运行npm install hexo —save就好,不需要再次执行 npm install hexo-qiniu-sync --save 因为在第一次下载的时候已经在配置文件记录了 4. 畅言评论插件集成参考功能：博客下面进行各种登陆评论，首页及详情页顶部评论量显示 4.1.畅言集成步骤1234567step1：注册畅言:http://changyan.kuaizhan.com/获取畅言评论的APP ID 和APP KEYICP备案：自己有最好,网上随便找一个step2：集成就不详叙，直接参考：https://www.jianshu.com/p/5888bd91d070 遇到的坑 ：a. 显示不全 解决办法：更改next/layout/_partials/comments.swig代码原来的代码： 34行处1234&lt;div class=&quot;comments&quot; id=&quot;comments&quot;&gt; &lt;/style&gt; &lt;div id=&quot;SOHUCS&quot;&gt;&lt;/div&gt; &lt;/div&gt; 改完后的代码：12345678&lt;div class=&quot;comments&quot; id=&quot;comments&quot;&gt; &lt;style&gt; #comments &#123; transform: none !important; &#125; &lt;/style&gt; &lt;div id=&quot;SOHUCS&quot;&gt;&lt;/div&gt; &lt;/div&gt; b. 首页显示评论出现问题参考解法 解决办法：next/layout/_mavro/post.swig:175～178行123&lt;a href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;#SOHUCS&quot; itemprop=&quot;discussionUrl&quot;&gt; &lt;span id=&quot;url::&#123;&#123; post.permalink &#125;&#125;&quot; class=&quot;cy_cmt_count&quot; data-xid=&quot;&#123;&#123; post.path &#125;&#125;&quot; itemprop=&quot;commentsCount&quot; &gt;&lt;/span&gt; &lt;/a&gt; 将post.permalink这个值包一层encodeURI方法1&lt;span id=&quot;url::&#123;&#123; encodeURI(post.permalink) &#125;&#125;&quot; class=&quot;cy_cmt_count&quot; data-xid=&quot;&#123;&#123; post.path &#125;&#125;&quot; itemprop=&quot;commentsCount&quot; &gt;&lt;/span&gt; 4.2. 我为什么最终选畅言而不其他评论插件，其他评论插件我都集成过？（ps:下面的言论不代表其余的评论插件做的不行，很可能是我的集成姿势不对） 先说说我集成评论系统的要求：登陆评论方便、首页/详情页评论数显示正确 4.2.1. gitment集成参考: id获取问题导致如果同时发布两篇文章，两篇文章下显示的评论都是两篇文章的总合Error：validation failed 解决办法如下 12345678910111213文件:themes\next\layout_third-party\comments\gitments.swig替换 id: window.location.pathname,方法一：id: &apos;&#123;&#123; page.date &#125;&#125;’,方法二：id: (window.location.pathname.length &lt; 50) ? window.location.pathname : &apos;&lt;%= page.date %&gt;&apos;,function renderGitment()&#123; var gitment = new &#123;&#123;CommentsClass&#125;&#125;(&#123; id: window.location.pathname, owner: &apos;&#123;&#123; theme.gitment.github_user &#125;&#125;&apos;, repo: &apos;&#123;&#123; theme.gitment.github_repo &#125;&#125;&apos;, &#123;% if theme.gitment.mint %&#125; lang: &quot;&#123;&#123; theme.gitment.language &#125;&#125;&quot; || navigator.language || navigator.systemLanguage || navigator.userLanguage, &#123;% endif %&#125; 4.2.2. 来必得集成参考插件集成最简单，但是因为是韩国的所以加载比较慢，首页没有评论数量显示所以没用。 4.2.3. valine集成参考集成也挺简单，但是评论的时候让用户直接选择留下联系方式，然后没有首页显示评论数量所以没用，且评论管理不知道在哪里管理； 5. 本地搜索功能local_search 方法一：推荐官方教程12345678910111213141516Step1: cd 到博客根目录npm install hexo-generator-searchdb --saveStep2:根目录/_config.yml 文件下添加下面代码search: path: search.xml field: post format: html limit: 10000 Step3:next/_config.yml 文件下更改以下代码:改false为truelocal_search: enable: true #false 方法二：民间教程123456789101112131415161718192021222324step1： 安装插件插件管理方法一：自己管理cd next/source/libgit clone https://github.com/theme-next/hexo-generator-searchdb.git local_search ps:local_search名字和里面对应方法二：直接让npm给你管理插件-- 推荐npm install hexo-generator-searchdb --saveStep2your root _config.yml 添加：search: path: search.xml field: post format: html limit: 10000 step3/next/_config.yml 改local_search为truelocal_search: enable: true 6. 文字数量和阅读时长1234567891011121314151617Step1npm install hexo-symbols-count-time --save Step2your root _config.ymlsymbols_count_time: symbols: true time: true total_symbols: true total_time: true /next/_config.yml 不用动 7. 开启RRS订阅ps:Next主题默认就支持插件git 参考链接123456789101112131415161718Step1cd博客根目录安装 RSS 插件npm install hexo-generator-feed --saveStep2开启网站 RSS 支持编辑网站根目录下的 _config.yml，添加以下代码开启# RSS订阅feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: &apos; &apos;]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS Developer Skills Matrix]]></title>
    <url>%2F2018%2F08%2F06%2FiOS%20Developer%20Skills%20Matrix%2F</url>
    <content type="text"><![CDATA[一线开发者应该定时整理下自己应该掌握哪些技能树，并思考如何规划以后横向或纵向的学习路线，以为下鄙人在学习过程中发现库iOS-Developer-Roadmap，感觉挺有价值所以用进行记录并翻译技能树。 PS:iOS-Developer-Roadmap项目发现的地方为Chrome的一个推荐Github项目插件 GitHunt Dark（寻找最受欢迎的GitHub项目） BohdanOrlov的Github库iOS-Developer-Roadmap上技能树翻译[原技能树图谱][翻译图谱] Junior Middle Senior 能力 Json做新闻类App 能够及时设计和交付快速可靠的聊天模块 可以用非狂热的想法建立团队行为标准 代码集成 使用git来移动代码 对GitFlow发表了看法 有想法如何建立CI过程和自动化 范式 有面向对象（OOP）的思想 能够处理比较难的FRP（响应式编程） 从其他平台和范例中获取价值 依赖 知道使用CocoaPods 知道使用苹果的包管理器 Swift Package Manager(SPM)，但是Carthage 也是一个选项 知道减少和拥有依赖关系的重要性 平台 会使用 Array/Dictionay/Set 道值/引用类型和Equatable / Hashable 知道swift和Objc-C的方法调度的细节 客户服务器协议 从互联网上获取JSON是件小事 进行基于WebSocket的实时聊天是可行的 建立视频聊天是一项可以实现的挑战 参考 使用StackOverFlow作为单一的事实来源 经常使用官方文档 询问平台开发人员并可以进行逆向工程 内存 知道如何避免和修复内存泄漏 知道NSPointterArray以及结构增加二进制的原因 有一个减少内存不足崩溃的策略 UI 可以在Interface Builder中构建基本UI 可以在代码中创建UI 可以对非主线程进行布局和差异计算 多线程 asyncAfter是朋友@synchronize所有的东西 asyncAfter是敌人，线程同步是个问题 理解多线程多余死锁 态度 期望他人在开发过程中进行教学和指导 与团队讨论设计以分享决策 负责设计决策的队友 设计模式 理解代理、target-action、mvc 精通Observe，Facade和Mediator模式 知道依赖注入和服务定位器之间的最佳位置 产品质量 如果应用程序在我的手机上运行，则会对其进测试 编写单元测试并尝试TDD和UI测试 定义了具有非重叠覆盖区域的可维护测试金字塔 部分学习参考知识点： 1、 Equatable / Hashable 2、 NSPointerArray、NSHashTable、NSMapTable[参考链接1) ][参考链接2] : 添加一个对象集合,但不想集合创建一个强引用 3、 Facade(iOS外观设计模式) 4、 Mediator中介者模式 4.1. 目前用到casatwy的CTMediator]用来进行路由设计，主要思想是动态进行方法调用：12345NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:methodSig];[invocation setArgument:&amp;params atIndex:2];[invocation setSelector:action];[invocation setTarget:target];[invocation invoke]; 4.2. 参考链接： !!!iOS应用架构谈 组件化方案 - 重点学习 iOS组件化实践方案－LDBusMediator炼就 iOS设计模式-中介者 Target-Action 实现组件解耦 —— CTMediator使用教程]]></content>
      <categories>
        <category>iOS学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈 ReactiveCocoa 之 MVVM]]></title>
    <url>%2F2017%2F10%2F24%2F%E6%B5%85%E8%B0%88%20ReactiveCocoa%20%E4%B9%8B%20MVVM%2F</url>
    <content type="text"><![CDATA[简介 ： ReactiveCocoa(简称：RAC)为一个开源函数响应式编程框架； 使用场景：通过RAC可以更加方便编程进行MVVM设计模式编程； 核心机制为信号（信号流）。 Demo地址 由于Swift和OC版本存在的差异性比较大，维护团队直接给拆了一下： Swift版本（ReactiveSwift）和 OC版本（ReactiveCocoa） 写该篇文章的初衷： 如何使用RAC 和 如何借助RAC来逐步实现MVC到MVVM的迁移。 一、ReactiveCocoa初见 1、编程思想ReactiveCocoa是函数式编程（Functional Programming）和响应式编程（Reactive Programming）集大成者； 2、实现关键： 2.1. 每个方法必须有返回值（本身对象）2.2. 把函数或者Block当做参数, block参数（需要操作的值）block返回值（操作结果）； 3、ReactiveCocoa初见 0、如何集成就略了（直接拉入项目或者CocoaPods） 1、 RACSiganl 最基本的信号类，默认为冷信号，表示当数据改变时，信号内部会发出数据，只有订阅了（subscribeNext）才会进被触发(编程热信号)，代码演示如下： 123456789101112131415// 1.创建信号RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; // 3、发送信号信号 NSLog(@&quot;信号被订阅 发送信号&quot;); // 4、执行了这一步 订阅信号才会发触发 [subscriber sendNext:@&quot;heheh&quot;]; return nil; &#125;]; // 2.订阅信号 ---必须为订阅 [signal subscribeNext:^(id _Nullable x) &#123; // 发送信号的内容 NSLog(@&quot;====%@&quot;, x); &#125;]; 2、RACSubscriber 订阅者，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。(示例也如上所示) 3、RACDisposable : 用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。使用场景:不想监听某个信号时，可以通过它主动取消订阅信号 代码演示如下： 1234567891011121314151617181920// 1.创建RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; // 3、发送信号信号 NSLog(@&quot;信号被订阅 发送信号&quot;); [subscriber sendNext:@&quot;heheh&quot;]; return [RACDisposable disposableWithBlock:^&#123; // 只要信号取消就会来这里 // 默认一个信号发送数据完毕就会主动取消订阅 NSLog(@&quot;信号被取消了&quot;); &#125;]; &#125;]; // 2.订阅信号 ---必须为订阅 RACDisposable *disposable = [signal subscribeNext:^(id _Nullable x) &#123; // 发送信号的内容 NSLog(@&quot;====%@&quot;, x); &#125;]; // 3.取消订阅 [disposable dispose]; 4、RACSubject 4.1. RACSubject:信号提供者，自己可以充当信号，又能发送信号。4.2. 用场景:通常用来代替代理，有了它，就不必要定义代理了。 5、RACTuple 元组类,类似NSArray,用来包装值. 123RACTuple *tuple = [RACTuple tupleWithObjectsFromArray:@[@&quot;hello111&quot;, @&quot;hello222&quot;,@&quot;hello333&quot;]]; NSLog(@&quot;%@&quot;, [tuple objectAtIndex:0]); 6、RACSequence 6.1、RAC中的集合类，用于代替NSArray,NSDictionary,可以使用它来快速遍历数组和字典。 12345678910111213141516171819202122232425262728291、RACSequence代替数组- (void)testRACSequenceArr&#123; NSArray * arr = @[@&quot;123&quot;, @&quot;asdfas&quot;, @1]; // 订阅集合信号，内部会自动便利所有的元素发出来 [arr.rac_sequence.signal subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;%@&quot;, x); &#125;];&#125;2、RACSequence代替字典- (void)testRACSequenceDict&#123; NSDictionary *dict = @&#123; @&quot;name&quot; : @&quot;张三&quot;, @&quot;age&quot; : @22&#125;; [dict.rac_sequence.signal subscribeNext:^(RACTuple * _Nullable x) &#123; // 方法一、 // NSLog(@&quot;%@ %@&quot;, x[0], x[1]); // 方法二、 // 用来解析元组， 宏里面的参数，传需要解析出来的变量名 // = 右边，放需要解析的元组 RACTupleUnpack(NSString *key, NSString *value) = x; NSLog(@&quot;%@ %@&quot;, key, value ); &#125;]; &#125; 7、RACCommand 7.1、直译为命令，只是一个继承自 NSObject 的类，但是它却可以用来创建和订阅用于响应某些事件的信号。7.2、相对而言比较复杂7.3、使用场景：网络请求（MVVM设计模式中网络模块）7.4、在默认情况下 RACCommand 都是不支持并发操作的，需要在上一次命令执行之后才可以发送下一次操作，如果直接execute:两次，最终也只会执行第一个execute：； 所以谨记 在使用应用中推荐一个网络请求对应一个command； 1234567891011121314151617181920212223242526简单使用 - 用于网络请求- (void)RACCommandSimpleUse&#123; RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(NSNumber * _Nullable input) &#123; return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:input]; // 每次sendNext 记得sendCompleted [subscriber sendCompleted]; return nil; &#125;]; &#125;]; [[command.executionSignals switchToLatest] subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;%@&quot;, x); &#125;]; // 在默认情况下 RACCommand 都是不支持并发操作的，需要在上一次命令执行之后才可以发送下一次操作，如果直接execute:两次，最终也只会执行第一个execute： // 所以谨记: 一个command对应一个网络请求 [command execute:@&quot;网络请求1&quot;]; // [command execute:@&quot;网络请求2&quot;]; [RACScheduler.mainThreadScheduler afterDelay:0.5 schedule:^&#123; [command execute:@&quot;网络请求2&quot;]; &#125;];&#125; 8、RACMulticastConnection 8.1、直译为多播连接;8.2、存在的问题普通的信号在执行sendNext:的时候，都会重新再执行以下信号的创建，当你想在一个请求完成后 进行分多级刷新UI 或者 做一些别的操作，如果直接用普通的信号进行sendNext：时候，则会进行多次网络请求操作；8.3、项目中使用到的场景比较少； 1234567891011121314151617181920212223242526272829303132333435-(void)RACMulticastConnectionUse&#123; // 1、通过信号创建链接 RACMulticastConnection *connection = [[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; NSLog(@&quot;完毕&quot;); [subscriber sendNext:@&quot;Send Request&quot;]; // 每次sendNext 记得sendCompleted // [subscriber sendCompleted]; return nil; &#125;] publish]; // 订阅信号（通过链接转换的信号）一次 [connection.signal subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;一次 x : %@&quot;, x); &#125;]; // 订阅信号（通过链接转换的信号）二次 [connection.signal subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;二次 x : %@&quot;, x); &#125;]; [connection connect]; // 且只有第一次连接才会有效果 // [connection.signal subscribeNext:^(id _Nullable x) &#123; // NSLog(@&quot;重新连接第一次 x : %@&quot;, x); // &#125;]; // [connection.signal subscribeNext:^(id _Nullable x) &#123; // NSLog(@&quot;重新连接第二次 x : %@&quot;, x); // &#125;]; // [connection connect];&#125; 二、ReactiveCocoa使用场景 1、代替代理 1、对象持有signal， 推荐用这种 1234567Code eg.:- (void)useRACInstandDelegate&#123; [self.redView.btnClickSignal subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;%@&quot;, x); &#125;];&#125; 2、使用rac_signalForSelector来进行方方法的执行，类似于系统自带方法performSelector:withObject:，不推荐(硬编码 和 警告)； 12345678Code eg.:- (void)useRACInstandDelegate2&#123; [[self.redView rac_signalForSelector:@selector(btnClick:)] subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;红色view上面的按钮点击了&quot;); &#125;];&#125; 2、代替KVO： 123456789101112131415161718- (void)insteadKVO&#123; // 需手动导入：#import &quot;NSObject+RACKVOWrapper.h&quot; // 1.代替KVO 方法一 [self.redView rac_observeKeyPath:@&quot;frame&quot; options:NSKeyValueObservingOptionNew observer:nil block:^(id value, NSDictionary *change, BOOL causedByDealloc, BOOL affectedOnlyLastComponent) &#123; // &#125;]; // 2.替代KVO 方法二 [[self.redView rac_valuesForKeyPath:@&quot;frame&quot; observer:nil] subscribeNext:^(id _Nullable x) &#123; // 打印的是NSRect NSLog(@&quot;%@&quot;, x); &#125;]; 3、监听按钮的点击事件： 12345678- (void)monitorBtnClick&#123; UIButton *btn; [[btn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl * _Nullable x) &#123; &#125;];&#125; 4、代替通知： 12345678- (void)insteadNotification&#123; [[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardWillShowNotification object:nil] subscribeNext:^(NSNotification * _Nullable x) &#123; &#125;];&#125; 5、监听文本框文案： 1234567- (void)insteadTextInput&#123; UITextField *textField; [textField.rac_textSignal subscribeNext:^(NSString * _Nullable x) &#123; // 监听到文本的改变 &#125;];&#125; 6、处理当界面有多次请求时，需要都获取到数据时，才能展示界面 1234567891011121314151617181920212223242526272829303132333435- (void)multiRequestData&#123; RACSignal *signal1 = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; NSLog(@&quot;发送木块一的数据&quot;); [subscriber sendNext:@&quot;发送木块一的数据&quot;]; return nil; &#125;]; RACSignal *signal2 = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; NSLog(@&quot;发送模块二的数据&quot;); [subscriber sendNext:@&quot;发送模块二的数据&quot;]; return nil; &#125;]; // 数组：存放信号 // 当数组中的所有信号都发送完成的时候，才会执行Selector // 方法的参数： 必须跟数组一一对应 // 方法的参数：就是每一个信号发送的数据 [self rac_liftSelector:@selector(updateUIFirstPartData:secondPartData:) withSignalsFromArray:@[signal1, signal2]];&#125;- (void)updateUIFirstPartData:(NSString *)firstPartData secondPartData:(NSString *)secondPartData&#123; NSLog(@&quot;更新 UI%@ %@&quot;,firstPartData , secondPartData);&#125; 三、浅谈MVVM 简介：MVVM,个人理解他就是MVC的升级版，解耦版，它是一种双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然； MVVM设计模式并不一定要借助RAC来实现，但若使用RAC来实现会更加的简单(因为所有的操作和响应都通过信号来完成对接)；M : 最基本的模型数据V : 视图 / 控制器VM : 处理业务的逻辑（eg:操作事件、数据请求等） 1.项目目录结构的体现（给你一种既视感😆）： Module├── Controllers├── Views├── Models└── VM 2.具体的实操（由于比较简单的实现，model数据就放在VM里面） 2.1. V(控制器或者视图)里面的写法： 提前对数据进行绑定 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748备注： LoginVc.m 文件， LoginVc.h文件可忽略#import &quot;LoginVc.h&quot;#import &quot;LogingVM.h&quot;@interface LoginVc ()@property (weak, nonatomic) IBOutlet UITextField *userNameTF;@property (weak, nonatomic) IBOutlet UITextField *pwdTF;@property (weak, nonatomic) IBOutlet UIButton *LoginBtn;@property (nonatomic, strong) LogingVM *loginVM;@end@implementation LoginVc- (void)viewDidLoad &#123; [super viewDidLoad]; [self initRac]; &#125;- (void)initRac&#123; // 1. 绑定信号 RAC(self.loginVM, account) = self.userNameTF.rac_textSignal; RAC(self.loginVM, pwd) = self.pwdTF.rac_textSignal; // 2. 登陆按钮能否点击 RAC(_LoginBtn,enabled) = self.loginVM.loginEnableSiganl; // 3. 监听登录按钮点击 [[_LoginBtn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) &#123; // 处理登录事件 =&gt; 发送登陆请求 [self.loginVM.loginCommand execute:nil]; &#125;];&#125;- (LogingVM *)loginVM&#123; if (!_loginVM) &#123; _loginVM = [[LogingVM alloc] init]; &#125; return _loginVM;&#125;@end 2.2. VM （数据的交互），由于比较简单直接把model放到了VM里面了, 一些数据的逻辑处理， 按钮是否可点击，网络是否要请求等； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879头文件：LogingVM.h#import &lt;Foundation/Foundation.h&gt;@interface LogingVM : NSObject@property (nonatomic, strong) NSString *account;@property (nonatomic, strong) NSString *pwd;@property (nonatomic, strong, readonly) RACSignal *loginEnableSiganl; /**&lt; 处理登录按钮是否允许点击 */@property (nonatomic, strong, readonly) RACCommand *loginCommand;/** 登录按钮命令 */@end实现文件： LogingVM.m#import &quot;LogingVM.h&quot;@implementation LogingVM- (instancetype)init&#123; if (self = [super init]) &#123; [self setUp]; &#125; return self;&#125;// 初始化操作- (void)setUp&#123; // 1.登录按钮是否能点击 的信号 _loginEnableSiganl = [RACSignal combineLatest:@[RACObserve(self, account), RACObserve(self, pwd)] reduce:^id(NSString *account,NSString *pwd)&#123; return @(account.length &amp;&amp; pwd.length); &#125;]; // 2.登录点击 信号 _loginCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123; return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; // 发送数据 [subscriber sendNext:@&quot;请求登录的数据&quot;]; [subscriber sendCompleted]; &#125;); return nil; &#125;]; &#125;]; // 3.处理登录请求返回的结果 [_loginCommand.executionSignals.switchToLatest subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;]; // 4.处理登录执行过程 [[_loginCommand.executing skip:1] subscribeNext:^(id x) &#123; if ([x boolValue] == YES) &#123; NSLog(@&quot;登陆成功&quot;); &#125;else&#123; NSLog(@&quot;登陆时报&quot;); &#125; &#125;];&#125;@end 3、 通过上面的登陆示例，可以感受到RAC在MVVM的便捷性，可测试性（VM）都有一定的提高。 4、如果项目把设计模式由MVC迁移为MVVM，可以分步走，可以理解MVVM是升级版的MVC， 其实就是把以前放在VC 里面处理的逻辑有条理的放到VM里面，Code可测性变高。]]></content>
      <categories>
        <category>iOS学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARKit解读]]></title>
    <url>%2F2017%2F06%2F07%2FARKit%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[官网地址 一、了解： ARSession ： 管理设备相机和增强现实体验所需的运动处理的共享对象。 二、配置： ARSessionConfiguration： 仅跟踪设备方向的基本配置。 ARWorldTrackingSessionConfiguration : 跟踪设备的方向和位置以及检测设备相机所看到的实际表面的配置。 三、标准视图： 建立基本的AR经验 （配置AR会话，并使用SceneKit或SpriteKit显示AR内容。） ARSKView ：用于显示使用2D SpriteKit内容增强相机视图的AR体验的视图。 ARSCNView :用于显示使用3D SceneKit内容增强相机视图的AR体验的视图。 四、自定义视图： 用Metal显示AR体验 通过渲染相机图像和使用位置跟踪信息来显示叠加内容来构建自定义AR视图。 五、现实世界的对象和位置 ARAnchor : 可用于将对象放置在AR场景中的现实世界的位置和方向。 ARPlaneAnchor : 有关AR会话中检测到的真实平面的位置和方向的信息。 ARHitTestResult : 通过检查AR会话的设备摄像头视图中的一个点找到有关现实世界表面的信息。 六、相机和场景细节 ARFrame : 作为AR会话的一部分捕获的视频图像和位置跟踪信息。 ARCamera : 有关AR会话中捕获的视频帧的摄像机位置和成像特性的信息。 ARLightEstimate : 与AR会话中捕获的视频帧相关联的估计场景照明信息。]]></content>
      <categories>
        <category>iOS学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尼康D5200的使用]]></title>
    <url>%2F2016%2F09%2F05%2F%E5%B0%BC%E5%BA%B7D5200%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[蚂蚁摄影视屏教程 1、镜头和机身主要按键介绍： 1.1、镜头和机身上的按键的熟悉 1.2、新手应该了解的知识：光圈、快门、感光度 1.3、机身和镜头的拆卸和组装（咔的一声） 1.4、VR:光学防抖（一般开启） 1.5、A/M 自动或者手动（一般设置为A） 1.6、镜头锁（有些有有些没有，旋转至18的时候开启了锁，这个锁是便于携带） 1.7、fn 自定义设定；（设置为感光ISO） menu-&gt;自定义菜单-&gt;f控制 -&gt; 指定fn控制 —&gt; 然后选择（自己想要的选项：ISO感光度） 调节的时候 长按 fn + 滚动轮 1.8、闪电符号： 闪光灯 1.9、对焦辅助灯 2.0、开关机拨杆 / 快门键 2.1、红点：录像 2.2、右边曝光补偿键（光圈的标识：调节光圈大小 + / — ） 2.3、info ： 屏幕的开关机键 2.4、单张拍摄、连拍、自拍 2.5、显示屏取景和取景器取景 （LV方向：显示屏取景 再按下info键则显示一些信息） 反之切换 2.6、顶部转盘-&gt;模式转盘：（顺时针方向命名） P ： 程序自动模式 S ：快门优先 （佳能上叫tv） A : 光圈优先模式 M: 全手动模式 AUTO:全自动 闪光灯关闭 SCENE 场景模式 （夜景、室内、海滩等11种场景模式） 人像模式 风景模式 儿童照模式 运动模式 小花：微距模式 EFFECTS: 滤镜特效模式（模型效果、剪影等一些特俗的效果） 2.7、取景器 2.8、显示屏 2.9、I 键 ： 尼康相机设置参数通用按钮键 ，操作方式：I —&gt; 上下左右键 —&gt;OK —&gt; 需要选择的项目 —&gt; OK确定 3.0、拨盘：调节参数 3.1、相册 3.2、上下左右 / 确认 键 （看照片的时候： 左右键切换、上下键可以显示更多的信息） 3.3、放大 和 缩小 ： 查看照片 放大 （缩小：帮助菜单键，选择某个选项的时候，按下缩小键 会出现更多信息便于我们理解，灯光较 暗的时候，左下角会出现一个 ？在一直闪烁，这时候按 缩小键 则会提示你打开闪光灯进行补光 ） 3.4、menu键：一些设置 光圈 D5200 是39点对焦 曝光指示表（0的找出来的照片： 左边暗、右边亮） 屏幕指示意义： 2、闪光灯：较暗就开灯3、变焦： 旋转变焦环（调成显示屏取景、或者取景器取景）4、连拍/自拍（抓拍： 按下上面的连拍按钮（高速：5 ；低速：3）； 自拍：10秒延时自拍）5、视频录制：可以录制 全高清视频（先切换为显示屏取景正在录制，且上面的意义：录制模式：全高清）新手用A ： 光圈优先6、光圈（用来控制进光大小）： 大光圈： 人物 （视角窄）； 小光圈：大场景，适合拍风景（视角大）； 中间光圈调整： 按住 上面的曝光补偿 + 转动拨盘 就可以调整了 （往右边转：F后面年数字越大，光圈越小； 左边:F后面数字越来越小，光圈越来越大）7、快门：控制进光时间 （S 和 M 模式下才可以调节）仅仅拨动拨盘就能调整: 左慢右快 高速快门：抓拍小宝宝 和运动员的 精彩瞬间 慢速快门：记录汽车尾灯拉丝 和 星空流星轨迹效果8、感光度ISO：对光线的敏感度，P S M A 模式下都可以调整（可以设置快捷键，或者按 I键进行） 感光度越低 画面越整体越暗 画质越清楚（在光线充足的情况下，推荐尽量使用低感光ISO白天推荐使用100就好；） 感光度越高 画面整体越亮 但是噪点高，画质会更粗糙） 9、对焦方式： P S A M模式下可以调整 对焦方式 : 4 种 AF - A : 自动伺服对焦 （动静对焦方式的自动切换） AF - S ：单次伺服对焦（适合拍摄静止的物体） AF - C ：连续伺服对焦 （适合拍摄动态的物体） 马拉松赛事 MF : 手动对焦 对焦区域：选择 派人物 拍眼睛 ，人更加有神， 在对焦区域模式里面选择 单点对焦 —&gt; 通过上下左右键 从39个对焦点钟任意选择一个对焦点 对焦区域： 推荐使用39点对焦 + 连续对焦 ===&gt; 更好的抓拍 10、测光模式：（P S A M模式下都可以调节） M 如何操作： I 键 —&gt; 测光模式 —&gt; OK —&gt; 测光模式的选择界面 矩阵测光、中央重点测光、点测光 曝光准确的照片：避免曝光不足太暗、 曝光太足引起抓拍太亮 风景和合影， 平价测光 逆光中的人物 推荐 使用 点测光 把 需要 拍摄的物体放在中间的时候 就需要 中央重点测光 优雅的拍照姿势：1、 双脚与双肩齐平；2、蹲着：单膝跪地，用后胳膊肘放腿上；3、依靠： 三角形具有稳定性； 保养：清洁镜头 ： 用拭擦布向一个方向拭擦换镜头： 需要 向下 换 防止灰尘]]></content>
      <categories>
        <category>爱好</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发成长之道]]></title>
    <url>%2F2015%2F12%2F28%2FiOS%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[1、创作（写有深度的博客、仿制优秀的项目、随时记录理解）； 2、做有难度的项目； 3、“不用则废”不只是针对技能，还针对理解； 4、尽量少抱大腿,或者压根就别抱大腿； 5、多读源码(用五柳先生的话就是,不求甚解. 但是读源码也不能盲目的看,最好是看和最近的工作相关的)； 6、多读国外的iOS开发网站和blog：Raywenderlich 和 nshipster 还有 objc.io 7、要孜孜不倦的学习： （学习第二门开发语言：推荐python）；]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>个人成长</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Flutter 网络的三种简单实现]]></title>
    <url>%2F2019%2F02%2F23%2FFlutter-%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%89%E7%A7%8D%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[概述：本文主要讲解了flutter网络请求三种方式 flutter自带的HttpClient、 第三方库http 和 第三方库Dio 的简单实现 GET 和 POST请求，本文是笔者学习Flutter网络模块知识总结，若有问题还望不腻赐教。 本文Demo地址 一.系统自带HttpClient1.使用中温馨提示1.1.导入库12import 'dart:io'; // 网络请求import 'dart:convert'; // 数据解析 1.2.Uri的多种初始化方式123456// 方法1Uri uri = Uri(scheme: 'https', host: 'appbg.lcfarm.com', path: homeNoviceListUrl);// 方法2Uri uri = Uri.https('appbg.lcfarm.com', homeNoviceListUrl);// uri方法3Uri uri = Uri.parse(njqbaseUrl + homeNoviceListUrl); 2.简单使用2.1.GET请求123456789101112131415161718192021222324252627282930313233343536373839404142434445// 1.1 HttpClient - get （疑问？queryParameters仅仅用在get请求吗）void loadData_sys_get() async &#123;print('------loadData_sys_get--------');var httpClient = new HttpClient();var params = Map&lt;String, String&gt;();// uri方法1Uri uri = Uri(scheme: 'https', host: 'appbg.lcfarm.com', path: homeNoviceListUrl);// uri方法2// Uri uri = Uri.https(// 'appbg.lcfarm.com', homeNoviceListUrl);// uri方法3// Uri uri = Uri.parse(njqbaseUrl + homeNoviceListUrl);var request = await httpClient.getUrl(uri);var headers = Map&lt;String, String&gt;();headers['loginSource'] = 'IOS';headers['useVersion'] = '3.1.0';headers['isEncoded'] = '1';headers['bundleId'] = 'com.nongfadai.iospro';request.headers.add("loginSource", "IOS");request.headers.add("useVersion", "3.1.0");request.headers.add("isEncoded", "1");request.headers.add("bundleId", "com.nongfadai.iospro");var response = await request.close();var responseBody = await response.transform(Utf8Decoder()).join();if (response.statusCode == HttpStatus.ok) &#123; print('请求头：$&#123;response.headers&#125;'); print('111请求成功代发数据为:\n $responseBody'); print('--------------'); Map data = jsonDecode(responseBody); print('222请求成功代发数据为:\n $data');&#125; else &#123; print('\n\n\n11111==请求失败$&#123;response.statusCode&#125;');&#125;&#125; 2.2.POST请求注意点：请求参数需要编码后放在request中12345678910111213141516171819202122232425262728293031323334void loadData_sys_post() async &#123;print('------loadData_sys_post--------');HttpClient httpClient = new HttpClient();// queryParameters get请求的查询参数(适用于get请求？？？是吗？？？)// Uri uri = Uri(// scheme: "https", host: "appbg.lcfarm.com", path: homeRegularListUrl);// HttpClientRequest request = await httpClient.postUrl(uri);var url = njqbaseUrl + homeRegularListUrl;HttpClientRequest request = await httpClient.postUrl(Uri.parse(url));// 设置请求头request.headers.set("loginSource", "IOS");request.headers.set("useVersion", "3.1.0");request.headers.set("isEncoded", "1");request.headers.set("bundleId", "com.nongfadai.iospro");// Content-Type大小写都okrequest.headers.set('content-type', 'application/json');/// 添加请求体/// https://stackoverflow.com/questions/50278258/http-post-with-json-on-body-flutter-dart/50295533Map jsonMap = &#123;'currentPage': '1'&#125;;request.add(utf8.encode(json.encode(jsonMap)));HttpClientResponse response = await request.close();String responseBody = await response.transform(utf8.decoder).join();if (response.statusCode == HttpStatus.ok) &#123; print('请求成功'); print(response.headers); print(responseBody);&#125;&#125; 二.请求第三方库 http1.使用中温馨提示1.1.添加依赖12dependencies: http: ^0.12.0 #latest version 1.2.导入库1import 'package:http/http.dart' as http; //导入前需要配置 2.简单使用2.1. GET请求2.2.1. http - get1123456789101112131415void loadData_http_get() async &#123; print('------loadData_http_get--------'); var client = http.Client(); var uri = Uri.parse(njqbaseUrl + homeNoviceListUrl); http.Response response = await client.get(uri); if (response.statusCode == HttpStatus.ok) &#123; print(response.body); &#125; else &#123; print('请求失败 code 码为$&#123;response.statusCode&#125;'); &#125;&#125; 2.2. http - get简便方法（链式编程）12345678910111213void loadData_http_get_convenience() async &#123; print('------简便方法loadData_http_get_convenience--------'); var uri = Uri.parse(njqbaseUrl + homeNoviceListUrl); http.Client().get(uri).then((http.Response response) &#123; if (response.statusCode == HttpStatus.ok) &#123; print(response.body); &#125; else &#123; print('请求失败 code 码为$&#123;response.statusCode&#125;'); &#125; &#125;); &#125; 2.2. POST请求2.2.1. http - post1234567891011121314151617181920212223242526272829void loadData_http_post() async &#123; print('------ loadData_http_post --------'); var headers = Map&lt;String, String&gt;(); headers["loginSource"] = "IOS"; headers["useVersion"] = "3.1.0"; headers["isEncoded"] = "1"; headers["bundleId"] = "com.nongfadai.iospro"; headers["loginSource"] = "IOS"; headers["Content\-Type"] = "application/json"; Map params = &#123;'currentPage': '1'&#125;; // 嵌套两层都可以，但是具体哪个好还有待确认？？？？ var jsonParams = utf8.encode(json.encode(params)); // var jsonParams = json.encode(params); var httpClient = http.Client(); var uri = Uri.parse(njqbaseUrl + homeNoviceListUrl); http.Response response = await httpClient.post(uri, body: jsonParams, headers: headers); if (response.statusCode == HttpStatus.ok) &#123; print(response.body); &#125; else &#123; print('请求失败 code 码���$&#123;response.statusCode&#125;'); &#125;&#125; 2.2.2. http - Post简便方法（链式编程）1234567891011121314151617181920212223242526void loadData_http_post_convenience() async &#123; print('------ loadData_http_post --------'); var headers = Map&lt;String, String&gt;(); headers["loginSource"] = "IOS"; headers["useVersion"] = "3.1.0"; headers["isEncoded"] = "1"; headers["bundleId"] = "com.nongfadai.iospro"; headers["loginSource"] = "IOS"; headers["Content\-Type"] = "application/json"; Map params = &#123;'currentPage': '1'&#125;; // 嵌套两层都可以，但是具体哪个好还有待确认？？？？ var jsonParams = utf8.encode(json.encode(params)); // var jsonParams = json.encode(params); var httpClient = http.Client(); var url = njqbaseUrl + homeRegularListUrl; httpClient.post(url, body: jsonParams, headers: headers).then((response) &#123; print("Response status: $&#123;response.statusCode&#125;"); print("Response body: $&#123;response.body&#125;"); &#125;).whenComplete(httpClient.close);&#125; 三.请求第三方库 Dio1.使用中温馨提示1.1.添加依赖12dependencies: dio: ^2.0.11 #latest version 1.2.导入库1import 'package:dio/dio.dart'; 2.简单使用2.1. GET请求注意：Dio的get请求（baseUrl都是在dio.option.baseUrl设置的） 请求头可以在dio.option上设置，也可以在新建的option上设置,新建option是可选的12345678910111213141516171819void loadData_dio_get() async &#123; var headers = Map&lt;String, String&gt;(); headers['loginSource'] = 'IOS'; headers['useVersion'] = '3.1.0'; headers['isEncoded'] = '1'; headers['bundleId'] = 'com.nongfadai.iospro'; headers['Content-Type'] = 'application/json'; Dio dio = Dio(); dio.options.headers.addAll(headers); dio.options.baseUrl = njqbaseUrl; Response response = await dio.get(homeNoviceListUrl); if (response.statusCode == HttpStatus.ok) &#123; print(response.headers); print(response.data); &#125; &#125; 2.2. POST请求2.2.1. dio - 方式一（baseUrl都是在dio.option.baseUrl设置的）注意：直接在 dio.options设置除methods以外的 请求头参数123456789101112131415161718192021222324252627282930313233void loadData_dio_dioOfOptionsSetting() async &#123; debugPrint( ' \n post请求 ======================= 开始请求 =======================\n'); var headers = Map&lt;String, String&gt;(); headers['loginSource'] = 'IOS'; headers['useVersion'] = '3.1.0'; headers['isEncoded'] = '1'; headers['bundleId'] = 'com.nongfadai.iospro'; headers['Content-Type'] = 'application/json'; Dio dio = Dio(); dio.options.baseUrl = njqbaseUrl; dio.options.connectTimeout = 60000; dio.options.receiveTimeout = 60000; dio.options.headers.addAll(headers); dio.options.method = 'post'; Options option = Options(method: 'post'); // Response response = await dio.request(homeRegularListUrl, // data: &#123;"currentPage": "1"&#125;, options: option); Response response = await dio.post(homeRegularListUrl, data: &#123;"currentPage": "1"&#125;, options: option); if (response.statusCode == HttpStatus.ok) &#123; debugPrint('请求参数： $&#123;response.request.queryParameters&#125;'); debugPrint( '-------------------请求成功,请求结果如下:-----------------\n \n===请求求url: $&#123;response.request.uri.toString()&#125; \n \n===请求 ���: \n$&#123;response.headers&#125; \n \n===请求结果: \n$&#123;response.data&#125;\n'); debugPrint('-------------------请求成功,请求结果打印完毕----------------'); &#125; else &#123; print('请求失败'); &#125; &#125; 2.2.2. dio - 方式二（baseUrl都是在dio.option.baseUrl设置的）注意：在新建的option上设置请求头参数12345678910111213141516171819202122232425262728293031void loadData_dio_newOptionSetting() async &#123; debugPrint(' \n======================= 开始请求 =======================\n'); var headers = Map&lt;String, String&gt;(); headers['loginSource'] = 'IOS'; headers['useVersion'] = '3.1.0'; headers['isEncoded'] = '1'; headers['bundleId'] = 'com.nongfadai.iospro'; headers['Content-Type'] = 'application/json'; Options option = Options(method: 'post'); option.connectTimeout = 60000; option.receiveTimeout = 60000; option.headers.addAll(headers); Dio dio = Dio(); dio.options.baseUrl = njqbaseUrl; Response response = await dio.post(homeRegularListUrl, data: &#123;"currentPage": 1&#125;, options: option); // Response response = await dio.request(homeRegularListUrl, // data: &#123;"currentPage": 1&#125;, options: option); if (response.statusCode == HttpStatus.ok) &#123; debugPrint('请求参数： $&#123;response.request.queryParameters&#125;'); debugPrint( '-------------------请求成功,请求结果如下:-----------------\n \n===请求url: $&#123;response.request.uri.toString()&#125; \n \n===请求 头: \n$&#123;response.headers&#125; \n \n===请求结果: \n$&#123;response.data&#125;\n'); debugPrint('-------------------请求成功,请求结果打印完毕----------------'); &#125; else &#123; print('请求失败'); &#125; &#125; 本文Demo地址]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则替换url字符串中的值]]></title>
    <url>%2F2019%2F02%2F18%2F%E6%AD%A3%E5%88%99%E6%9B%BF%E6%8D%A2url%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%80%BC%2F</url>
    <content type="text"><![CDATA[1、方法一：键和值一起替换 1234567891011121314151617- (NSString *) paramValueOfUrl:(NSString *) url withParam:(NSString *) param value:(NSString *)value&#123; NSError *error; NSString *targetString = [NSString stringWithFormat:@&quot;%@=%@&quot;,param,value]; NSString *regTags = [[NSString alloc] initWithFormat:@&quot;%@=+([\\w]*)&quot;,param]; NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:regTags options:0 error:&amp;error]; NSString *string = [regex stringByReplacingMatchesInString:url options:0 range:NSMakeRange(0, [url length]) withTemplate:targetString]; return string;&#125; 2、方法二： 值替换 1234567891011121314151617181920212223242526/// 方法二：- (NSString *) paramValueOfUrl2:(NSString *) url withParam:(NSString *) param value:(NSString *)value&#123; NSError *error; // (^|&amp;|\\?|#)+%@=+([^&amp;|#]*)(#|&amp;|$) ： range 取 [match rangeAtIndex:2] // %@=+([^&amp;|#]*)(#|&amp;|$) ： range 取 [match rangeAtIndex:1] // 通过numberOfRanges获取结果数量，然后分别打印获取值 [url substringWithRange:[match rangeAtIndex:i]] NSString *regTags = [[NSString alloc] initWithFormat:@&quot;(^|&amp;|\\?|#)+%@=+([^&amp;|#]*)(#|&amp;|$)&quot;,param]; NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:regTags options:NSRegularExpressionCaseInsensitive error:&amp;error]; // 执行匹配的过程 NSArray *matches = [regex matchesInString:url options:0 range:NSMakeRange(0, [url length])]; for (NSTextCheckingResult *match in matches) &#123; NSRange range = [match rangeAtIndex:2]; NSString *tagValue = [url substringWithRange:range]; // 分组2所对应的串 if (![value isEqualToString:tagValue]) &#123; url = [url stringByReplacingCharactersInRange:range withString:value]; &#125; &#125; return url;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发工具攻略(一)]]></title>
    <url>%2F2018%2F08%2F07%2FSublime%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. Sublime安装插件报错解决办法 错误：There are no packages available for installation 解决办法：12345678910111213141516171819Step1:Preferences-&gt;PackageSettings-&gt;PackageControl-&gt;Settings-UserStep2:在文件里面添加如下代码：&quot;debug&quot;: true,&quot;downloader_precedence&quot;: &#123; &quot;windows&quot;: [&quot;wininet&quot;], &quot;osx&quot;: [&quot;curl&quot;, &quot;wget&quot;], &quot;linux&quot;: [&quot;urllib&quot;, &quot;curl&quot;, &quot;wget&quot;] &#125;,Step3: ⁃ command + shift + p 进行插件安装 首先的安装插件管理器： Install Package 然后输入要安装的插件名称 2. Github转移项目到Coding.net笔者的需求：个人博客部署系统代码不需要进行在github上进行公开，github私有项目又需要付费，感觉不值，所以有此次需求 参考 1. Coding.net上建立一个新的私有仓库（有就不用建立）2.Coding.net配置公钥,git操作需要权限1234567891011121314Step1command+shift+. 展示隐藏文件，然后cd到.ssh文件下面找到.pub结尾的文件(即公钥文件)，拷贝私钥Step2coding个人中心 - SSH公钥 - 新增公钥 添加就好ps:补充如何生成SSH公钥1. 根目录下 执行ssh-keygen确认保存公钥的位置（.ssh/id_rsa）重复一个密码两次，如果不想在使用公钥的时候输入密码，可以留空2. 获取公钥 cat ~/.ssh/id_rsa.pub 3. 把github上的代码clone到指定路径123git clone --bare https://github.com/***/******.gitps: --bare 创建的克隆版本库都不包含工作区，直接就是版本库的内容，这样的版本库称为裸版本库。 4.使用镜像推送的方式上传代码到新的服务器123456cd xxxx.gitgit push --mirror https://git.coding.net/cc412/xxxx.gitps: https://git.coding.net/cc412/xxxx.git 是coding.net仓库地址 如果https不行推荐用SSH 5.删除本地代码12cd ..//返回上一路径rm -rf xxxx.git //干掉 6.从新服务器clone下来，就是你想要的库了123git clone https://git.coding.net/cc412/xxxx.gitps： 如果https不行推荐用SSH 7. 码云 也是一样的操作,笔者验证码云https和SSH都OK，最终用哪个看自己需要，笔者最终选择了码云！]]></content>
      <categories>
        <category>开发工具攻略</category>
      </categories>
      <tags>
        <tag>攻略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next主题博客功能完善]]></title>
    <url>%2F2018%2F08%2F07%2FNext%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%96%84%2F</url>
    <content type="text"><![CDATA[前提为你已经搭建好hexo next博客如果没有，则参考搭建吧😝注意：下载next地址变了next新地址博客部署命令可以用&amp;&amp;操作： hexo clean &amp;&amp; hexo g &amp;&amp; hexo s hexo clean &amp;&amp; hexo g &amp;&amp; hexo d！！！很多插件安装，网上的如果不行，请直接参考插件官网，最官方 一、配置问题注意点1. 文章显示中文12根目录/_config.yml（不是next下面的哈）language: zh-CN # 是zh-CN 不是zh-Hans 2. 首页显示阅读全文12345themes/next/_config.ymlauto_excerpt: enable: true # 设置是否显示阅读全文，文章较多的话，有必要设置为 true length: 200 #预览展示多少文字 3. 分享功能ps:微信图片加载不出来，所以去掉了12345678910111213141516171819202122232425Step1source/libgit clone https://github.com/theme-next/theme-next-needmoreshare2 source/lib/needsharebuttonps：名字不是随便的needsharebuttonStep2needmoreshare2: enable: true postbottom: enable: true options: iconStyle: box boxForm: horizontal position: bottomCenter networks: Weibo,Douban,QQZone,Twitter,Facebook float: enable: true options: iconStyle: box boxForm: horizontal position: middleRight networks: Weibo,Douban,QQZone,Twitter,Facebook 4. 添加分类和标签官方链接参考链接 4.1. 添加分类12345678910111213141516171819202122232425262728293031323334353637Step1进入博客所在文件夹执行 ： hexo new page categories成功提示 ： INFO Created: ~/Documents/blog/source/categories/index.md根据上面的路径，找到index.md这个文件，打开后默认内容是这样的：---title: 文章分类date: 2017-05-27 13:47:40---添加type: &quot;categories&quot;到内容中，添加后是这样的：---title: 文章分类date: 2017-05-27 13:47:40type: &quot;categories&quot;---新建文章后 hexo new [post] 文章标题添加categories属性，再部署之后就可以在分类页看到分类了---title: hexo next 为文章添加分类date: 2016-03-16 08:12:43tags:categories: 前端---或则这样但是分类只能添加一个---title: hexo next 为文章添加分类date: 2016-03-16 08:12:43tags:categories: - 前端--- 4.2. 添加标签123456789101112131415161718192021222324252627282930313233Step1进入博客所在文件夹hexo new page tags成功后提示INFO Created: ~/Documents/blog/source/tags/index.md根据上面的路径，找到index.md这个文件，打开后默认内容是这样的：---title: 标签date: 2017-05-27 14:22:08---添加type: &quot;tags&quot;到内容中，添加后是这样的：---title: 文章分类date: 2017-05-27 13:47:40type: &quot;tags&quot;---Step2新建文章或者想给某个文件添加tags，则如下操作---title: jQuery对表单的操作及更多应用date: 2017-05-26 12:12:57categories: - web前端tags:- jQuery- 表格- 表单验证--- 注意： 1.只有添加了tags: xxx的文章才会被收录到首页的“标签”中。 2.在categories和tags的index.m文件里面添加 comments: false ，把评论关了 细心的朋友可能已经发现，这两个的设置几乎一模一样！是的，没错，思路都是一样的。所以我们可以打开scaffolds/post.md文件，在tages:上面加入categories:,保存后，之后执行hexo new 文章名命令生成的文件，页面里就有categories:项了。 scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。 5. 文章侧边栏控制123# 这个地方控制自动打开文章目录条# #sidebar: 注释掉则表示一打开详情页不会自动弹出sidebar sidebar: 6. 不要Next自动添加序号1234567891011themes/next/_config.yml 修改 number: falsetoc: enable: true # Automatically add list number to toc. # 不要next系统添加序号 number: false #true # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false 7.代码高亮主题色12需要写明语言才会真正有效果hexo next highlight_theme 设置 8. 安装与卸载插件8.1. 安装12npm install xxx –save做相应配置（官网） 8.2. 卸载123456npm uninstall 插件名称 --save去掉相应配置(安装时候配置的)例： 卸载hexo s上传图片到的七牛插件（个人安装又卸载了）npm uninstall hexo-qiniu-sync --save去掉根目录/_config.yml下配置 9.网页加载动画效果PS： next 已经集成好动画了，如果对速度有要求的话直接关闭，个人选择关闭,加载太慢了。123# 加载有点慢 关掉motion: enable: false #true 10. 如何在首页添加图片参考链接12345678910111213每篇文章里面添加photos: —&quot;图片链接&quot;---layout: &apos;[post]&apos;title: Next主题博客功能完善date: 2018-08-07 00:25:53tags:- 博客- 技巧categories: 博客搭建photos: - &quot;http://oz2tkq0zj.bkt.clouddn.com/17-11-9/52323298.jpg&quot;--- 二、 添加功能插件1. 图片浏览放大功能fancybox1234567891011Step1:cd next/source/libgit clone https://github.com/theme-next/theme-next-fancybox3 fancyboxps:注意fancybox和next/_config.uml里面的名字保持一致step2：更改next/_config.uml文件fancybox： true 2. 阅读次数ps: 仅限于博文详情页面显示阅读数，在首页不显示1234567891011step1更改next/_config.uml文件enable: true,如下：busuanzi_count: enable: true #false total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye post_views: true post_views_icon: eye 3. hexo s 顺便上传图片到七牛云服务器参考ps:这个插件感觉可添加也可不用添加，用到图片的时候自己上传到七牛服务器就好1234567891011121314151617181920212223242526272829303132333435363738394041424344454647step1:自己注册七牛服务器（目前笔者觉得够用了）step2:hexo主目录，下载插件npm install hexo-qiniu-sync --savestep3:配置next/_config.yml#七牛云存储设置##offline 是否离线. 离线状态将使用本地地址渲染##sync 是否同步##bucket 空间名称.##access_key 上传密钥AccessKey##secret_key 上传密钥SecretKey##secret_file 秘钥文件路径，可以将上述两个属性配置到文件内，防止泄露，json格式。绝对路径相对路径均可##dirPrefix 上传的资源子目录前缀.如设置，需与urlPrefix同步 ##urlPrefix 外链前缀.##up_host 上传服务器路径,如选择华北区域的话配置为http://up-z1.qiniu.com##local_dir 本地目录.##update_exist 是否更新已经上传过的文件(仅文件大小不同或在上次上传后进行更新的才会重新上传)##image/js/css 子参数folder为不同静态资源种类的目录名称，一般不需要改动##image.extend 这是个特殊参数，用于生成缩略图或加水印等操作。具体请参考http://developer.qiniu.com/docs/v6/api/reference/fop/image/ ## 可使用基本图片处理、高级图片处理、图片水印处理这3个接口。例如 ?imageView2/2/w/500 即生成宽度最多500px的缩略图qiniu: offline: false sync: true bucket: bucket_name secret_file: sec/qn.json or C: access_key: AccessKey secret_key: SecretKey dirPrefix: static urlPrefix: http://bucket_name.qiniudn.com/static up_host: http://upload.qiniu.com local_dir: static update_exist: true image: folder: images extend: js: folder: js css: folder: css step4:在hexo目录下,运行一下hexo s，图片直接上传到七牛云存储上去了 注意:备份发布系统代码不会上传hexo-qiniu-sync，不过在重新下载了部署系统，则直接运行npm install hexo —save就好,不需要再次执行 npm install hexo-qiniu-sync --save 因为在第一次下载的时候已经在配置文件记录了 4. 畅言评论插件集成参考功能：博客下面进行各种登陆评论，首页及详情页顶部评论量显示 4.1.畅言集成步骤1234567step1：注册畅言:http://changyan.kuaizhan.com/获取畅言评论的APP ID 和APP KEYICP备案：自己有最好,网上随便找一个step2：集成就不详叙，直接参考：https://www.jianshu.com/p/5888bd91d070 遇到的坑 ：a. 显示不全 解决办法：更改next/layout/_partials/comments.swig代码原来的代码： 34行处1234&lt;div class=&quot;comments&quot; id=&quot;comments&quot;&gt; &lt;/style&gt; &lt;div id=&quot;SOHUCS&quot;&gt;&lt;/div&gt; &lt;/div&gt; 改完后的代码：12345678&lt;div class=&quot;comments&quot; id=&quot;comments&quot;&gt; &lt;style&gt; #comments &#123; transform: none !important; &#125; &lt;/style&gt; &lt;div id=&quot;SOHUCS&quot;&gt;&lt;/div&gt; &lt;/div&gt; b. 首页显示评论出现问题参考解法 解决办法：next/layout/_mavro/post.swig:175～178行123&lt;a href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;#SOHUCS&quot; itemprop=&quot;discussionUrl&quot;&gt; &lt;span id=&quot;url::&#123;&#123; post.permalink &#125;&#125;&quot; class=&quot;cy_cmt_count&quot; data-xid=&quot;&#123;&#123; post.path &#125;&#125;&quot; itemprop=&quot;commentsCount&quot; &gt;&lt;/span&gt; &lt;/a&gt; 将post.permalink这个值包一层encodeURI方法1&lt;span id=&quot;url::&#123;&#123; encodeURI(post.permalink) &#125;&#125;&quot; class=&quot;cy_cmt_count&quot; data-xid=&quot;&#123;&#123; post.path &#125;&#125;&quot; itemprop=&quot;commentsCount&quot; &gt;&lt;/span&gt; 4.2. 我为什么最终选畅言而不其他评论插件，其他评论插件我都集成过？（ps:下面的言论不代表其余的评论插件做的不行，很可能是我的集成姿势不对） 先说说我集成评论系统的要求：登陆评论方便、首页/详情页评论数显示正确 4.2.1. gitment集成参考: id获取问题导致如果同时发布两篇文章，两篇文章下显示的评论都是两篇文章的总合Error：validation failed 解决办法如下 12345678910111213文件:themes\next\layout_third-party\comments\gitments.swig替换 id: window.location.pathname,方法一：id: &apos;&#123;&#123; page.date &#125;&#125;’,方法二：id: (window.location.pathname.length &lt; 50) ? window.location.pathname : &apos;&lt;%= page.date %&gt;&apos;,function renderGitment()&#123; var gitment = new &#123;&#123;CommentsClass&#125;&#125;(&#123; id: window.location.pathname, owner: &apos;&#123;&#123; theme.gitment.github_user &#125;&#125;&apos;, repo: &apos;&#123;&#123; theme.gitment.github_repo &#125;&#125;&apos;, &#123;% if theme.gitment.mint %&#125; lang: &quot;&#123;&#123; theme.gitment.language &#125;&#125;&quot; || navigator.language || navigator.systemLanguage || navigator.userLanguage, &#123;% endif %&#125; 4.2.2. 来必得集成参考插件集成最简单，但是因为是韩国的所以加载比较慢，首页没有评论数量显示所以没用。 4.2.3. valine集成参考集成也挺简单，但是评论的时候让用户直接选择留下联系方式，然后没有首页显示评论数量所以没用，且评论管理不知道在哪里管理； 5. 本地搜索功能local_search 方法一：推荐官方教程12345678910111213141516Step1: cd 到博客根目录npm install hexo-generator-searchdb --saveStep2:根目录/_config.yml 文件下添加下面代码search: path: search.xml field: post format: html limit: 10000 Step3:next/_config.yml 文件下更改以下代码:改false为truelocal_search: enable: true #false 方法二：民间教程123456789101112131415161718192021222324step1： 安装插件插件管理方法一：自己管理cd next/source/libgit clone https://github.com/theme-next/hexo-generator-searchdb.git local_search ps:local_search名字和里面对应方法二：直接让npm给你管理插件-- 推荐npm install hexo-generator-searchdb --saveStep2your root _config.yml 添加：search: path: search.xml field: post format: html limit: 10000 step3/next/_config.yml 改local_search为truelocal_search: enable: true 6. 文字数量和阅读时长1234567891011121314151617Step1npm install hexo-symbols-count-time --save Step2your root _config.ymlsymbols_count_time: symbols: true time: true total_symbols: true total_time: true /next/_config.yml 不用动 7. 开启RRS订阅ps:Next主题默认就支持插件git 参考链接123456789101112131415161718Step1cd博客根目录安装 RSS 插件npm install hexo-generator-feed --saveStep2开启网站 RSS 支持编辑网站根目录下的 _config.yml，添加以下代码开启# RSS订阅feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: &apos; &apos;]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS Developer Skills Matrix]]></title>
    <url>%2F2018%2F08%2F06%2FiOS%20Developer%20Skills%20Matrix%2F</url>
    <content type="text"><![CDATA[一线开发者应该定时整理下自己应该掌握哪些技能树，并思考如何规划以后横向或纵向的学习路线，以为下鄙人在学习过程中发现库iOS-Developer-Roadmap，感觉挺有价值所以用进行记录并翻译技能树。 PS:iOS-Developer-Roadmap项目发现的地方为Chrome的一个推荐Github项目插件 GitHunt Dark（寻找最受欢迎的GitHub项目） BohdanOrlov的Github库iOS-Developer-Roadmap上技能树翻译[原技能树图谱][翻译图谱] Junior Middle Senior 能力 Json做新闻类App 能够及时设计和交付快速可靠的聊天模块 可以用非狂热的想法建立团队行为标准 代码集成 使用git来移动代码 对GitFlow发表了看法 有想法如何建立CI过程和自动化 范式 有面向对象（OOP）的思想 能够处理比较难的FRP（响应式编程） 从其他平台和范例中获取价值 依赖 知道使用CocoaPods 知道使用苹果的包管理器 Swift Package Manager(SPM)，但是Carthage 也是一个选项 知道减少和拥有依赖关系的重要性 平台 会使用 Array/Dictionay/Set 道值/引用类型和Equatable / Hashable 知道swift和Objc-C的方法调度的细节 客户服务器协议 从互联网上获取JSON是件小事 进行基于WebSocket的实时聊天是可行的 建立视频聊天是一项可以实现的挑战 参考 使用StackOverFlow作为单一的事实来源 经常使用官方文档 询问平台开发人员并可以进行逆向工程 内存 知道如何避免和修复内存泄漏 知道NSPointterArray以及结构增加二进制的原因 有一个减少内存不足崩溃的策略 UI 可以在Interface Builder中构建基本UI 可以在代码中创建UI 可以对非主线程进行布局和差异计算 多线程 asyncAfter是朋友@synchronize所有的东西 asyncAfter是敌人，线程同步是个问题 理解多线程多余死锁 态度 期望他人在开发过程中进行教学和指导 与团队讨论设计以分享决策 负责设计决策的队友 设计模式 理解代理、target-action、mvc 精通Observe，Facade和Mediator模式 知道依赖注入和服务定位器之间的最佳位置 产品质量 如果应用程序在我的手机上运行，则会对其进测试 编写单元测试并尝试TDD和UI测试 定义了具有非重叠覆盖区域的可维护测试金字塔 部分学习参考知识点： 1、 Equatable / Hashable 2、 NSPointerArray、NSHashTable、NSMapTable[参考链接1) ][参考链接2] : 添加一个对象集合,但不想集合创建一个强引用 3、 Facade(iOS外观设计模式) 4、 Mediator中介者模式 4.1. 目前用到casatwy的CTMediator]用来进行路由设计，主要思想是动态进行方法调用：12345NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:methodSig];[invocation setArgument:&amp;params atIndex:2];[invocation setSelector:action];[invocation setTarget:target];[invocation invoke]; 4.2. 参考链接： !!!iOS应用架构谈 组件化方案 - 重点学习 iOS组件化实践方案－LDBusMediator炼就 iOS设计模式-中介者 Target-Action 实现组件解耦 —— CTMediator使用教程]]></content>
      <categories>
        <category>iOS学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈 ReactiveCocoa 之 MVVM]]></title>
    <url>%2F2017%2F10%2F24%2F%E6%B5%85%E8%B0%88%20ReactiveCocoa%20%E4%B9%8B%20MVVM%2F</url>
    <content type="text"><![CDATA[简介 ： ReactiveCocoa(简称：RAC)为一个开源函数响应式编程框架； 使用场景：通过RAC可以更加方便编程进行MVVM设计模式编程； 核心机制为信号（信号流）。 Demo地址 由于Swift和OC版本存在的差异性比较大，维护团队直接给拆了一下： Swift版本（ReactiveSwift）和 OC版本（ReactiveCocoa） 写该篇文章的初衷： 如何使用RAC 和 如何借助RAC来逐步实现MVC到MVVM的迁移。 一、ReactiveCocoa初见 1、编程思想ReactiveCocoa是函数式编程（Functional Programming）和响应式编程（Reactive Programming）集大成者； 2、实现关键： 2.1. 每个方法必须有返回值（本身对象）2.2. 把函数或者Block当做参数, block参数（需要操作的值）block返回值（操作结果）； 3、ReactiveCocoa初见 0、如何集成就略了（直接拉入项目或者CocoaPods） 1、 RACSiganl 最基本的信号类，默认为冷信号，表示当数据改变时，信号内部会发出数据，只有订阅了（subscribeNext）才会进被触发(编程热信号)，代码演示如下： 123456789101112131415// 1.创建信号RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; // 3、发送信号信号 NSLog(@&quot;信号被订阅 发送信号&quot;); // 4、执行了这一步 订阅信号才会发触发 [subscriber sendNext:@&quot;heheh&quot;]; return nil; &#125;]; // 2.订阅信号 ---必须为订阅 [signal subscribeNext:^(id _Nullable x) &#123; // 发送信号的内容 NSLog(@&quot;====%@&quot;, x); &#125;]; 2、RACSubscriber 订阅者，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。(示例也如上所示) 3、RACDisposable : 用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。使用场景:不想监听某个信号时，可以通过它主动取消订阅信号 代码演示如下： 1234567891011121314151617181920// 1.创建RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; // 3、发送信号信号 NSLog(@&quot;信号被订阅 发送信号&quot;); [subscriber sendNext:@&quot;heheh&quot;]; return [RACDisposable disposableWithBlock:^&#123; // 只要信号取消就会来这里 // 默认一个信号发送数据完毕就会主动取消订阅 NSLog(@&quot;信号被取消了&quot;); &#125;]; &#125;]; // 2.订阅信号 ---必须为订阅 RACDisposable *disposable = [signal subscribeNext:^(id _Nullable x) &#123; // 发送信号的内容 NSLog(@&quot;====%@&quot;, x); &#125;]; // 3.取消订阅 [disposable dispose]; 4、RACSubject 4.1. RACSubject:信号提供者，自己可以充当信号，又能发送信号。4.2. 用场景:通常用来代替代理，有了它，就不必要定义代理了。 5、RACTuple 元组类,类似NSArray,用来包装值. 123RACTuple *tuple = [RACTuple tupleWithObjectsFromArray:@[@&quot;hello111&quot;, @&quot;hello222&quot;,@&quot;hello333&quot;]]; NSLog(@&quot;%@&quot;, [tuple objectAtIndex:0]); 6、RACSequence 6.1、RAC中的集合类，用于代替NSArray,NSDictionary,可以使用它来快速遍历数组和字典。 12345678910111213141516171819202122232425262728291、RACSequence代替数组- (void)testRACSequenceArr&#123; NSArray * arr = @[@&quot;123&quot;, @&quot;asdfas&quot;, @1]; // 订阅集合信号，内部会自动便利所有的元素发出来 [arr.rac_sequence.signal subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;%@&quot;, x); &#125;];&#125;2、RACSequence代替字典- (void)testRACSequenceDict&#123; NSDictionary *dict = @&#123; @&quot;name&quot; : @&quot;张三&quot;, @&quot;age&quot; : @22&#125;; [dict.rac_sequence.signal subscribeNext:^(RACTuple * _Nullable x) &#123; // 方法一、 // NSLog(@&quot;%@ %@&quot;, x[0], x[1]); // 方法二、 // 用来解析元组， 宏里面的参数，传需要解析出来的变量名 // = 右边，放需要解析的元组 RACTupleUnpack(NSString *key, NSString *value) = x; NSLog(@&quot;%@ %@&quot;, key, value ); &#125;]; &#125; 7、RACCommand 7.1、直译为命令，只是一个继承自 NSObject 的类，但是它却可以用来创建和订阅用于响应某些事件的信号。7.2、相对而言比较复杂7.3、使用场景：网络请求（MVVM设计模式中网络模块）7.4、在默认情况下 RACCommand 都是不支持并发操作的，需要在上一次命令执行之后才可以发送下一次操作，如果直接execute:两次，最终也只会执行第一个execute：； 所以谨记 在使用应用中推荐一个网络请求对应一个command； 1234567891011121314151617181920212223242526简单使用 - 用于网络请求- (void)RACCommandSimpleUse&#123; RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(NSNumber * _Nullable input) &#123; return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:input]; // 每次sendNext 记得sendCompleted [subscriber sendCompleted]; return nil; &#125;]; &#125;]; [[command.executionSignals switchToLatest] subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;%@&quot;, x); &#125;]; // 在默认情况下 RACCommand 都是不支持并发操作的，需要在上一次命令执行之后才可以发送下一次操作，如果直接execute:两次，最终也只会执行第一个execute： // 所以谨记: 一个command对应一个网络请求 [command execute:@&quot;网络请求1&quot;]; // [command execute:@&quot;网络请求2&quot;]; [RACScheduler.mainThreadScheduler afterDelay:0.5 schedule:^&#123; [command execute:@&quot;网络请求2&quot;]; &#125;];&#125; 8、RACMulticastConnection 8.1、直译为多播连接;8.2、存在的问题普通的信号在执行sendNext:的时候，都会重新再执行以下信号的创建，当你想在一个请求完成后 进行分多级刷新UI 或者 做一些别的操作，如果直接用普通的信号进行sendNext：时候，则会进行多次网络请求操作；8.3、项目中使用到的场景比较少； 1234567891011121314151617181920212223242526272829303132333435-(void)RACMulticastConnectionUse&#123; // 1、通过信号创建链接 RACMulticastConnection *connection = [[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; NSLog(@&quot;完毕&quot;); [subscriber sendNext:@&quot;Send Request&quot;]; // 每次sendNext 记得sendCompleted // [subscriber sendCompleted]; return nil; &#125;] publish]; // 订阅信号（通过链接转换的信号）一次 [connection.signal subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;一次 x : %@&quot;, x); &#125;]; // 订阅信号（通过链接转换的信号）二次 [connection.signal subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;二次 x : %@&quot;, x); &#125;]; [connection connect]; // 且只有第一次连接才会有效果 // [connection.signal subscribeNext:^(id _Nullable x) &#123; // NSLog(@&quot;重新连接第一次 x : %@&quot;, x); // &#125;]; // [connection.signal subscribeNext:^(id _Nullable x) &#123; // NSLog(@&quot;重新连接第二次 x : %@&quot;, x); // &#125;]; // [connection connect];&#125; 二、ReactiveCocoa使用场景 1、代替代理 1、对象持有signal， 推荐用这种 1234567Code eg.:- (void)useRACInstandDelegate&#123; [self.redView.btnClickSignal subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;%@&quot;, x); &#125;];&#125; 2、使用rac_signalForSelector来进行方方法的执行，类似于系统自带方法performSelector:withObject:，不推荐(硬编码 和 警告)； 12345678Code eg.:- (void)useRACInstandDelegate2&#123; [[self.redView rac_signalForSelector:@selector(btnClick:)] subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;红色view上面的按钮点击了&quot;); &#125;];&#125; 2、代替KVO： 123456789101112131415161718- (void)insteadKVO&#123; // 需手动导入：#import &quot;NSObject+RACKVOWrapper.h&quot; // 1.代替KVO 方法一 [self.redView rac_observeKeyPath:@&quot;frame&quot; options:NSKeyValueObservingOptionNew observer:nil block:^(id value, NSDictionary *change, BOOL causedByDealloc, BOOL affectedOnlyLastComponent) &#123; // &#125;]; // 2.替代KVO 方法二 [[self.redView rac_valuesForKeyPath:@&quot;frame&quot; observer:nil] subscribeNext:^(id _Nullable x) &#123; // 打印的是NSRect NSLog(@&quot;%@&quot;, x); &#125;]; 3、监听按钮的点击事件： 12345678- (void)monitorBtnClick&#123; UIButton *btn; [[btn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl * _Nullable x) &#123; &#125;];&#125; 4、代替通知： 12345678- (void)insteadNotification&#123; [[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardWillShowNotification object:nil] subscribeNext:^(NSNotification * _Nullable x) &#123; &#125;];&#125; 5、监听文本框文案： 1234567- (void)insteadTextInput&#123; UITextField *textField; [textField.rac_textSignal subscribeNext:^(NSString * _Nullable x) &#123; // 监听到文本的改变 &#125;];&#125; 6、处理当界面有多次请求时，需要都获取到数据时，才能展示界面 1234567891011121314151617181920212223242526272829303132333435- (void)multiRequestData&#123; RACSignal *signal1 = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; NSLog(@&quot;发送木块一的数据&quot;); [subscriber sendNext:@&quot;发送木块一的数据&quot;]; return nil; &#125;]; RACSignal *signal2 = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; NSLog(@&quot;发送模块二的数据&quot;); [subscriber sendNext:@&quot;发送模块二的数据&quot;]; return nil; &#125;]; // 数组：存放信号 // 当数组中的所有信号都发送完成的时候，才会执行Selector // 方法的参数： 必须跟数组一一对应 // 方法的参数：就是每一个信号发送的数据 [self rac_liftSelector:@selector(updateUIFirstPartData:secondPartData:) withSignalsFromArray:@[signal1, signal2]];&#125;- (void)updateUIFirstPartData:(NSString *)firstPartData secondPartData:(NSString *)secondPartData&#123; NSLog(@&quot;更新 UI%@ %@&quot;,firstPartData , secondPartData);&#125; 三、浅谈MVVM 简介：MVVM,个人理解他就是MVC的升级版，解耦版，它是一种双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然； MVVM设计模式并不一定要借助RAC来实现，但若使用RAC来实现会更加的简单(因为所有的操作和响应都通过信号来完成对接)；M : 最基本的模型数据V : 视图 / 控制器VM : 处理业务的逻辑（eg:操作事件、数据请求等） 1.项目目录结构的体现（给你一种既视感😆）： Module├── Controllers├── Views├── Models└── VM 2.具体的实操（由于比较简单的实现，model数据就放在VM里面） 2.1. V(控制器或者视图)里面的写法： 提前对数据进行绑定 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748备注： LoginVc.m 文件， LoginVc.h文件可忽略#import &quot;LoginVc.h&quot;#import &quot;LogingVM.h&quot;@interface LoginVc ()@property (weak, nonatomic) IBOutlet UITextField *userNameTF;@property (weak, nonatomic) IBOutlet UITextField *pwdTF;@property (weak, nonatomic) IBOutlet UIButton *LoginBtn;@property (nonatomic, strong) LogingVM *loginVM;@end@implementation LoginVc- (void)viewDidLoad &#123; [super viewDidLoad]; [self initRac]; &#125;- (void)initRac&#123; // 1. 绑定信号 RAC(self.loginVM, account) = self.userNameTF.rac_textSignal; RAC(self.loginVM, pwd) = self.pwdTF.rac_textSignal; // 2. 登陆按钮能否点击 RAC(_LoginBtn,enabled) = self.loginVM.loginEnableSiganl; // 3. 监听登录按钮点击 [[_LoginBtn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) &#123; // 处理登录事件 =&gt; 发送登陆请求 [self.loginVM.loginCommand execute:nil]; &#125;];&#125;- (LogingVM *)loginVM&#123; if (!_loginVM) &#123; _loginVM = [[LogingVM alloc] init]; &#125; return _loginVM;&#125;@end 2.2. VM （数据的交互），由于比较简单直接把model放到了VM里面了, 一些数据的逻辑处理， 按钮是否可点击，网络是否要请求等； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879头文件：LogingVM.h#import &lt;Foundation/Foundation.h&gt;@interface LogingVM : NSObject@property (nonatomic, strong) NSString *account;@property (nonatomic, strong) NSString *pwd;@property (nonatomic, strong, readonly) RACSignal *loginEnableSiganl; /**&lt; 处理登录按钮是否允许点击 */@property (nonatomic, strong, readonly) RACCommand *loginCommand;/** 登录按钮命令 */@end实现文件： LogingVM.m#import &quot;LogingVM.h&quot;@implementation LogingVM- (instancetype)init&#123; if (self = [super init]) &#123; [self setUp]; &#125; return self;&#125;// 初始化操作- (void)setUp&#123; // 1.登录按钮是否能点击 的信号 _loginEnableSiganl = [RACSignal combineLatest:@[RACObserve(self, account), RACObserve(self, pwd)] reduce:^id(NSString *account,NSString *pwd)&#123; return @(account.length &amp;&amp; pwd.length); &#125;]; // 2.登录点击 信号 _loginCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123; return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; // 发送数据 [subscriber sendNext:@&quot;请求登录的数据&quot;]; [subscriber sendCompleted]; &#125;); return nil; &#125;]; &#125;]; // 3.处理登录请求返回的结果 [_loginCommand.executionSignals.switchToLatest subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;]; // 4.处理登录执行过程 [[_loginCommand.executing skip:1] subscribeNext:^(id x) &#123; if ([x boolValue] == YES) &#123; NSLog(@&quot;登陆成功&quot;); &#125;else&#123; NSLog(@&quot;登陆时报&quot;); &#125; &#125;];&#125;@end 3、 通过上面的登陆示例，可以感受到RAC在MVVM的便捷性，可测试性（VM）都有一定的提高。 4、如果项目把设计模式由MVC迁移为MVVM，可以分步走，可以理解MVVM是升级版的MVC， 其实就是把以前放在VC 里面处理的逻辑有条理的放到VM里面，Code可测性变高。]]></content>
      <categories>
        <category>iOS学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARKit解读]]></title>
    <url>%2F2017%2F06%2F07%2FARKit%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[官网地址 一、了解： ARSession ： 管理设备相机和增强现实体验所需的运动处理的共享对象。 二、配置： ARSessionConfiguration： 仅跟踪设备方向的基本配置。 ARWorldTrackingSessionConfiguration : 跟踪设备的方向和位置以及检测设备相机所看到的实际表面的配置。 三、标准视图： 建立基本的AR经验 （配置AR会话，并使用SceneKit或SpriteKit显示AR内容。） ARSKView ：用于显示使用2D SpriteKit内容增强相机视图的AR体验的视图。 ARSCNView :用于显示使用3D SceneKit内容增强相机视图的AR体验的视图。 四、自定义视图： 用Metal显示AR体验 通过渲染相机图像和使用位置跟踪信息来显示叠加内容来构建自定义AR视图。 五、现实世界的对象和位置 ARAnchor : 可用于将对象放置在AR场景中的现实世界的位置和方向。 ARPlaneAnchor : 有关AR会话中检测到的真实平面的位置和方向的信息。 ARHitTestResult : 通过检查AR会话的设备摄像头视图中的一个点找到有关现实世界表面的信息。 六、相机和场景细节 ARFrame : 作为AR会话的一部分捕获的视频图像和位置跟踪信息。 ARCamera : 有关AR会话中捕获的视频帧的摄像机位置和成像特性的信息。 ARLightEstimate : 与AR会话中捕获的视频帧相关联的估计场景照明信息。]]></content>
      <categories>
        <category>iOS学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尼康D5200的使用]]></title>
    <url>%2F2016%2F09%2F05%2F%E5%B0%BC%E5%BA%B7D5200%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[蚂蚁摄影视屏教程 1、镜头和机身主要按键介绍： 1.1、镜头和机身上的按键的熟悉 1.2、新手应该了解的知识：光圈、快门、感光度 1.3、机身和镜头的拆卸和组装（咔的一声） 1.4、VR:光学防抖（一般开启） 1.5、A/M 自动或者手动（一般设置为A） 1.6、镜头锁（有些有有些没有，旋转至18的时候开启了锁，这个锁是便于携带） 1.7、fn 自定义设定；（设置为感光ISO） menu-&gt;自定义菜单-&gt;f控制 -&gt; 指定fn控制 —&gt; 然后选择（自己想要的选项：ISO感光度） 调节的时候 长按 fn + 滚动轮 1.8、闪电符号： 闪光灯 1.9、对焦辅助灯 2.0、开关机拨杆 / 快门键 2.1、红点：录像 2.2、右边曝光补偿键（光圈的标识：调节光圈大小 + / — ） 2.3、info ： 屏幕的开关机键 2.4、单张拍摄、连拍、自拍 2.5、显示屏取景和取景器取景 （LV方向：显示屏取景 再按下info键则显示一些信息） 反之切换 2.6、顶部转盘-&gt;模式转盘：（顺时针方向命名） P ： 程序自动模式 S ：快门优先 （佳能上叫tv） A : 光圈优先模式 M: 全手动模式 AUTO:全自动 闪光灯关闭 SCENE 场景模式 （夜景、室内、海滩等11种场景模式） 人像模式 风景模式 儿童照模式 运动模式 小花：微距模式 EFFECTS: 滤镜特效模式（模型效果、剪影等一些特俗的效果） 2.7、取景器 2.8、显示屏 2.9、I 键 ： 尼康相机设置参数通用按钮键 ，操作方式：I —&gt; 上下左右键 —&gt;OK —&gt; 需要选择的项目 —&gt; OK确定 3.0、拨盘：调节参数 3.1、相册 3.2、上下左右 / 确认 键 （看照片的时候： 左右键切换、上下键可以显示更多的信息） 3.3、放大 和 缩小 ： 查看照片 放大 （缩小：帮助菜单键，选择某个选项的时候，按下缩小键 会出现更多信息便于我们理解，灯光较 暗的时候，左下角会出现一个 ？在一直闪烁，这时候按 缩小键 则会提示你打开闪光灯进行补光 ） 3.4、menu键：一些设置 光圈 D5200 是39点对焦 曝光指示表（0的找出来的照片： 左边暗、右边亮） 屏幕指示意义： 2、闪光灯：较暗就开灯3、变焦： 旋转变焦环（调成显示屏取景、或者取景器取景）4、连拍/自拍（抓拍： 按下上面的连拍按钮（高速：5 ；低速：3）； 自拍：10秒延时自拍）5、视频录制：可以录制 全高清视频（先切换为显示屏取景正在录制，且上面的意义：录制模式：全高清）新手用A ： 光圈优先6、光圈（用来控制进光大小）： 大光圈： 人物 （视角窄）； 小光圈：大场景，适合拍风景（视角大）； 中间光圈调整： 按住 上面的曝光补偿 + 转动拨盘 就可以调整了 （往右边转：F后面年数字越大，光圈越小； 左边:F后面数字越来越小，光圈越来越大）7、快门：控制进光时间 （S 和 M 模式下才可以调节）仅仅拨动拨盘就能调整: 左慢右快 高速快门：抓拍小宝宝 和运动员的 精彩瞬间 慢速快门：记录汽车尾灯拉丝 和 星空流星轨迹效果8、感光度ISO：对光线的敏感度，P S M A 模式下都可以调整（可以设置快捷键，或者按 I键进行） 感光度越低 画面越整体越暗 画质越清楚（在光线充足的情况下，推荐尽量使用低感光ISO白天推荐使用100就好；） 感光度越高 画面整体越亮 但是噪点高，画质会更粗糙） 9、对焦方式： P S A M模式下可以调整 对焦方式 : 4 种 AF - A : 自动伺服对焦 （动静对焦方式的自动切换） AF - S ：单次伺服对焦（适合拍摄静止的物体） AF - C ：连续伺服对焦 （适合拍摄动态的物体） 马拉松赛事 MF : 手动对焦 对焦区域：选择 派人物 拍眼睛 ，人更加有神， 在对焦区域模式里面选择 单点对焦 —&gt; 通过上下左右键 从39个对焦点钟任意选择一个对焦点 对焦区域： 推荐使用39点对焦 + 连续对焦 ===&gt; 更好的抓拍 10、测光模式：（P S A M模式下都可以调节） M 如何操作： I 键 —&gt; 测光模式 —&gt; OK —&gt; 测光模式的选择界面 矩阵测光、中央重点测光、点测光 曝光准确的照片：避免曝光不足太暗、 曝光太足引起抓拍太亮 风景和合影， 平价测光 逆光中的人物 推荐 使用 点测光 把 需要 拍摄的物体放在中间的时候 就需要 中央重点测光 优雅的拍照姿势：1、 双脚与双肩齐平；2、蹲着：单膝跪地，用后胳膊肘放腿上；3、依靠： 三角形具有稳定性； 保养：清洁镜头 ： 用拭擦布向一个方向拭擦换镜头： 需要 向下 换 防止灰尘]]></content>
      <categories>
        <category>爱好</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发成长之道]]></title>
    <url>%2F2015%2F12%2F28%2FiOS%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[1、创作（写有深度的博客、仿制优秀的项目、随时记录理解）； 2、做有难度的项目； 3、“不用则废”不只是针对技能，还针对理解； 4、尽量少抱大腿,或者压根就别抱大腿； 5、多读源码(用五柳先生的话就是,不求甚解. 但是读源码也不能盲目的看,最好是看和最近的工作相关的)； 6、多读国外的iOS开发网站和blog：Raywenderlich 和 nshipster 还有 objc.io 7、要孜孜不倦的学习： （学习第二门开发语言：推荐python）；]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>个人成长</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Flutter-BLoC-第三讲</title>
      <link href="/2019/04/03/Flutter-BLoC-%E7%AC%AC%E4%B8%89%E8%AE%B2/"/>
      <url>/2019/04/03/Flutter-BLoC-%E7%AC%AC%E4%B8%89%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<p>本文为 <strong>《Flutter Bloc Package》</strong> 的译文，<a href="https://medium.com/flutter-community/flutter-bloc-package-295b53e95c5c" target="_blank" rel="noopener">原文地址</a>，若转载本译文请注明出处。</p><p><img src="https://upload-images.jianshu.io/upload_images/699599-2cea67aa88470b50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在使用Flutter工作一段时间之后，我决定创建一个软件包以帮助我经常使用的东西：BLoC模式。<br>对于那些不熟悉BLoC模式的人来说，它是一种设计模式，有助于将表示层与业务逻辑分开。你在<a href="https://www.youtube.com/watch?v=fahC3ky_zW0" target="_blank" rel="noopener">这里</a>了解更多。</p><p>使用BLoC模式可能具有挑战性,因为需要建立对Streams和Reactive Programming的理解。但它的核心是BLoC非常简单：</p><blockquote><p>BLoC 将event流作为输入，并将它们转换为state流作为输出。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/699599-b832fb70d262434e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>我们现在可以在<a href="https://pub.dartlang.org/packages/bloc" target="_blank" rel="noopener">bloc的dart包</a>的帮助下使用这种强大的设计模式。</p><p>该软件包抽象了模式的反应方面，允许开发人员专注于将事件(event)转换为状态(state)。</p><p>让我们从定义这些术语开始……</p><h3 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h3><h4 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h4><p><strong>Events</strong> 是Bloc的输入。它们通常是UI事件，例如按钮按下。Events被分发(dispatched)并且被转换为States。</p><h4 id="States"><a href="#States" class="headerlink" title="States"></a>States</h4><p><strong>States</strong> 是Bloc的输出。表示组件可以监听状态流 并根据给定状态重绘其自身的部分（BlocBuilder有关详细信息，请参阅参考资料）。</p><h4 id="Transitions"><a href="#Transitions" class="headerlink" title="Transitions"></a>Transitions</h4><p><strong>Transitions</strong> 发生在 调用mapEventToState之后 但在更新了bloc的state之前 调度了一个Event</p><p>现在我们了解事件和状态，我们可以看一下Bloc API。</p><h3 id="BLOC-API"><a href="#BLOC-API" class="headerlink" title="BLOC API"></a>BLOC API</h3><h4 id="mapEventToState"><a href="#mapEventToState" class="headerlink" title="mapEventToState"></a>mapEventToState</h4><blockquote><p>当一个类继承Bloc时，必须实现 mapEventToState 方法， 该函数将传入事件作为参数。<br>只要UI层触发一个事件，就会调用 mapEventToState。<br>mapEventToState 必须将该event转换为新state，并以UI层消耗的Stream形式返回新状态。</p></blockquote><h4 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h4><blockquote><p>dispatch 是一个 接受 event 并触发 mapEventToState 的方法。<br>可以从表示层调用dispatch 或 从Bloc内部（见例子）并通知Bloc一个新 event。</p></blockquote><h4 id="initialState"><a href="#initialState" class="headerlink" title="initialState"></a>initialState</h4><blockquote><p>initialState是处理任何事件之前的状态（在mapEventToState被调用之前）。<br>如果未实现，则为initialState null。</p></blockquote><h4 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h4><blockquote><p>transform是一个 在调用mapEventToState之前 可以重写以转换 Stream<event> .<br>这允许使用distinct() 和 debounce() 的操作。</event></p></blockquote><h4 id="onTransition"><a href="#onTransition" class="headerlink" title="onTransition"></a>onTransition</h4><blockquote><p>onTransition 是一个 每次 transform 发生时都可以重写以进行处理 的方法。<br>调度新event 并调用mapEventToState时发生transition。<br>onTransition 在更新 bloc 状态之前 被调用。<br><strong>这是添加特定于块的日志记录/分析的好地方</strong></p></blockquote><p>让我们创建一个counter bloc！</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> CounterEvent &#123; increment, decrement &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterBloc</span> <span class="keyword">extends</span> <span class="title">Bloc</span>&lt;<span class="title">CounterEvent</span>, <span class="title">int</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> initialState =&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Stream&lt;<span class="built_in">int</span>&gt; mapEventToState(CounterEvent event) <span class="keyword">async</span>* &#123;</span><br><span class="line">    <span class="keyword">switch</span> (event) &#123;</span><br><span class="line">      <span class="keyword">case</span> CounterEvent.decrement:</span><br><span class="line">        <span class="keyword">yield</span> currentState - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CounterEvent.increment:</span><br><span class="line">        <span class="keyword">yield</span> currentState + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建一个BLoC 需要作如下操作:</strong></p><blockquote><ul><li>定义所有 event 和 state</li><li>继承Bloc</li><li>重写 initialState 和 mapEventToState</li></ul></blockquote><p>在这种情况下，我们的 events 是CounterEvents ,states 是 integers</p><p>CounterBloc 转换 CounterEvents 为 integers。</p><p>我们可以通过 dispatch 来 通知CounterBloc 事件</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">final</span> counterBloc = CounterBloc();</span><br><span class="line"></span><br><span class="line">  counterBloc.dispatch(CounterEvent.increment);</span><br><span class="line">  counterBloc.dispatch(CounterEvent.decrement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了观察状state 的 转换（Transitions），我们可以重写onTransition。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> CounterEvent &#123; increment, decrement &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterBloc</span> <span class="keyword">extends</span> <span class="title">Bloc</span>&lt;<span class="title">CounterEvent</span>, <span class="title">int</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> initialState =&gt; <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> onTransition(Transition&lt;CounterEvent, <span class="built_in">int</span>&gt; transition) &#123;</span><br><span class="line">    <span class="built_in">print</span>(transition);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Stream&lt;<span class="built_in">int</span>&gt; mapEventToState(CounterEvent event) <span class="keyword">async</span>* &#123;</span><br><span class="line">    <span class="keyword">switch</span> (event) &#123;</span><br><span class="line">      <span class="keyword">case</span> CounterEvent.decrement:</span><br><span class="line">        <span class="keyword">yield</span> currentState - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CounterEvent.increment:</span><br><span class="line">        <span class="keyword">yield</span> currentState + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，每当发出(dispatch)一个CounterEvent我们的Bloc将响应一个新的integer状态，我们将看到一个transition被输出到控制台。</p><p>现在让我们使用Flutter构建一个UI，并使用flutter_bloc 包将UI连接到我们的CounterBloc。</p><h3 id="BlocBuilder"><a href="#BlocBuilder" class="headerlink" title="BlocBuilder"></a>BlocBuilder</h3><blockquote><p>BlocBuilder是一个Flutter小部件，它需要一个Bloc和一个构建器函数。<br>BlocBuilder处理构建窗口小部件以响应新state。<br>BlocBuilder与StreamBuilder非常相似，但它有一个更简单的API来减少所需的样板代码量。</p></blockquote><h3 id="BlocProvider"><a href="#BlocProvider" class="headerlink" title="BlocProvider"></a>BlocProvider</h3><blockquote><p>BlocProvider是一个Flutter小部件，它通过 BlocProvider.of(context)为其子女提供了一个bloc。<br>它用作依赖注入（DI）小部件, 这样一个bloc实例 可以被提供给子树中的多个小部件。</p></blockquote><p>现在让我们构建 counter App</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() =&gt; _AppState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AppState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">App</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> CounterBloc _counterBloc = CounterBloc();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter Demo'</span>,</span><br><span class="line">      home: BlocProvider&lt;CounterBloc&gt;(</span><br><span class="line">        bloc: _counterBloc,</span><br><span class="line">        child: CounterPage(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _counterBloc.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> CounterBloc _counterBloc = BlocProvider.of&lt;CounterBloc&gt;(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">'Counter'</span>)),</span><br><span class="line">      body: BlocBuilder&lt;CounterEvent, <span class="built_in">int</span>&gt;(</span><br><span class="line">        bloc: _counterBloc,</span><br><span class="line">        builder: (BuildContext context, <span class="built_in">int</span> count) &#123;</span><br><span class="line">          <span class="keyword">return</span> Center(</span><br><span class="line">            child: Text(</span><br><span class="line">              <span class="string">'<span class="subst">$count</span>'</span>,</span><br><span class="line">              style: TextStyle(fontSize: <span class="number">24.0</span>),</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: Column(</span><br><span class="line">        crossAxisAlignment: CrossAxisAlignment.end,</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.end,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Padding(</span><br><span class="line">            padding: EdgeInsets.symmetric(vertical: <span class="number">5.0</span>),</span><br><span class="line">            child: FloatingActionButton(</span><br><span class="line">              child: Icon(Icons.add),</span><br><span class="line">              onPressed: () &#123;</span><br><span class="line">                _counterBloc.dispatch(CounterEvent.increment);</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">          Padding(</span><br><span class="line">            padding: EdgeInsets.symmetric(vertical: <span class="number">5.0</span>),</span><br><span class="line">            child: FloatingActionButton(</span><br><span class="line">              child: Icon(Icons.remove),</span><br><span class="line">              onPressed: () &#123;</span><br><span class="line">                _counterBloc.dispatch(CounterEvent.decrement);</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该App小部件是StatefulWidget，负责创建和销毁 CounterBloc。<br>它让 CounterBloc 使用 BlocProvider 小部件可用于 CounterPage 小部件。</p><p>CounterPage小部件是StatelessWidget， 它使用BlocBuilder重建UI以响应CounterBloc的状态变化。</p><p>此时，我们已经成功地将我们的表示层与业务逻辑层分开。请注意，CounterPage窗口小部件对用户点击按钮时发生的情况一无所知。小部件只是告诉CounterBloc用户按下了递增或递减按钮。</p><p>有关更多示例和详细文档，请查看<a href="https://felangel.github.io/bloc/#/" target="_blank" rel="noopener">官方集团文档</a>。</p><p>相关链接：</p><p><a href="https://pub.dartlang.org/packages/bloc" target="_blank" rel="noopener">bloc dart包</a><br><a href="https://pub.dartlang.org/packages/flutter_bloc" target="_blank" rel="noopener">flutter_bloc包</a><br><a href="https://felangel.github.io/bloc/#/" target="_blank" rel="noopener">flutter_bloc使用官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter-BLoC-第二讲</title>
      <link href="/2019/03/14/Flutter-BLoC-%E7%AC%AC%E4%BA%8C%E8%AE%B2/"/>
      <url>/2019/03/14/Flutter-BLoC-%E7%AC%AC%E4%BA%8C%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<p><strong>[译文]Reactive Programming - Streams - BLoC实际用例</strong> <a href="https://www.didierboelens.com/2018/12/reactive-programming---streams---bloc---practical-use-cases/#4-form-validation" target="_blank" rel="noopener">原文</a></p><p>BLoC，Reactive Programming，Streams - 实际用例和有用模式。</p><p>[TOC]<br>注：此处的”toc”应显示为目录，但是简书不支持，显示不出来。</p><p><strong>介绍</strong></p><blockquote><p>在介绍了BLoC，Reactive Programming和Streams的概念后，我在一段时间之前做了一些介绍，尽管与我分享一些我经常使用并且个人觉得非常有用的模式（至少对我而言）可能会很有趣。这些模式使我在开发过程中节省了大量时间，并使我的代码更易于阅读和调试。</p></blockquote><p>我要谈的话题是：</p><blockquote><ul><li>1.BLoC Provider and InheritedWidget</li><li>2.在哪里初始化BLoC？</li><li>3.事件状态（允许根据事件响应状态转换）</li><li>4.表格验证（允许根据条目和验证控制表单的行为）</li><li>5.Part Of（允许Widget根据其在列表中的存在来调整其行为）</li></ul></blockquote><p>完整的源代码可以在<a href="https://github.com/boeledi/blocs" target="_blank" rel="noopener">GitHub</a>上找到。</p><h3 id="1-BLoC-Provider-and-InheritedWidget"><a href="#1-BLoC-Provider-and-InheritedWidget" class="headerlink" title="1.BLoC Provider and InheritedWidget"></a>1.BLoC Provider and InheritedWidget</h3><p>我借此文章的机会介绍我的BlocProvider的另一个版本，它现在依赖于一个InheritedWidget。</p><p>使用InheritedWidget的优点是我们获得了性能。</p><h4 id="1-1-之前的实现"><a href="#1-1-之前的实现" class="headerlink" title="1.1. 之前的实现"></a>1.1. 之前的实现</h4><p>我之前版本的BlocProvider实现为常规StatefulWidget，如下所示： </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BlocBase</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> dispose();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generic BLoC provider</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlocProvider</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">BlocBase</span>&gt; <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  BlocProvider(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.child,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.bloc,</span><br><span class="line">  &#125;): <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> T bloc;</span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _BlocProviderState&lt;T&gt; createState() =&gt; _BlocProviderState&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> T of&lt;T <span class="keyword">extends</span> BlocBase&gt;(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">final</span> type = _typeOf&lt;BlocProvider&lt;T&gt;&gt;();</span><br><span class="line">    BlocProvider&lt;T&gt; provider = context.ancestorWidgetOfExactType(type);</span><br><span class="line">    <span class="keyword">return</span> provider.bloc;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">Type</span> _typeOf&lt;T&gt;() =&gt; T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_BlocProviderState</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">BlocProvider</span>&lt;<span class="title">BlocBase</span>&gt;&gt;</span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    widget.bloc.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> widget.child;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我使用StatefulWidget从dispose（）方法中受益，以确保在不再需要时释放BLoC分配的资源。</p><p>这很好用但从性能角度来看并不是最佳的。</p><p>context.ancestorWidgetOfExactType()是一个为时间复杂度为O(n)的函数，为了检索某种类型的祖先，它将对widget树 做向上导航，从上下文开始，一次递增一个父，直到完成。如果从上下文到祖先的距离很小（即O(n)结果很少），则可以接受对此函数的调用，否则应该避免。这是这个函数的代码。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget ancestorWidgetOfExactType(<span class="built_in">Type</span> targetType) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_debugCheckStateIsActiveForAncestorLookup());</span><br><span class="line">    <span class="built_in">Element</span> ancestor = _parent;</span><br><span class="line">    <span class="keyword">while</span> (ancestor != <span class="keyword">null</span> &amp;&amp; ancestor.widget.runtimeType != targetType)</span><br><span class="line">        ancestor = ancestor._parent;</span><br><span class="line">    <span class="keyword">return</span> ancestor?.widget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-新的实现"><a href="#1-2-新的实现" class="headerlink" title="1.2. 新的实现"></a>1.2. 新的实现</h4><p>新实现依赖于StatefulWidget，并结合InheritedWidget： </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Type</span> _typeOf&lt;T&gt;() =&gt; T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BlocBase</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> dispose();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlocProvider</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">BlocBase</span>&gt; <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  BlocProvider(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.child,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.bloc,</span><br><span class="line">  &#125;): <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line">  <span class="keyword">final</span> T bloc;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _BlocProviderState&lt;T&gt; createState() =&gt; _BlocProviderState&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> T of&lt;T <span class="keyword">extends</span> BlocBase&gt;(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">final</span> type = _typeOf&lt;_BlocProviderInherited&lt;T&gt;&gt;();</span><br><span class="line">    _BlocProviderInherited&lt;T&gt; provider = </span><br><span class="line">            context.ancestorInheritedElementForWidgetOfExactType(type)?.widget;</span><br><span class="line">    <span class="keyword">return</span> provider?.bloc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_BlocProviderState</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">BlocBase</span>&gt; <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">BlocProvider</span>&lt;<span class="title">T</span>&gt;&gt;</span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    widget.bloc?.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> _BlocProviderInherited&lt;T&gt;(</span><br><span class="line">      bloc: widget.bloc,</span><br><span class="line">      child: widget.child,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_BlocProviderInherited</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line">  _BlocProviderInherited(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> Widget child,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.bloc,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> T bloc;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> updateShouldNotify(_BlocProviderInherited oldWidget) =&gt; <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点是这个解决方案是性能。</strong></p><p>由于使用了InheritedWidget，它现在可以调用context.ancestorInheritedElementForWidgetOfExactType()函数，它是一个O（1），这意味着祖先的检索是立即的，如其源代码所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">InheritedElement ancestorInheritedElementForWidgetOfExactType(<span class="built_in">Type</span> targetType) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_debugCheckStateIsActiveForAncestorLookup());</span><br><span class="line">    <span class="keyword">final</span> InheritedElement ancestor = _inheritedWidgets == <span class="keyword">null</span> </span><br><span class="line">                                    ? <span class="keyword">null</span> </span><br><span class="line">                                    : _inheritedWidgets[targetType];</span><br><span class="line">    <span class="keyword">return</span> ancestor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这来自于所有InheritedWidgets都由Framework记忆的事实。</p><blockquote><ul><li>为什么使用 ancestorInheritedElementForWidgetOfExactType ？</li><li>您可能已经注意到我使用 ancestorInheritedElementForWidgetOfExactType 方法而不是通常的 inheritFromWidgetOfExactType 。</li><li>原因是我不希望上下文调用的BlocProvider被注册为InheritedWidget的依赖项，因为我不需要它。</li></ul></blockquote><h4 id="1-3-如何使用新的BlocProvider？"><a href="#1-3-如何使用新的BlocProvider？" class="headerlink" title="1.3. 如何使用新的BlocProvider？"></a>1.3. 如何使用新的BlocProvider？</h4><h5 id="1-3-1-注入BLoC"><a href="#1-3-1-注入BLoC" class="headerlink" title="1.3.1.注入BLoC"></a>1.3.1.注入BLoC</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> BlocProvider&lt;MyBloc&gt;&#123;</span><br><span class="line">        bloc: myBloc,</span><br><span class="line">        child: ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-3-2-检索BLoC"><a href="#1-3-2-检索BLoC" class="headerlink" title="1.3.2. 检索BLoC"></a>1.3.2. 检索BLoC</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context)&#123;</span><br><span class="line">    MyBloc myBloc = BlocProvider.of&lt;MyBloc&gt;(context);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-在哪里初始化BLoC？"><a href="#2-在哪里初始化BLoC？" class="headerlink" title="2.在哪里初始化BLoC？"></a>2.在哪里初始化BLoC？</h3><p>要回答这个问题，您需要弄清楚其使用范围。</p><h4 id="2-1-应用程序中随处可用"><a href="#2-1-应用程序中随处可用" class="headerlink" title="2.1.应用程序中随处可用"></a>2.1.应用程序中随处可用</h4><p>假设您必须处理与用户身份验证/配置文件，用户首选项，购物篮相关的一些机制, 可从应用程序的任何可能部分(例如，从不同页面)获得获得BLoC(),存在两种方式使这个BLoC可访问。</p><h5 id="2-1-1-使用全局单例"><a href="#2-1-1-使用全局单例" class="headerlink" title="2.1.1.使用全局单例"></a>2.1.1.使用全局单例</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:rxdart/rxdart.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GlobalBloc</span> </span>&#123;</span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// 与此BLoC相关的流</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  BehaviorSubject&lt;<span class="built_in">String</span>&gt; _controller = BehaviorSubject&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">  <span class="built_in">Function</span>(<span class="built_in">String</span>) <span class="keyword">get</span> push =&gt; _controller.sink.add;</span><br><span class="line">  Stream&lt;<span class="built_in">String</span>&gt; <span class="keyword">get</span> stream =&gt; _controller;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Singleton工厂</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> GlobalBloc _bloc = <span class="keyword">new</span> GlobalBloc._internal();</span><br><span class="line">  <span class="keyword">factory</span> GlobalBloc()&#123;</span><br><span class="line">    <span class="keyword">return</span> _bloc;</span><br><span class="line">  &#125;</span><br><span class="line">  GlobalBloc._internal();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Resource disposal</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    _controller?.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GlobalBloc globalBloc = GlobalBloc();</span><br></pre></td></tr></table></figure><p>要使用此BLoC，您只需导入该类并直接调用其方法，如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'global_bloc.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    Widget build(BuildContext context)&#123;</span><br><span class="line">        globalBloc.push(<span class="string">'building MyWidget'</span>);</span><br><span class="line">        <span class="keyword">return</span> Container();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个可以接受的解决方案，如果你需要有一个BLoC是唯一的，需要从应用程序内的任意位置访问。 </p><blockquote><ul><li>这是非常容易使用;</li><li>它不依赖于任何BuildContext ;</li><li>没有必要通过任何BlocProvider去寻找 BLoC;</li><li>为了释放它的资源，只需确保将应用程序实现为StatefulWidget，并在应用程序Widget 的重写dispose（）方法中调用globalBloc.dispose（）</li></ul></blockquote><p>许多纯粹主义者反对这种解决方案。我不知道为什么，但是…所以让我们看看另一个…… </p><h5 id="2-1-2-把它放在一切之上"><a href="#2-1-2-把它放在一切之上" class="headerlink" title="2.1.2. 把它放在一切之上"></a>2.1.2. 把它放在一切之上</h5><p>在Flutter中，所有页面的祖先本身必须是MaterialApp的父级。这是由于这样的事实，一个页面（或路由）被包装在一个OverlayEntry，一个共同的孩子堆栈的所有页面。</p><blockquote><p>换句话说，每个页面都有一个Buildcontext，它独立于任何其他页面。这就解释了为什么在不使用任何技巧的情况下，2页（路线）不可能有任何共同点。</p></blockquote><p>因此，如果您需要在应用程序中的任何位置使用BLoC，则必须将其作为MaterialApp的父级，如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(Application());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> BlocProvider&lt;AuthenticationBloc&gt;(</span><br><span class="line">      bloc: AuthenticationBloc(),</span><br><span class="line">      child: MaterialApp(</span><br><span class="line">        title: <span class="string">'BLoC Samples'</span>,</span><br><span class="line">        theme: ThemeData(</span><br><span class="line">          primarySwatch: Colors.blue,</span><br><span class="line">        ),</span><br><span class="line">        home: InitializationPage(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-可用于子树"><a href="#2-2-可用于子树" class="headerlink" title="2.2.可用于子树"></a>2.2.可用于子树</h4><p>大多数情况下，您可能需要在应用程序的某些特定部分使用BLoC。</p><p>作为一个例子，我们可以想到的讨论主题，其中集团将用于</p><blockquote><ul><li>与服务器交互以检索，添加，更新帖子</li><li>列出要在特定页面中显示的线程</li><li>…</li></ul></blockquote><p>因此，如果您需要在应用程序中的任何位置使用BLoC，则必须将其作为MaterialApp的父级，如下所示： </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTree</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> BlocProvider&lt;MyBloc&gt;(</span><br><span class="line">      bloc: MyBloc(),</span><br><span class="line">      child: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          MyChildWidget(),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyChildWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span> </span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    MyBloc = BlocProvider.of&lt;MyBloc&gt;(context);</span><br><span class="line">    <span class="keyword">return</span> Container();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，所有widgets都可以通过对呼叫BlocProvider.of方法 访问BLoC</p><blockquote><p>附：<br>如上所示的解决方案并不是最佳解决方案，因为它将在每次重建时实例化BLoC。<br>后果：</p><ul><li>您将丢失任何现有的BLoC内容</li><li>它会耗费CPU时间，因为它需要在每次构建时实例化它。</li></ul></blockquote><p>一个更好的办法，在这种情况下，是使用StatefulWidget从它的持久受益国，具体如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTree</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line"> <span class="meta">@override</span></span><br><span class="line">  _MyTreeState createState() =&gt; _MyTreeState();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyTreeState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyTree</span>&gt;</span>&#123;</span><br><span class="line">  MyBloc bloc;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState()&#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    bloc = MyBloc();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    bloc?.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> BlocProvider&lt;MyBloc&gt;(</span><br><span class="line">      bloc: bloc,</span><br><span class="line">      child: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          MyChildWidget(),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这种方法，如果需要重建“ MyTree ”小部件，则不必重新实例化BLoC并直接重用现有实例。</p><h4 id="2-3-仅适用于一个小部件"><a href="#2-3-仅适用于一个小部件" class="headerlink" title="2.3.仅适用于一个小部件"></a>2.3.仅适用于一个小部件</h4><p>这涉及BLoC仅由一个 Widget使用的情况。</p><p>在这种情况下，可以在Widget中实例化BLoC。</p><h3 id="3-事件状态（允许根据事件响应状态转换）"><a href="#3-事件状态（允许根据事件响应状态转换）" class="headerlink" title="3.事件状态（允许根据事件响应状态转换）"></a>3.事件状态（允许根据事件响应状态转换）</h3><p>有时，处理一系列可能是顺序或并行，长或短，同步或异步以及可能导致各种结果的活动可能变得非常难以编程。您可能还需要更新显示以及进度或根据状态。</p><p>第一个用例旨在使这种情况更容易处理。</p><blockquote><p>该解决方案基于以下原则：</p><ul><li>发出一个事件;</li><li>此事件触发一些导致一个或多个状态的动作;</li><li>这些状态中的每一个都可以反过来发出其他事件或导致另一个状态;</li><li>然后，这些事件将根据活动状态触发其他操作;</li><li>等等…</li></ul></blockquote><p>为了说明这个概念，我们来看两个常见的例子：</p><blockquote><p>应用初始化</p><ul><li>假设您需要运行一系列操作来初始化应用程序。操作可能与服务器的交互相关联（例如，加载一些数据）。<br>在此初始化过程中，您可能需要显示进度条和一系列图像以使用户等待。</li></ul></blockquote><blockquote><p>认证</p><ul><li>在启动时，应用程序可能需要用户进行身份验证或注册。<br>用户通过身份验证后，将重定向到应用程序的主页面。然后，如果用户注销，则将其重定向到认证页面。</li></ul></blockquote><p>为了能够处理所有可能的情况，事件序列，但是如果我们认为可以在应用程序中的任何地方触发事件，这可能变得非常难以管理。</p><p>这就是BlocEventState，兼有BlocEventStateBuilder，可以帮助很多…</p><h4 id="3-1-BlocEventState"><a href="#3-1-BlocEventState" class="headerlink" title="3.1. BlocEventState"></a>3.1. BlocEventState</h4><p>BlocEventState背后的想法是定义一个BLoC：</p><blockquote><ul><li>接受事件作为输入;</li><li>当发出新事件时调用eventHandler;</li><li>eventHandler 负责根据事件采取适当的行动并发出状态作为回应。</li></ul></blockquote><p>下图显示了这个想法：<br><img src="https://upload-images.jianshu.io/upload_images/699599-7bb89ed779a57533.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>这是这类的源代码。解释如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:blocs/bloc_helpers/bloc_provider.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:meta/meta.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:rxdart/rxdart.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BlocEvent</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BlocState</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BlocEventStateBase</span>&lt;<span class="title">BlocEvent</span>, <span class="title">BlocState</span>&gt; <span class="keyword">implements</span> <span class="title">BlocBase</span> </span>&#123;</span><br><span class="line">  PublishSubject&lt;BlocEvent&gt; _eventController = PublishSubject&lt;BlocEvent&gt;();</span><br><span class="line">  BehaviorSubject&lt;BlocState&gt; _stateController = BehaviorSubject&lt;BlocState&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// 要调用以发出事件</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="built_in">Function</span>(BlocEvent) <span class="keyword">get</span> emitEvent =&gt; _eventController.sink.add;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// 当前/新状态</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  Stream&lt;BlocState&gt; <span class="keyword">get</span> state =&gt; _stateController.stream;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// 事件的外部处理</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  Stream&lt;BlocState&gt; eventHandler(BlocEvent event, BlocState currentState);</span><br><span class="line"></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// initialState</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="keyword">final</span> BlocState initialState;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  BlocEventStateBase(&#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.initialState,</span><br><span class="line">  &#125;)&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 对于每个接收到的事件，我们调用[eventHandler]并发出任何结果的newState</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    _eventController.listen((BlocEvent event)&#123;</span><br><span class="line">      BlocState currentState = _stateController.value ?? initialState;</span><br><span class="line">      eventHandler(event, currentState).forEach((BlocState newState)&#123;</span><br><span class="line">        _stateController.sink.add(newState);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _eventController.close();</span><br><span class="line">    _stateController.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如您所见，这是一个需要扩展的抽象类，用于定义eventHandler方法的行为。</p><p>他公开：</p><blockquote><ul><li>一个Sink（emitEvent）来推送一个事件 ;</li><li>一个流（状态）来监听发射状态。</li></ul></blockquote><p>在初始化时（请参阅构造函数）：</p><blockquote><p>一个初始化状态需要设置;</p><ul><li>它创建了一个StreamSubscription听传入事件到</li><li>将它们发送到eventHandler</li><li>发出结果状态。</li></ul></blockquote><h4 id="3-2-专门的BlocEventState"><a href="#3-2-专门的BlocEventState" class="headerlink" title="3.2. 专门的BlocEventState"></a>3.2. 专门的BlocEventState</h4><p>用于实现此类BlocEventState的模板在下面给出。之后，我们将实施真实的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemplateEventStateBloc</span> <span class="keyword">extends</span> <span class="title">BlocEventStateBase</span>&lt;<span class="title">BlocEvent</span>, <span class="title">BlocState</span>&gt; </span>&#123;</span><br><span class="line">  TemplateEventStateBloc()</span><br><span class="line">      : <span class="keyword">super</span>(</span><br><span class="line">          initialState: BlocState.notInitialized(),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Stream&lt;BlocState&gt; eventHandler( BlocEvent event, BlocState currentState) <span class="keyword">async</span>* &#123;</span><br><span class="line">     <span class="keyword">yield</span> BlocState.notInitialized();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这个模板不能编译，请不要担心……这是正常的，因为我们还没有定义BlocState.notInitialized（） ……这将在几分钟内出现。</p><p>此模板仅在初始化时提供initialState并覆盖eventHandler。</p><p>这里有一些非常有趣的事情需要注意。我们使用异步生成器：async * 和yield语句。</p><blockquote><p>使用async *修饰符标记函数，将函数标识为异步生成器：</p></blockquote><blockquote><p>每次 yield 语句 被调用时，它增加了下面的表达式的结果 yield 输出stream。</p></blockquote><blockquote><p>这是非常有用的，如果我们需要发出一个序列的States，从一系列的行动所造成（我们将在后面看到，在实践中）</p></blockquote><blockquote><p>有关异步生成器的其他详细信息，请单击此<a href="https://www.dartlang.org/articles/language/beyond-async" target="_blank" rel="noopener">链接</a>。</p></blockquote><h4 id="3-3-BlocEvent和BlocState"><a href="#3-3-BlocEvent和BlocState" class="headerlink" title="3.3.BlocEvent和BlocState"></a>3.3.BlocEvent和BlocState</h4><p>正如您所注意到的，我们已经定义了一个 BlocEvent 和 BlocState 抽象类。</p><p>这些类需要使用您要发出的特殊事件和状态进行扩展。</p><h4 id="3-4-BlocEventStateBuilder小部件"><a href="#3-4-BlocEventStateBuilder小部件" class="headerlink" title="3.4. BlocEventStateBuilder小部件"></a>3.4. BlocEventStateBuilder小部件</h4><p>模式最后一部分的是BlocEventStateBuilder小部件，它允许你在响应State(s)，所发射的BlocEventState。</p><p>这是它的源代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Widget AsyncBlocEventStateBuilder&lt;BlocState&gt;(BuildContext context, BlocState state);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlocEventStateBuilder</span>&lt;<span class="title">BlocEvent</span>,<span class="title">BlocState</span>&gt; <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> BlocEventStateBuilder(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.builder,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.bloc,</span><br><span class="line">  &#125;): <span class="keyword">assert</span>(builder != <span class="keyword">null</span>),</span><br><span class="line">      <span class="keyword">assert</span>(bloc != <span class="keyword">null</span>),</span><br><span class="line">      <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> BlocEventStateBase&lt;BlocEvent,BlocState&gt; bloc;</span><br><span class="line">  <span class="keyword">final</span> AsyncBlocEventStateBuilder&lt;BlocState&gt; builder;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamBuilder&lt;BlocState&gt;(</span><br><span class="line">      stream: bloc.state,</span><br><span class="line">      initialData: bloc.initialState,</span><br><span class="line">      builder: (BuildContext context, AsyncSnapshot&lt;BlocState&gt; snapshot)&#123;</span><br><span class="line">        <span class="keyword">return</span> builder(context, snapshot.data);</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个Widget只是一个专门的StreamBuilder，它会在每次发出新的BlocState时调用builder输入参数。</p><hr><p>好的。现在我们已经拥有了所有的部分，现在是时候展示我们可以用它们做些什么……</p><h4 id="3-5-案例1：应用程序初始化"><a href="#3-5-案例1：应用程序初始化" class="headerlink" title="3.5.案例1：应用程序初始化"></a>3.5.案例1：应用程序初始化</h4><p>第一个示例说明了您需要应用程序在启动时执行某些任务的情况。</p><p>常见的用途是游戏最初显示启动画面（动画与否），同时从服务器获取一些文件，检查新的更新是否可用，尝试连接到任何游戏中心 ……在显示实际主屏幕之前。为了不给应用程序什么都不做的感觉，它可能会显示一个进度条并定期显示一些图片，同时它会完成所有初始化过程。</p><p>我要向您展示的实现非常简单。它只会在屏幕上显示一些竞争百分比，但这可以很容易地扩展到您的需求。</p><h5 id="3-5-1。ApplicationInitializationEvent"><a href="#3-5-1。ApplicationInitializationEvent" class="headerlink" title="3.5.1。ApplicationInitializationEvent"></a>3.5.1。ApplicationInitializationEvent</h5><p>在这个例子中，我只考虑2个事件：</p><blockquote><ul><li>start：此事件将触发初始化过程;</li><li>stop：该事件可用于强制初始化进程停止。</li></ul></blockquote><p>这是定义代码实现：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationInitializationEvent</span> <span class="keyword">extends</span> <span class="title">BlocEvent</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> ApplicationInitializationEventType type;</span><br><span class="line"></span><br><span class="line">  ApplicationInitializationEvent(&#123;</span><br><span class="line">    <span class="keyword">this</span>.type: ApplicationInitializationEventType.start,</span><br><span class="line">  &#125;) : <span class="keyword">assert</span>(type != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> ApplicationInitializationEventType &#123;</span><br><span class="line">  start,</span><br><span class="line">  stop,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.5.2. ApplicationInitializationState</p><p>该类将提供与初始化过程相关的信息。</p><p>对于这个例子，我会考虑：</p><blockquote><ul><li>2标识：<br>isInitialized指示初始化是否完成<br>isInitializing以了解我们是否处于初始化过程的中间</li><li>进度完成率</li></ul></blockquote><p>这是它的源代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationInitializationState</span> <span class="keyword">extends</span> <span class="title">BlocState</span> </span>&#123;</span><br><span class="line">  ApplicationInitializationState(&#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.isInitialized,</span><br><span class="line">    <span class="keyword">this</span>.isInitializing: <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.progress: <span class="number">0</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> isInitialized;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> isInitializing;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> progress;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> ApplicationInitializationState.notInitialized() &#123;</span><br><span class="line">    <span class="keyword">return</span> ApplicationInitializationState(</span><br><span class="line">      isInitialized: <span class="keyword">false</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> ApplicationInitializationState.progressing(<span class="built_in">int</span> progress) &#123;</span><br><span class="line">    <span class="keyword">return</span> ApplicationInitializationState(</span><br><span class="line">      isInitialized: progress == <span class="number">100</span>,</span><br><span class="line">      isInitializing: <span class="keyword">true</span>,</span><br><span class="line">      progress: progress,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> ApplicationInitializationState.initialized() &#123;</span><br><span class="line">    <span class="keyword">return</span> ApplicationInitializationState(</span><br><span class="line">      isInitialized: <span class="keyword">true</span>,</span><br><span class="line">      progress: <span class="number">100</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.5.3. ApplicationInitializationBloc</p><p>该BLoC负责基于事件处理初始化过程。</p><p>这是代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationInitializationBloc</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">BlocEventStateBase</span>&lt;<span class="title">ApplicationInitializationEvent</span>, <span class="title">ApplicationInitializationState</span>&gt; </span>&#123;</span><br><span class="line">  ApplicationInitializationBloc()</span><br><span class="line">      : <span class="keyword">super</span>(</span><br><span class="line">          initialState: ApplicationInitializationState.notInitialized(),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Stream&lt;ApplicationInitializationState&gt; eventHandler(</span><br><span class="line">      ApplicationInitializationEvent event, ApplicationInitializationState currentState) <span class="keyword">async</span>* &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!currentState.isInitialized)&#123;</span><br><span class="line">      <span class="keyword">yield</span> ApplicationInitializationState.notInitialized();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event.type == ApplicationInitializationEventType.start) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">int</span> progress = <span class="number">0</span>; progress &lt; <span class="number">101</span>; progress += <span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">await</span> Future.delayed(<span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">300</span>));</span><br><span class="line">        <span class="keyword">yield</span> ApplicationInitializationState.progressing(progress);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event.type == ApplicationInitializationEventType.stop)&#123;</span><br><span class="line">      <span class="keyword">yield</span> ApplicationInitializationState.initialized();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些解释：</p><blockquote><ul><li>当收到事件“ ApplicationInitializationEventType.start ”时，它从0开始计数到100(单位为10），并且对于每个值（0,10,20，……），它发出（通过yield）一个告诉的新状态初始化正在运行（isInitializing = true）及其进度值。</li><li>当收到事件”ApplicationInitializationEventType.stop”时，它认为初始化已完成。</li><li>正如你所看到的，我在计数器循环中放了一些延迟。这将向您展示如何使用任何Future（例如，您需要联系服务器的情况）</li></ul></blockquote><h5 id="3-5-4-将它们全部包装在一起"><a href="#3-5-4-将它们全部包装在一起" class="headerlink" title="3.5.4. 将它们全部包装在一起"></a>3.5.4. 将它们全部包装在一起</h5><p>现在，剩下的部分是显示显示计数器的伪Splash屏幕 ……</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InitializationPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _InitializationPageState createState() =&gt; _InitializationPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_InitializationPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">InitializationPage</span>&gt; </span>&#123;</span><br><span class="line">  ApplicationInitializationBloc bloc;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState()&#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    bloc = ApplicationInitializationBloc();</span><br><span class="line">    bloc.emitEvent(ApplicationInitializationEvent());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    bloc?.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext pageContext) &#123;</span><br><span class="line">    <span class="keyword">return</span> SafeArea(</span><br><span class="line">      child: Scaffold(</span><br><span class="line">        body: Container(</span><br><span class="line">          child: Center(</span><br><span class="line">            child: BlocEventStateBuilder&lt;ApplicationInitializationEvent, ApplicationInitializationState&gt;(</span><br><span class="line">              bloc: bloc,</span><br><span class="line">              builder: (BuildContext context, ApplicationInitializationState state)&#123;</span><br><span class="line">                <span class="keyword">if</span> (state.isInitialized)&#123;</span><br><span class="line">                  <span class="comment">//</span></span><br><span class="line">                  <span class="comment">// Once the initialization is complete, let's move to another page</span></span><br><span class="line">                  <span class="comment">//</span></span><br><span class="line">                  WidgetsBinding.instance.addPostFrameCallback((_)&#123;</span><br><span class="line">                    Navigator.of(context).pushReplacementNamed(<span class="string">'/home'</span>);</span><br><span class="line">                  &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> Text(<span class="string">'Initialization in progress... <span class="subst">$&#123;state.progress&#125;</span>%'</span>);</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><ul><li>由于ApplicationInitializationBloc不需要在应用程序的任何地方使用，我们可以在StatefulWidget中初始化它;</li><li>我们直接发出ApplicationInitializationEventType.start事件来触发eventHandler</li><li>每次发出ApplicationInitializationState时，我们都会更新文本</li><li>初始化完成后，我们将用户重定向到主页。</li></ul></blockquote><p>特技</p><blockquote><p>由于我们无法直接重定向到主页，在构建器内部，我们使用WidgetsBinding.instance.addPostFrameCallback（）方法请求Flutter 在渲染完成后立即执行方法</p></blockquote><h4 id="3-6-案例2：应用程序身份验证和注销"><a href="#3-6-案例2：应用程序身份验证和注销" class="headerlink" title="3.6. 案例2：应用程序身份验证和注销"></a>3.6. 案例2：应用程序身份验证和注销</h4><p>对于此示例，我将考虑以下用例：</p><blockquote><ul><li>在启动时，如果用户未经过身份验证，则会自动显示“ 身份验证/注册”页面;</li><li>在用户认证期间，显示CircularProgressIndicator ;</li><li>经过身份验证后，用户将被重定向到主页 ;</li><li>在应用程序的任何地方，用户都可以注销;</li><li>当用户注销时，用户将自动重定向到“ 身份验证”页面。</li></ul></blockquote><p>当然，很有可能以编程方式处理所有这些，但将所有这些委托给BLoC要容易得多。</p><p>下图解释了我要解释的解决方案：</p><p><img src="http://upload-images.jianshu.io/upload_images/699599-0b360ed2992b8fff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>名为“ DecisionPage ” 的中间页面将负责将用户自动重定向到“ 身份验证”页面或主页，具体取决于用户身份验证的状态。当然，此DecisionPage从不显示，也不应被视为页面。</p><h5 id="3-6-1-AuthenticationEvent"><a href="#3-6-1-AuthenticationEvent" class="headerlink" title="3.6.1. AuthenticationEvent"></a>3.6.1. AuthenticationEvent</h5><p>在这个例子中，我只考虑2个事件：</p><blockquote><ul><li>login：当用户正确验证时发出此事件;</li><li>logout：用户注销时发出的事件。</li></ul></blockquote><p>代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticationEvent</span> <span class="keyword">extends</span> <span class="title">BlocEvent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  AuthenticationEvent(&#123;</span><br><span class="line">    <span class="keyword">this</span>.name: <span class="string">''</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthenticationEventLogin</span> <span class="keyword">extends</span> <span class="title">AuthenticationEvent</span> </span>&#123;</span><br><span class="line">  AuthenticationEventLogin(&#123;</span><br><span class="line">    <span class="built_in">String</span> name,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(</span><br><span class="line">          name: name,</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthenticationEventLogout</span> <span class="keyword">extends</span> <span class="title">AuthenticationEvent</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>3.6.2. AuthenticationState<br>该类将提供与身份验证过程相关的信息。</p><p>对于这个例子，我会考虑：</p><blockquote><ul><li>3点：<br>isAuthenticated指示身份验证是否完整<br>isAuthenticating以了解我们是否处于身份验证过程的中间<br>hasFailed表示身份验证失败</li><li>经过身份验证的用户名</li></ul></blockquote><p>这是它的源代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthenticationState</span> <span class="keyword">extends</span> <span class="title">BlocState</span> </span>&#123;</span><br><span class="line">  AuthenticationState(&#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.isAuthenticated,</span><br><span class="line">    <span class="keyword">this</span>.isAuthenticating: <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.hasFailed: <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.name: <span class="string">''</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> isAuthenticated;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> isAuthenticating;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> hasFailed;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">factory</span> AuthenticationState.notAuthenticated() &#123;</span><br><span class="line">    <span class="keyword">return</span> AuthenticationState(</span><br><span class="line">      isAuthenticated: <span class="keyword">false</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> AuthenticationState.authenticated(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="keyword">return</span> AuthenticationState(</span><br><span class="line">      isAuthenticated: <span class="keyword">true</span>,</span><br><span class="line">      name: name,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> AuthenticationState.authenticating() &#123;</span><br><span class="line">    <span class="keyword">return</span> AuthenticationState(</span><br><span class="line">      isAuthenticated: <span class="keyword">false</span>,</span><br><span class="line">      isAuthenticating: <span class="keyword">true</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> AuthenticationState.failure() &#123;</span><br><span class="line">    <span class="keyword">return</span> AuthenticationState(</span><br><span class="line">      isAuthenticated: <span class="keyword">false</span>,</span><br><span class="line">      hasFailed: <span class="keyword">true</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-6-3-AuthenticationBloc"><a href="#3-6-3-AuthenticationBloc" class="headerlink" title="3.6.3.AuthenticationBloc"></a>3.6.3.AuthenticationBloc</h5><p>此BLoC负责根据事件处理身份验证过程。</p><p>这是代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthenticationBloc</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">BlocEventStateBase</span>&lt;<span class="title">AuthenticationEvent</span>, <span class="title">AuthenticationState</span>&gt; </span>&#123;</span><br><span class="line">  AuthenticationBloc()</span><br><span class="line">      : <span class="keyword">super</span>(</span><br><span class="line">          initialState: AuthenticationState.notAuthenticated(),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Stream&lt;AuthenticationState&gt; eventHandler(</span><br><span class="line">      AuthenticationEvent event, AuthenticationState currentState) <span class="keyword">async</span>* &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">is</span> AuthenticationEventLogin) &#123;</span><br><span class="line">      <span class="comment">//通知我们正在进行身份验证</span></span><br><span class="line">      <span class="keyword">yield</span> AuthenticationState.authenticating();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//模拟对身份验证服务器的调用</span></span><br><span class="line">      <span class="keyword">await</span> Future.delayed(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//告知我们是否已成功通过身份验证</span></span><br><span class="line">      <span class="keyword">if</span> (event.name == <span class="string">"failure"</span>)&#123;</span><br><span class="line">        <span class="keyword">yield</span> AuthenticationState.failure();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> AuthenticationState.authenticated(event.name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">is</span> AuthenticationEventLogout)&#123;</span><br><span class="line">      <span class="keyword">yield</span> AuthenticationState.notAuthenticated();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些解释：</p><blockquote><ul><li>当收到事件“ AuthenticationEventLogin ”时，它会（通过yield）发出一个新状态，告知身份验证正在运行（isAuthenticating = true）。</li><li>然后它运行身份验证，一旦完成，就会发出另一个状态，告知身份验证已完成。</li><li>当收到事件“ AuthenticationEventLogout ”时，它将发出一个新状态，告诉用户不再进行身份验证。</li></ul></blockquote><h5 id="3-6-4-AuthenticationPage"><a href="#3-6-4-AuthenticationPage" class="headerlink" title="3.6.4. AuthenticationPage"></a>3.6.4. AuthenticationPage</h5><p>正如您将要看到的那样，为了便于解释，此页面非常基本且不会做太多。</p><p>这是代码。解释如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthenticationPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Prevents the use of the "back" button</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  Future&lt;<span class="built_in">bool</span>&gt; _onWillPopScope() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    AuthenticationBloc bloc = BlocProvider.of&lt;AuthenticationBloc&gt;(context);</span><br><span class="line">    <span class="keyword">return</span> WillPopScope(</span><br><span class="line">      onWillPop: _onWillPopScope,</span><br><span class="line">      child: SafeArea(</span><br><span class="line">        child: Scaffold(</span><br><span class="line">          appBar: AppBar(</span><br><span class="line">            title: Text(<span class="string">'Authentication Page'</span>),</span><br><span class="line">            leading: Container(),</span><br><span class="line">          ),</span><br><span class="line">          body: Container(</span><br><span class="line">            child:</span><br><span class="line">                BlocEventStateBuilder&lt;AuthenticationEvent, AuthenticationState&gt;(</span><br><span class="line">              bloc: bloc,</span><br><span class="line">              builder: (BuildContext context, AuthenticationState state) &#123;</span><br><span class="line">                <span class="keyword">if</span> (state.isAuthenticating) &#123;</span><br><span class="line">                  <span class="keyword">return</span> PendingAction();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (state.isAuthenticated)&#123;</span><br><span class="line">                  <span class="keyword">return</span> Container();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">List</span>&lt;Widget&gt; children = &lt;Widget&gt;[];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Button to fake the authentication (success)</span></span><br><span class="line">                children.add(</span><br><span class="line">                  ListTile(</span><br><span class="line">                      title: RaisedButton(</span><br><span class="line">                        child: Text(<span class="string">'Log in (success)'</span>),</span><br><span class="line">                        onPressed: () &#123;</span><br><span class="line">                            bloc.emitEvent(AuthenticationEventLogin(name: <span class="string">'Didier'</span>));</span><br><span class="line">                        &#125;,</span><br><span class="line">                      ),</span><br><span class="line">                    ),</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Button to fake the authentication (failure)</span></span><br><span class="line">                children.add(</span><br><span class="line">                  ListTile(</span><br><span class="line">                      title: RaisedButton(</span><br><span class="line">                        child: Text(<span class="string">'Log in (failure)'</span>),</span><br><span class="line">                        onPressed: () &#123;</span><br><span class="line">                            bloc.emitEvent(AuthenticationEventLogin(name: <span class="string">'failure'</span>));</span><br><span class="line">                        &#125;,</span><br><span class="line">                      ),</span><br><span class="line">                    ),</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Display a text if the authentication failed</span></span><br><span class="line">                <span class="keyword">if</span> (state.hasFailed)&#123;</span><br><span class="line">                  children.add(</span><br><span class="line">                    Text(<span class="string">'Authentication failure!'</span>),</span><br><span class="line">                  );</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> Column(</span><br><span class="line">                  children: children,</span><br><span class="line">                );    </span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><ul><li>第11行：页面检索对AuthenticationBloc的引用</li><li>第24-70行：它监听发出的AuthenticationState：<br> 如果身份验证正在进行中，它会显示一个CircularProgressIndicator，告诉用户正在进行某些操作并阻止用户访问该页面（第25-27行）<br> 如果验证成功，我们不需要显示任何内容（第29-31行）。<br> 如果用户未经过身份验证，则会显示2个按钮以模拟成功的身份验证和失败。<br> 当我们点击其中一个按钮时，我们发出一个AuthenticationEventLogin事件，以及一些参数（通常由认证过程使用）<br> 如果验证失败，我们会显示错误消息（第60-64行）</li></ul></blockquote><p>提示</p><blockquote><p>您可能已经注意到，我将页面包装在WillPopScope中。<br>理由是我不希望用户能够使用Android’后退’按钮，如此示例中所示，身份验证是一个必须的步骤，它阻止用户访问任何其他部分，除非经过正确的身份验证。</p></blockquote><h5 id="3-6-5-DecisionPage"><a href="#3-6-5-DecisionPage" class="headerlink" title="3.6.5. DecisionPage"></a>3.6.5. DecisionPage</h5><p>如前所述，我希望应用程序根据身份验证状态自动重定向到AuthenticationPage或HomePage。</p><p>以下是此DecisionPage的代码，说明如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecisionPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  DecisionPageState createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DecisionPageState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecisionPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">DecisionPage</span>&gt; </span>&#123;</span><br><span class="line">  AuthenticationState oldAuthenticationState;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    AuthenticationBloc bloc = BlocProvider.of&lt;AuthenticationBloc&gt;(context);</span><br><span class="line">    <span class="keyword">return</span> BlocEventStateBuilder&lt;AuthenticationEvent, AuthenticationState&gt;(</span><br><span class="line">      bloc: bloc,</span><br><span class="line">      builder: (BuildContext context, AuthenticationState state) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state != oldAuthenticationState)&#123;</span><br><span class="line">          oldAuthenticationState = state;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (state.isAuthenticated)&#123;</span><br><span class="line">            _redirectToPage(context, HomePage());</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state.isAuthenticating || state.hasFailed)&#123;</span><br><span class="line">           <span class="comment">//do nothing</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _redirectToPage(context, AuthenticationPage());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="comment">//此页面不需要显示任何内容</span></span><br><span class="line">        <span class="comment">//总是在任何活动页面后面提醒（因此“隐藏”）。</span></span><br><span class="line">        <span class="keyword">return</span> Container();</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _redirectToPage(BuildContext context, Widget page)&#123;</span><br><span class="line">    WidgetsBinding.instance.addPostFrameCallback((_)&#123;</span><br><span class="line">      MaterialPageRoute newRoute = MaterialPageRoute(</span><br><span class="line">          builder: (BuildContext context) =&gt; page</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">      Navigator.of(context).pushAndRemoveUntil(newRoute, ModalRoute.withName(<span class="string">'/decision'</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>提醒</p><p>为了详细解释这一点，我们需要回到Flutter处理Pages（= Route）的方式。要处理路由，我们使用导航器，它创建一个叠加层。<br>这个覆盖是一个堆栈的OverlayEntry，他们每个人的包含页面。<br>当我们通过Navigator.of（上下文）推送，弹出，替换页面时，后者更新其重建的覆盖（因此堆栈）。<br>当堆栈被重建，每个OverlayEntry（因此它的内容）也被重建。<br>因此，当我们通过Navigator.of（上下文）进行操作时，所有剩余的页面都会重建！</p></blockquote><p>那么，为什么我将它实现为StatefulWidget？</p><p>为了能够响应AuthenticationState的任何更改，此“ 页面 ”需要在应用程序的整个生命周期中保持存在。</p><p>这意味着，根据上面的提醒，每次Navigator.of（上下文）完成操作时，都会重建此页面。</p><p>因此，它的BlocEventStateBuilder也将重建，调用自己的构建器方法。</p><p>因为此构建器负责将用户重定向到与AuthenticationState对应的页面，所以如果我们每次重建页面时重定向用户，它将继续重定向，因为不断重建。</p><p>为了防止这种情况发生，我们只需要记住我们采取行动的最后一个AuthenticationState，并且只在收到另一个AuthenticationState时采取另一个动作。</p><p>这是如何运作的？</p><p>如上所述，每次发出AuthenticationState时，BlocEventStateBuilder都会调用其构建器。</p><p>基于状态标志（isAuthenticated），我们知道我们需要向哪个页面重定向用户。</p><blockquote><p>特技</p><p>由于我们无法直接从构建器重定向到另一个页面，因此我们使用WidgetsBinding.instance.addPostFrameCallback（）方法在呈现完成后请求Flutter执行方法</p><p>此外，由于我们需要在重定向用户之前删除任何现有页面，除了需要保留在所有情况下的此DecisionPage 之外，我们使用Navigator.of（context）.pushAndRemoveUntil（…）来实现此目的。</p></blockquote><p>3.6.6、登出<br>要让用户注销，您现在可以创建一个“ LogOutButton ”并将其放在应用程序的任何位置。</p><blockquote><ul><li>此按钮只需要发出AuthenticationEventLogout（）事件，这将导致以下自动操作链：<br>1.它将由AuthenticationBloc处理<br>2.反过来会发出一个AuthentiationState（isAuthenticated = false）<br>3.这将由DecisionPage通过BlocEventStateBuilder处理<br>4.这会将用户重定向到AuthenticationPage</li></ul></blockquote><h5 id="3-6-7-AuthenticationBloc"><a href="#3-6-7-AuthenticationBloc" class="headerlink" title="3.6.7. AuthenticationBloc"></a>3.6.7. AuthenticationBloc</h5><p>由于AuthenticationBloc需要提供给该应用程序的任何页面，我们也将注入它作为MaterialApp父母，如下所示</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(Application());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> BlocProvider&lt;AuthenticationBloc&gt;(</span><br><span class="line">      bloc: AuthenticationBloc(),</span><br><span class="line">      child: MaterialApp(</span><br><span class="line">        title: <span class="string">'BLoC Samples'</span>,</span><br><span class="line">        theme: ThemeData(</span><br><span class="line">          primarySwatch: Colors.blue,</span><br><span class="line">        ),</span><br><span class="line">        home: DecisionPage(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-表格验证（允许根据条目和验证控制表单的行为）"><a href="#4-表格验证（允许根据条目和验证控制表单的行为）" class="headerlink" title="4.表格验证（允许根据条目和验证控制表单的行为）"></a>4.表格验证（允许根据条目和验证控制表单的行为）</h3><blockquote><p>BLoC的另一个有趣用途是当您需要验证表单时：</p><ul><li>根据某些业务规则验证与TextField相关的条目;</li><li>根据规则显示验证错误消息;</li><li>根据业务规则自动化窗口小部件的可访问性。</li></ul></blockquote><p>我现在要做的一个例子是RegistrationForm，它由3个TextFields（电子邮件，密码，确认密码）和1个RaisedButton组成，以启动注册过程。</p><p>我想要实现的业务规则是：</p><blockquote><ul><li>该电子邮件必须是一个有效的电子邮件地址。如果不是，则需要显示消息。</li><li>该密码必须是有效的（必须包含至少8个字符，具有1个大写，小写1，图1和1个特殊字符）。如果无效，则需要显示消息。</li><li>在重新输入密码需要满足相同的验证规则和相同的密码。如果不相同，则需要显示消息。</li><li>在登记时，按钮可能只能激活所有的规则都是有效的。</li></ul></blockquote><h4 id="4-1-RegistrationFormBloc"><a href="#4-1-RegistrationFormBloc" class="headerlink" title="4.1.RegistrationFormBloc"></a>4.1.RegistrationFormBloc</h4><p>该BLoC负责处理验证业务规则，如前所述。</p><p>源码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegistrationFormBloc</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="title">with</span> <span class="title">EmailValidator</span>, <span class="title">PasswordValidator</span> <span class="keyword">implements</span> <span class="title">BlocBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> BehaviorSubject&lt;<span class="built_in">String</span>&gt; _emailController = BehaviorSubject&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">  <span class="keyword">final</span> BehaviorSubject&lt;<span class="built_in">String</span>&gt; _passwordController = BehaviorSubject&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">  <span class="keyword">final</span> BehaviorSubject&lt;<span class="built_in">String</span>&gt; _passwordConfirmController = BehaviorSubject&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Inputs</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="built_in">Function</span>(<span class="built_in">String</span>) <span class="keyword">get</span> onEmailChanged =&gt; _emailController.sink.add;</span><br><span class="line">  <span class="built_in">Function</span>(<span class="built_in">String</span>) <span class="keyword">get</span> onPasswordChanged =&gt; _passwordController.sink.add;</span><br><span class="line">  <span class="built_in">Function</span>(<span class="built_in">String</span>) <span class="keyword">get</span> onRetypePasswordChanged =&gt; _passwordConfirmController.sink.add;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Validators</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  Stream&lt;<span class="built_in">String</span>&gt; <span class="keyword">get</span> email =&gt; _emailController.stream.transform(validateEmail);</span><br><span class="line">  Stream&lt;<span class="built_in">String</span>&gt; <span class="keyword">get</span> password =&gt; _passwordController.stream.transform(validatePassword);</span><br><span class="line">  Stream&lt;<span class="built_in">String</span>&gt; <span class="keyword">get</span> confirmPassword =&gt; _passwordConfirmController.stream.transform(validatePassword)</span><br><span class="line">    .doOnData((<span class="built_in">String</span> c)&#123;</span><br><span class="line">      <span class="comment">// If the password is accepted (after validation of the rules)</span></span><br><span class="line">      <span class="comment">// we need to ensure both password and retyped password match</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="number">0</span> != _passwordController.value.compareTo(c))&#123;</span><br><span class="line">        <span class="comment">// If they do not match, add an error</span></span><br><span class="line">        _passwordConfirmController.addError(<span class="string">"No Match"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Registration button</span></span><br><span class="line">  Stream&lt;<span class="built_in">bool</span>&gt; <span class="keyword">get</span> registerValid =&gt; Observable.combineLatest3(</span><br><span class="line">                                      email, </span><br><span class="line">                                      password, </span><br><span class="line">                                      confirmPassword, </span><br><span class="line">                                      (e, p, c) =&gt; <span class="keyword">true</span></span><br><span class="line">                                    );</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _emailController?.close();</span><br><span class="line">    _passwordController?.close();</span><br><span class="line">    _passwordConfirmController?.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>让我详细解释一下……</p><ul><li>我们首先初始化3个BehaviorSubject来处理表单的每个TextField的Streams。</li><li>我们公开了3个Function（String），它将用于接受来自TextFields的输入。</li><li>我们公开了3个Stream <string>，TextField将使用它来显示由它们各自的验证产生的潜在错误消息</string></li><li>我们公开了1个Stream <bool>，它将被RaisedButton使用，以根据整个验证结果启用/禁用它。</bool></li></ul></blockquote><p>好的，现在是时候深入了解更多细节……</p><p>您可能已经注意到，此类的签名有点特殊。我们来回顾一下吧。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegistrationFormBloc</span> <span class="keyword">extends</span> <span class="title">Object</span> </span></span><br><span class="line"><span class="class">                           <span class="title">with</span> <span class="title">EmailValidator</span>, <span class="title">PasswordValidator</span> </span></span><br><span class="line"><span class="class">                           <span class="keyword">implements</span> <span class="title">BlocBase</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>with</strong> 关键字意味着这个类是使用混入(MIXINS)(在另一个类中重用一些类代码的一种方法)，为了能够使用with关键字，该类需要扩展Object类。这些mixin包含分别验证电子邮件和密码的代码。</p><p>有关详细信息，混入我建议你阅读从这篇大文章 <a href="https://medium.com/flutter-community/dart-what-are-mixins-3a72344011f3" target="_blank" rel="noopener">Romain Rastel</a>。</p><h5 id="4-1-1-Validator-Mixins"><a href="#4-1-1-Validator-Mixins" class="headerlink" title="4.1.1. Validator Mixins"></a>4.1.1. Validator Mixins</h5><p>我只会解释EmailValidator，因为PasswordValidator非常相似。</p><p>First, the code:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">String</span> _kEmailRule = <span class="string">r"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailValidator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> StreamTransformer&lt;<span class="built_in">String</span>,<span class="built_in">String</span>&gt; validateEmail = </span><br><span class="line">      StreamTransformer&lt;<span class="built_in">String</span>,<span class="built_in">String</span>&gt;.fromHandlers(handleData: (email, sink)&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">RegExp</span> emailExp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(_kEmailRule);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!emailExp.hasMatch(email) || email.isEmpty)&#123;</span><br><span class="line">          sink.addError(<span class="string">'Entre a valid email'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          sink.add(email);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类公开了一个 final 函数（“ validateEmail ”），它是一个StreamTransformer。</p><blockquote><p>提醒<br>StreamTransformer被调用如下：stream.transform（StreamTransformer）。<br>StreamTransformer通过transform方法从Stream引用它的输入。然后它处理此输入，并将转换后的输入重新注入初始Stream。</p></blockquote><h5 id="4-1-2-为什么使用stream-transform（）？"><a href="#4-1-2-为什么使用stream-transform（）？" class="headerlink" title="4.1.2. 为什么使用stream.transform（）？"></a>4.1.2. 为什么使用stream.transform（）？</h5><p>如前所述，如果验证成功，StreamTransformer会将输入重新注入Stream。为什么有用？</p><p>以下是与Observable.combineLatest3（）相关的解释…此方法在它引用的所有Streams之前不会发出任何值，至少发出一个值。</p><p>让我们看看下面的图片来说明我们想要实现的目标。</p><p><img src="https://upload-images.jianshu.io/upload_images/699599-4ce491c8f1fa94dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>如果用户输入电子邮件并且后者经过验证，它将由电子邮件流发出，该电子邮件流将是Observable.combineLatest3（）的一个输入;<br>如果电子邮件地址无效，错误将被添加到流（和没有价值会流出流）;<br>这同样适用于密码和重新输入密码 ;<br>当所有这三个验证都成功时（意味着所有这三个流都会发出一个值），Observable.combineLatest3（）将依次发出一个真正的感谢“ （e，p，c）=&gt; true ”（见第35行）。</p></blockquote><h5 id="4-1-3-验证2个密码"><a href="#4-1-3-验证2个密码" class="headerlink" title="4.1.3. 验证2个密码"></a>4.1.3. 验证2个密码</h5><p>我在互联网上看到了很多与这种比较有关的问题。存在几种解决方案，让我解释其中的两种。</p><h6 id="4-1-3-1-基本解决方案-没有错误消息"><a href="#4-1-3-1-基本解决方案-没有错误消息" class="headerlink" title="4.1.3.1.基本解决方案 - 没有错误消息"></a>4.1.3.1.基本解决方案 - 没有错误消息</h6><p>第一个解决方案可能是以下一个：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;<span class="built_in">bool</span>&gt; <span class="keyword">get</span> registerValid =&gt; Observable.combineLatest3(</span><br><span class="line">                                      email, </span><br><span class="line">                                      password, </span><br><span class="line">                                      confirmPassword, </span><br><span class="line">                                      (e, p, c) =&gt; (<span class="number">0</span> == p.compareTo(c))</span><br><span class="line">                                    );</span><br></pre></td></tr></table></figure><p>这个解决方案只需验证两个密码，如果它们匹配，就会发出一个值（= true）。</p><p>我们很快就会看到，Register按钮的可访问性将取决于registerValid流。</p><p>如果两个密码不匹配，则该流不会发出任何值，并且“ 注册”按钮保持不活动状态，但用户不会收到任何错误消息以帮助他理解原因。</p><h6 id="4-1-3-2。带错误消息的解决方案"><a href="#4-1-3-2。带错误消息的解决方案" class="headerlink" title="4.1.3.2。带错误消息的解决方案"></a>4.1.3.2。带错误消息的解决方案</h6><p>另一种解决方案包括扩展confirmPassword流的处理，如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;<span class="built_in">String</span>&gt; <span class="keyword">get</span> confirmPassword =&gt; _passwordConfirmController.stream.transform(validatePassword)</span><br><span class="line">    .doOnData((<span class="built_in">String</span> c)&#123;</span><br><span class="line">      <span class="comment">//如果接受密码（在验证规则后）</span></span><br><span class="line">      <span class="comment">//我们需要确保密码和重新输入的密码匹配</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="number">0</span> != _passwordController.value.compareTo(c))&#123;</span><br><span class="line">         <span class="comment">//如果它们不匹配，请添加错误</span></span><br><span class="line">        _passwordConfirmController.addError(<span class="string">"No Match"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>一旦验证了重新输入密码，它就会被Stream发出，并且使用doOnData，我们可以直接获取此发出的值并将其与密码流的值进行比较。如果两者不匹配，我们现在可以发送错误消息。</p><h4 id="4-2-The-RegistrationForm"><a href="#4-2-The-RegistrationForm" class="headerlink" title="4.2. The RegistrationForm"></a>4.2. The RegistrationForm</h4><p>现在让我们先解释一下RegistrationForm：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegistrationForm</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _RegistrationFormState createState() =&gt; _RegistrationFormState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_RegistrationFormState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">RegistrationForm</span>&gt; </span>&#123;</span><br><span class="line">  RegistrationFormBloc _registrationFormBloc;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _registrationFormBloc = RegistrationFormBloc();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _registrationFormBloc?.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Form(</span><br><span class="line">      child: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          StreamBuilder&lt;<span class="built_in">String</span>&gt;(</span><br><span class="line">              stream: _registrationFormBloc.email,</span><br><span class="line">              builder: (BuildContext context, AsyncSnapshot&lt;<span class="built_in">String</span>&gt; snapshot) &#123;</span><br><span class="line">                <span class="keyword">return</span> TextField(</span><br><span class="line">                  decoration: InputDecoration(</span><br><span class="line">                    labelText: <span class="string">'email'</span>,</span><br><span class="line">                    errorText: snapshot.error,</span><br><span class="line">                  ),</span><br><span class="line">                  onChanged: _registrationFormBloc.onEmailChanged,</span><br><span class="line">                  keyboardType: TextInputType.emailAddress,</span><br><span class="line">                );</span><br><span class="line">              &#125;),</span><br><span class="line">          StreamBuilder&lt;<span class="built_in">String</span>&gt;(</span><br><span class="line">              stream: _registrationFormBloc.password,</span><br><span class="line">              builder: (BuildContext context, AsyncSnapshot&lt;<span class="built_in">String</span>&gt; snapshot) &#123;</span><br><span class="line">                <span class="keyword">return</span> TextField(</span><br><span class="line">                  decoration: InputDecoration(</span><br><span class="line">                    labelText: <span class="string">'password'</span>,</span><br><span class="line">                    errorText: snapshot.error,</span><br><span class="line">                  ),</span><br><span class="line">                  obscureText: <span class="keyword">false</span>,</span><br><span class="line">                  onChanged: _registrationFormBloc.onPasswordChanged,</span><br><span class="line">                );</span><br><span class="line">              &#125;),</span><br><span class="line">          StreamBuilder&lt;<span class="built_in">String</span>&gt;(</span><br><span class="line">              stream: _registrationFormBloc.confirmPassword,</span><br><span class="line">              builder: (BuildContext context, AsyncSnapshot&lt;<span class="built_in">String</span>&gt; snapshot) &#123;</span><br><span class="line">                <span class="keyword">return</span> TextField(</span><br><span class="line">                  decoration: InputDecoration(</span><br><span class="line">                    labelText: <span class="string">'retype password'</span>,</span><br><span class="line">                    errorText: snapshot.error,</span><br><span class="line">                  ),</span><br><span class="line">                  obscureText: <span class="keyword">false</span>,</span><br><span class="line">                  onChanged: _registrationFormBloc.onRetypePasswordChanged,</span><br><span class="line">                );</span><br><span class="line">              &#125;),</span><br><span class="line">          StreamBuilder&lt;<span class="built_in">bool</span>&gt;(</span><br><span class="line">              stream: _registrationFormBloc.registerValid,</span><br><span class="line">              builder: (BuildContext context, AsyncSnapshot&lt;<span class="built_in">bool</span>&gt; snapshot) &#123;</span><br><span class="line">                <span class="keyword">return</span> RaisedButton(</span><br><span class="line">                  child: Text(<span class="string">'Register'</span>),</span><br><span class="line">                  onPressed: (snapshot.hasData &amp;&amp; snapshot.data == <span class="keyword">true</span>)</span><br><span class="line">                      ? () &#123;</span><br><span class="line">                          <span class="comment">// launch the registration process</span></span><br><span class="line">                        &#125;</span><br><span class="line">                      : <span class="keyword">null</span>,</span><br><span class="line">                );</span><br><span class="line">              &#125;),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><ul><li>由于RegisterFormBloc仅供此表单使用，因此适合在此处初始化它。</li><li>每个TextField都包装在StreamBuilder <string>中，以便能够响应验证过程的任何结果（请参阅errorText：snapshot.error）</string></li><li>每次对TextField的内容进行修改时，我们都会通过onChanged发送输入到BLoC进行验证：_registrationFormBloc.onEmailChanged（电子邮件输入的情况）</li><li>对于RegisterButton，后者也包含在StreamBuilder <bool>中。<ul><li>如果_registrationFormBloc.registerValid发出一个值，onPressed方法将执行某些操作</li><li>如果未发出任何值，则onPressed方法将被指定为null，这将取消激活该按钮。</li></ul></bool></li></ul></blockquote><p>而已！表单中没有任何业务规则，这意味着可以更改规则而无需对表单进行任何修改，这非常好！</p><h3 id="5-Part-Of（允许Widget根据其在列表中的存在来调整其行为）"><a href="#5-Part-Of（允许Widget根据其在列表中的存在来调整其行为）" class="headerlink" title="5.Part Of（允许Widget根据其在列表中的存在来调整其行为）"></a>5.Part Of（允许Widget根据其在列表中的存在来调整其行为）</h3><p>有时，Widget知道它是否是驱动其行为的集合的一部分是有趣的。</p><p>对于本文的最后一个用例，我将考虑以下场景：</p><blockquote><p>应用程序处理项目;<br>用户可以选择放入购物篮的物品;<br>一件商品只能放入购物篮一次;<br>存放在购物篮中的物品可以从购物篮中取出;<br>一旦被移除，就可以将其取回。</p></blockquote><p>对于此示例，每个项目将显示一个按钮，该按钮将取决于购物篮中物品的存在。如果不是购物篮的一部分，该按钮将允许用户将其添加到购物篮中。如果是购物篮的一部分，该按钮将允许用户将其从篮子中取出。</p><p>为了更好地说明“ 部分 ”模式，我将考虑以下架构：</p><blockquote><p>一个购物页面将显示所有可能的项目清单;<br>购物页面中的每个商品都会显示一个按钮，用于将商品添加到购物篮或将其移除，具体取决于其在购物篮中的位置;<br>如果一个项目在购物页被添加到篮，它的按钮将自动更新，以允许用户从所述篮（反之亦然）将其删除，而不必重新生成购物页<br>另一页，购物篮，将列出篮子里的所有物品;<br>可以从此页面中删除购物篮中的任何商品。</p></blockquote><blockquote><p><strong>边注</strong><br>Part Of这个名字是我给的个人名字。这不是官方名称。</p></blockquote><p>正如您现在可以想象的那样，我们需要考虑一个专门用于处理所有可能项目列表的BLoC，以及购物篮的一部分。</p><p>这个BLoC可能如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingBloc</span> <span class="keyword">implements</span> <span class="title">BlocBase</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 所有商品的清单，购物篮的一部分</span></span><br><span class="line">  <span class="built_in">Set</span>&lt;ShoppingItem&gt; _shoppingBasket = <span class="built_in">Set</span>&lt;ShoppingItem&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 流到所有可能项目的列表</span></span><br><span class="line">  BehaviorSubject&lt;<span class="built_in">List</span>&lt;ShoppingItem&gt;&gt; _itemsController = BehaviorSubject&lt;<span class="built_in">List</span>&lt;ShoppingItem&gt;&gt;();</span><br><span class="line">  Stream&lt;<span class="built_in">List</span>&lt;ShoppingItem&gt;&gt; <span class="keyword">get</span> items =&gt; _itemsController;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Stream以列出购物篮中的项目部分</span></span><br><span class="line">  BehaviorSubject&lt;<span class="built_in">List</span>&lt;ShoppingItem&gt;&gt; _shoppingBasketController = BehaviorSubject&lt;<span class="built_in">List</span>&lt;ShoppingItem&gt;&gt;(seedValue: &lt;ShoppingItem&gt;[]);</span><br><span class="line">  Stream&lt;<span class="built_in">List</span>&lt;ShoppingItem&gt;&gt; <span class="keyword">get</span> shoppingBasket =&gt; _shoppingBasketController;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _itemsController?.close();</span><br><span class="line">    _shoppingBasketController?.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  ShoppingBloc() &#123;</span><br><span class="line">    _loadShoppingItems();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> addToShoppingBasket(ShoppingItem item)&#123;</span><br><span class="line">    _shoppingBasket.add(item);</span><br><span class="line">    _postActionOnBasket();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> removeFromShoppingBasket(ShoppingItem item)&#123;</span><br><span class="line">    _shoppingBasket.remove(item);</span><br><span class="line">    _postActionOnBasket();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _postActionOnBasket()&#123;</span><br><span class="line">    <span class="comment">// 使用新内容提供购物篮流</span></span><br><span class="line">    _shoppingBasketController.sink.add(_shoppingBasket.toList());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 任何其他处理，如</span></span><br><span class="line">    <span class="comment">// 计算篮子的总价</span></span><br><span class="line">    <span class="comment">// 项目数量，篮子的一部分......</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//生成一系列购物项目</span></span><br><span class="line">  <span class="comment">//通常这应该来自对服务器的调用</span></span><br><span class="line">  <span class="comment">//但是对于这个样本，我们只是模拟</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">void</span> _loadShoppingItems() &#123;</span><br><span class="line">    _itemsController.sink.add(<span class="built_in">List</span>&lt;ShoppingItem&gt;.generate(<span class="number">50</span>, (<span class="built_in">int</span> index) &#123;</span><br><span class="line">      <span class="keyword">return</span> ShoppingItem(</span><br><span class="line">        id: index,</span><br><span class="line">        title: <span class="string">"Item <span class="subst">$index</span>"</span>,</span><br><span class="line">        price: ((Random().nextDouble() * <span class="number">40.0</span> + <span class="number">10.0</span>) * <span class="number">100.0</span>).roundToDouble() /</span><br><span class="line">            <span class="number">100.0</span>,</span><br><span class="line">        color: Color((Random().nextDouble() * <span class="number">0xFFFFFF</span>).toInt() &lt;&lt; <span class="number">0</span>)</span><br><span class="line">            .withOpacity(<span class="number">1.0</span>),</span><br><span class="line">      );</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一可能需要解释的方法是_postActionOnBasket（）方法。每次在篮子中添加或删除项目时，我们都需要“刷新” _shoppingBasketController Stream 的内容，以便通知所有正在监听此Stream更改的Widgets并能够刷新/重建。</p><h4 id="5-2-ShoppingPage"><a href="#5-2-ShoppingPage" class="headerlink" title="5.2. ShoppingPage"></a>5.2. ShoppingPage</h4><p>此页面非常简单，只显示所有项目。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    ShoppingBloc bloc = BlocProvider.of&lt;ShoppingBloc&gt;(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SafeArea(</span><br><span class="line">        child: Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Shopping Page'</span>),</span><br><span class="line">        actions: &lt;Widget&gt;[</span><br><span class="line">          ShoppingBasket(),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">      body: Container(</span><br><span class="line">        child: StreamBuilder&lt;<span class="built_in">List</span>&lt;ShoppingItem&gt;&gt;(</span><br><span class="line">          stream: bloc.items,</span><br><span class="line">          builder: (BuildContext context,</span><br><span class="line">              AsyncSnapshot&lt;<span class="built_in">List</span>&lt;ShoppingItem&gt;&gt; snapshot) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!snapshot.hasData) &#123;</span><br><span class="line">              <span class="keyword">return</span> Container();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> GridView.builder(</span><br><span class="line">              gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">                crossAxisCount: <span class="number">3</span>,</span><br><span class="line">                childAspectRatio: <span class="number">1.0</span>,</span><br><span class="line">              ),</span><br><span class="line">              itemCount: snapshot.data.length,</span><br><span class="line">              itemBuilder: (BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">                <span class="keyword">return</span> ShoppingItemWidget(</span><br><span class="line">                  shoppingItem: snapshot.data[index],</span><br><span class="line">                );</span><br><span class="line">              &#125;,</span><br><span class="line">            );</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><ul><li>所述AppBar显示按钮，：<br> 显示出现在购物篮中的商品数量<br> 单击时将用户重定向到ShoppingBasket页面</li><li>项目列表使用GridView构建，包含在StreamBuilder &lt;List <shoppingitem>&gt;中</shoppingitem></li><li>每个项目对应一个ShoppingItemWidget</li></ul></blockquote><h4 id="5-3-ShoppingBasketPage"><a href="#5-3-ShoppingBasketPage" class="headerlink" title="5.3.ShoppingBasketPage"></a>5.3.ShoppingBasketPage</h4><p>此页面与ShoppingPage非常相似，只是StreamBuilder现在正在侦听由ShoppingBloc公开的_shoppingBasket流的变体。</p><h4 id="5-4-ShoppingItemWidget和ShoppingItemBloc"><a href="#5-4-ShoppingItemWidget和ShoppingItemBloc" class="headerlink" title="5.4. ShoppingItemWidget和ShoppingItemBloc"></a>5.4. ShoppingItemWidget和ShoppingItemBloc</h4><p><strong>Part Of</strong> 模式依赖于这两个元素的组合</p><blockquote><ul><li>该ShoppingItemWidget负责：<br>显示项目和<br>用于在购物篮中添加项目或从中取出项目的按钮</li><li>该ShoppingItemBloc负责告诉ShoppingItemWidget后者是否是购物篮的一部分，或者不是。<br>让我们看看他们如何一起工作……</li></ul></blockquote><h5 id="5-4-1-ShoppingItemBloc"><a href="#5-4-1-ShoppingItemBloc" class="headerlink" title="5.4.1. ShoppingItemBloc"></a>5.4.1. ShoppingItemBloc</h5><p>ShoppingItemBloc由每个ShoppingItemWidget实例化，赋予它“身份”</p><p>此BLoC侦听ShoppingBasket流的所有变体，并检查特定项目标识是否是篮子的一部分。</p><p>如果是，它会发出一个布尔值（= true），它将被ShoppingItemWidget捕获，以确定它是否是篮子的一部分。</p><p>这是BLoC的代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingItemBloc</span> <span class="keyword">implements</span> <span class="title">BlocBase</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Stream，如果ShoppingItemWidget是购物篮的一部分，则通知</span></span><br><span class="line">  BehaviorSubject&lt;<span class="built_in">bool</span>&gt; _isInShoppingBasketController = BehaviorSubject&lt;<span class="built_in">bool</span>&gt;();</span><br><span class="line">  Stream&lt;<span class="built_in">bool</span>&gt; <span class="keyword">get</span> isInShoppingBasket =&gt; _isInShoppingBasketController;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//收到所有商品列表的流，购物篮的一部分</span></span><br><span class="line">  PublishSubject&lt;<span class="built_in">List</span>&lt;ShoppingItem&gt;&gt; _shoppingBasketController = PublishSubject&lt;<span class="built_in">List</span>&lt;ShoppingItem&gt;&gt;();</span><br><span class="line">  <span class="built_in">Function</span>(<span class="built_in">List</span>&lt;ShoppingItem&gt;) <span class="keyword">get</span> shoppingBasket =&gt; _shoppingBasketController.sink.add;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//具有shoppingItem的“标识”的构造方法</span></span><br><span class="line">  ShoppingItemBloc(ShoppingItem shoppingItem)&#123;</span><br><span class="line">    <span class="comment">//每次购物篮内容的变化</span></span><br><span class="line">    _shoppingBasketController.stream</span><br><span class="line">                           <span class="comment">//我们检查这个shoppingItem是否是购物篮的一部分</span></span><br><span class="line">                         .map((list) =&gt; list.any((ShoppingItem item) =&gt; item.id == shoppingItem.id))</span><br><span class="line">                          <span class="comment">// if it is part</span></span><br><span class="line">                         .listen((isInShoppingBasket)</span><br><span class="line">                              <span class="comment">// we notify the ShoppingItemWidget </span></span><br><span class="line">                            =&gt; _isInShoppingBasketController.add(isInShoppingBasket));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _isInShoppingBasketController?.close();</span><br><span class="line">    _shoppingBasketController?.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-4-2。ShoppingItemWidget"><a href="#5-4-2。ShoppingItemWidget" class="headerlink" title="5.4.2。ShoppingItemWidget"></a>5.4.2。ShoppingItemWidget</h5><p>此Widget负责：</p><blockquote><ul><li>创建ShoppingItemBloc的实例并将其自己的标识传递给BLoC</li><li>监听ShoppingBasket内容的任何变化并将其转移到BLoC</li><li>监听ShoppingItemBloc知道它是否是篮子的一部分</li><li>显示相应的按钮（添加/删除），具体取决于它在篮子中的存在</li><li>响应按钮的用户操作<br>当用户点击添加按钮时，将自己添加到购物篮中<br>当用户点击删除按钮时，将自己从篮子中移除。</li></ul></blockquote><p>让我们看看它是如何工作的（解释在代码中给出）。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingItemWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  ShoppingItemWidget(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.shoppingItem,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> ShoppingItem shoppingItem;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _ShoppingItemWidgetState createState() =&gt; _ShoppingItemWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ShoppingItemWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ShoppingItemWidget</span>&gt; </span>&#123;</span><br><span class="line">  StreamSubscription _subscription;</span><br><span class="line">  ShoppingItemBloc _bloc;</span><br><span class="line">  ShoppingBloc _shoppingBloc;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didChangeDependencies() &#123;</span><br><span class="line">    <span class="keyword">super</span>.didChangeDependencies();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于不应在“initState（）”方法中使用上下文，</span></span><br><span class="line">    <span class="comment">//在需要时更喜欢使用“didChangeDependencies（）”</span></span><br><span class="line">    <span class="comment">//在初始化时引用上下文</span></span><br><span class="line">    _initBloc();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didUpdateWidget(ShoppingItemWidget oldWidget) &#123;</span><br><span class="line">    <span class="keyword">super</span>.didUpdateWidget(oldWidget);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为Flutter可能决定重新组织Widgets树</span></span><br><span class="line">    <span class="comment">//最好重新创建链接</span></span><br><span class="line">    _disposeBloc();</span><br><span class="line">    _initBloc();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _disposeBloc();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//这个例程对于创建链接是可靠的</span></span><br><span class="line">  <span class="keyword">void</span> _initBloc() &#123;</span><br><span class="line">    <span class="comment">//创建ShoppingItemBloc的实例</span></span><br><span class="line">    _bloc = ShoppingItemBloc(widget.shoppingItem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检索处理购物篮内容的BLoC </span></span><br><span class="line">    _shoppingBloc = BlocProvider.of&lt;ShoppingBloc&gt;(context);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//传输购物内容的简单管道</span></span><br><span class="line">    <span class="comment">//购物篮子到ShoppingItemBloc</span></span><br><span class="line">    _subscription = _shoppingBloc.shoppingBasket.listen(_bloc.shoppingBasket);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _disposeBloc() &#123;</span><br><span class="line">    _subscription?.cancel();</span><br><span class="line">    _bloc?.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget _buildButton() &#123;</span><br><span class="line">    <span class="keyword">return</span> StreamBuilder&lt;<span class="built_in">bool</span>&gt;(</span><br><span class="line">      stream: _bloc.isInShoppingBasket,</span><br><span class="line">      initialData: <span class="keyword">false</span>,</span><br><span class="line">      builder: (BuildContext context, AsyncSnapshot&lt;<span class="built_in">bool</span>&gt; snapshot) &#123;</span><br><span class="line">        <span class="keyword">return</span> snapshot.data</span><br><span class="line">            ? _buildRemoveFromShoppingBasket()</span><br><span class="line">            : _buildAddToShoppingBasket();</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget _buildAddToShoppingBasket()&#123;</span><br><span class="line">    <span class="keyword">return</span> RaisedButton(</span><br><span class="line">      child: Text(<span class="string">'Add...'</span>),</span><br><span class="line">      onPressed: ()&#123;</span><br><span class="line">        _shoppingBloc.addToShoppingBasket(widget.shoppingItem);</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget _buildRemoveFromShoppingBasket()&#123;</span><br><span class="line">    <span class="keyword">return</span> RaisedButton(</span><br><span class="line">      child: Text(<span class="string">'Remove...'</span>),</span><br><span class="line">      onPressed: ()&#123;</span><br><span class="line">        _shoppingBloc.removeFromShoppingBasket(widget.shoppingItem);</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Card(</span><br><span class="line">      child: GridTile(</span><br><span class="line">        header: Center(</span><br><span class="line">          child: Text(widget.shoppingItem.title),</span><br><span class="line">        ),</span><br><span class="line">        footer: Center(</span><br><span class="line">          child: Text(<span class="string">'<span class="subst">$&#123;widget.shoppingItem.price&#125;</span> €'</span>),</span><br><span class="line">        ),</span><br><span class="line">        child: Container(</span><br><span class="line">          color: widget.shoppingItem.color,</span><br><span class="line">          child: Center(</span><br><span class="line">            child: _buildButton(),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-5-这一切如何运作？"><a href="#5-5-这一切如何运作？" class="headerlink" title="5.5. 这一切如何运作？"></a>5.5. 这一切如何运作？</h4><p>下图显示了所有部分如何协同工作。</p><p><img src="https://upload-images.jianshu.io/upload_images/699599-416d1c66459d817e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>另一篇长篇文章，我希望我能缩短一点，但我认为值得一些解释。</p><p>正如我在介绍中所说，我个人在我的开发中经常使用这些“ 模式 ”。这让我节省了大量的时间和精力; 我的代码更易读，更容易调试。</p><p>此外，它有助于将业务与视图分离。</p><p>大多数肯定有其他方法可以做到这一点，甚至更好的方式，但它只对我有用，这就是我想与你分享的一切。</p><p>请继续关注新文章，同时祝您编程愉快。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter-BLoC-第一讲</title>
      <link href="/2019/03/14/Flutter-BLoC-%E7%AC%AC%E4%B8%80%E8%AE%B2/"/>
      <url>/2019/03/14/Flutter-BLoC-%E7%AC%AC%E4%B8%80%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="【译文】Reactive-Programming-Streams-BLoC"><a href="#【译文】Reactive-Programming-Streams-BLoC" class="headerlink" title="【译文】Reactive Programming - Streams - BLoC"></a>【译文】Reactive Programming - Streams - BLoC</h1><p><strong>本译文介绍Streams、Bloc 和 Reactive Programming 的概念。理论和实践范例。对于作者的个人note没有进行翻译，请自行翻阅<a href="https://www.didierboelens.com/2018/08/reactive-programming---streams---bloc/" target="_blank" rel="noopener">原文地址</a> <a href="https://github.com/boeledi/Streams-Block-Reactive-Programming-in-Flutter" target="_blank" rel="noopener">原文原码</a>。和iOS开发中的RAC相似，本文推荐重点在 &lt;如何基于流出的数据构建Widge&gt;！</strong></p><p><strong>难度：中级</strong></p><h3 id="本文纪实"><a href="#本文纪实" class="headerlink" title="本文纪实"></a>本文纪实</h3><blockquote><p>本译文的原文是在学 BLoC 的 <a href="https://felangel.github.io/bloc/#/flutterweathertutorial?id=dynamic-theming" target="_blank" rel="noopener">第三方框架</a> (<a href="https://felangel.github.io/bloc/#/flutterweathertutorial?id=dynamic-theming" target="_blank" rel="noopener">框架的教程</a>)而看到的推荐链接进入该文章，为了更好的实现Flutter的BLoC而进行的翻译学习，翻译完也到了文章底部竟然有推荐中文翻译 <a href="https://www.jianshu.com/p/e7e1bced6890" target="_blank" rel="noopener">链接</a>， 那本篇就孤芳自赏吧！也顺便记录下自己的第一篇国外技术译文吧！推荐读者结合<a href="https://www.didierboelens.com/2018/08/reactive-programming---streams---bloc/" target="_blank" rel="noopener">原文</a>  看译文效果会更佳。<br>笔者本文学习目的： 解耦</p></blockquote><h3 id="什么是流？"><a href="#什么是流？" class="headerlink" title="什么是流？"></a>什么是流？</h3><blockquote><p><strong>介绍</strong> :为了便于想象Stream的概念，只需考虑一个带有两端的管道，只有一个允许在其中插入一些东西。当你将某物插入管道时，它会在管道内流动并从另一端流出。</p></blockquote><p>在Flutter中</p><blockquote><ul><li>管道称为 <strong>Stream</strong></li><li>通常(*)使用StreamController来控制Stream</li><li>为了插入东西到Stream中，StreamController公开了”入口”名为StreamSink，可以sink属性进行访问你</li><li>StreamController通过stream属性公开了Stream的出口</li></ul></blockquote><p><strong>注意：</strong>  (*)：我故意使用术语”通常”，因为很可能不使用任何StreamController。但是，正如你将在本文中阅读的那样，我将只使用StreamControllers。</p><h4 id="Stream可以传递什么？"><a href="#Stream可以传递什么？" class="headerlink" title="Stream可以传递什么？"></a>Stream可以传递什么？</h4><p>所有类型值都可以通过流传递。从值，事件，对象，集合，映射，错误或甚至另一个流，可以由stream传达任何类型的数据。</p><h4 id="我怎么知道Stream传递的东西？"><a href="#我怎么知道Stream传递的东西？" class="headerlink" title="我怎么知道Stream传递的东西？"></a>我怎么知道Stream传递的东西？</h4><p>当你需要通知Stream传达某些内容时，你只需要监听<strong>StreamController</strong> 的<strong>stream</strong>属性。</p><p>定义监听器时，你会收到<strong>StreamSubscription</strong>对象。通过StreamSubscription对象，你将收到由Stream发生变化而触发通知。</p><p>只要有至少一个活动 监听器，Stream就会开始生成事件，以便每次都通知活动的 StreamSubscription对象：</p><blockquote><ul><li>一些数据来自流，</li><li>当一些错误发送到流时，</li><li>当流关闭时。</li></ul></blockquote><p>StreamSubscription对象也可以允许以下操作：</p><blockquote><ul><li>停止听</li><li>暂停，</li><li>恢复。</li></ul></blockquote><h4 id="Stream只是一个简单的管道吗？"><a href="#Stream只是一个简单的管道吗？" class="headerlink" title="Stream只是一个简单的管道吗？"></a>Stream只是一个简单的管道吗？</h4><p>不，<strong>Stream</strong>还允许在流出之前处理流入其中的数据。</p><p>为了控制Stream内部数据的处理，我们使用<strong>StreamTransformer</strong>，它只是</p><blockquote><ul><li>一个“捕获” Stream内部流动数据的函数</li><li>对数据做一些处理</li><li>这种转变的结果也是一个<strong>Stream</strong></li></ul></blockquote><p>你将直接从该声明中了解到，可以按顺序使用多个StreamTransformer。</p><p>StreamTransformer可以用进行任何类型的处理，例如：</p><blockquote><ul><li>过滤(filtering)：根据任何类型的条件过滤数据，</li><li>重新组合(regrouping)：重新组合数据，</li><li>修改(modification)：对数据应用任何类型的修改，</li><li>将数据注入其他流，</li><li>缓冲，</li><li>处理(processing)：根据数据进行任何类型的操作/操作，</li><li>…</li></ul></blockquote><h4 id="Stream流的类型"><a href="#Stream流的类型" class="headerlink" title="Stream流的类型"></a>Stream流的类型</h4><blockquote><p><strong>Stream</strong>有两种类型。</p></blockquote><h5 id="单订阅Stream"><a href="#单订阅Stream" class="headerlink" title="单订阅Stream"></a>单订阅Stream</h5><p>这种类型的Stream只允许在该Stream的整个生命周期内使用单个监听器。</p><blockquote><p>即在第一个订阅被取消后，也无法在此类流上收听两次。</p></blockquote><h5 id="广播流"><a href="#广播流" class="headerlink" title="广播流"></a>广播流</h5><p>第二种类型的Stream允许任意数量的监听器。</p><blockquote><p>可以随时向广播流添加监听器。新的监听器将在它开始收听Stream时收到事件。</p></blockquote><h4 id="基本的例子"><a href="#基本的例子" class="headerlink" title="基本的例子"></a>基本的例子</h4><h5 id="任何类型的数据"><a href="#任何类型的数据" class="headerlink" title="任何类型的数据"></a>任何类型的数据</h5><p>第一个示例显示了“单订阅” 流，它只是打印输入的数据。你可能会看到无关紧要的数据类型。</p><p>streams_1.dart </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 初始化“单订阅”流控制器</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">final</span> StreamController ctrl = StreamController();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">   <span class="comment">//初始化一个只打印数据的监听器</span></span><br><span class="line">  <span class="comment">//一收到它</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">final</span> StreamSubscription subscription = ctrl.stream.listen((data) =&gt; <span class="built_in">print</span>(<span class="string">'<span class="subst">$data</span>'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 我们在这里添加将会流进Stream中的数据</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  ctrl.sink.add(<span class="string">'my name'</span>);</span><br><span class="line">  ctrl.sink.add(<span class="number">1234</span>);</span><br><span class="line">  ctrl.sink.add(&#123;<span class="string">'a'</span>: <span class="string">'element A'</span>, <span class="string">'b'</span>: <span class="string">'element B'</span>&#125;);</span><br><span class="line">  ctrl.sink.add(<span class="number">123.45</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 我们发布了StreamController</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  ctrl.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="StreamTransformer"><a href="#StreamTransformer" class="headerlink" title="StreamTransformer"></a>StreamTransformer</h5><p>第二个示例显示“ 广播 ” 流，它传达整数值并仅打印偶数。为此，我们应用StreamTransformer来过滤（第14行）值，只让偶数经过。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Initialize a "Broadcast" Stream controller of integers</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">final</span> StreamController&lt;<span class="built_in">int</span>&gt; ctrl = StreamController&lt;<span class="built_in">int</span>&gt;.broadcast();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Initialize a single listener which filters out the odd numbers and</span></span><br><span class="line">  <span class="comment">// only prints the even numbers</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">final</span> StreamSubscription subscription = ctrl.stream</span><br><span class="line">      .where((value) =&gt; (value % <span class="number">2</span> == <span class="number">0</span>))</span><br><span class="line">      .listen((value) =&gt; <span class="built_in">print</span>(<span class="string">'<span class="subst">$value</span>'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// We here add the data that will flow inside the stream</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;<span class="number">11</span>; i++)&#123;</span><br><span class="line">  ctrl.sink.add(i);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// We release the StreamController</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  ctrl.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="RxDart"><a href="#RxDart" class="headerlink" title="RxDart"></a>RxDart</h3><p>所述RxDart包是用于执行 Dart 所述的ReactiveX API，它扩展了原始达特流 API符合ReactiveX标准。<br>由于它最初并未由Google定义，因此它使用不同的词汇表。下表给出了Dart和RxDart之间的相关性。</p><table><thead><tr><th>Dart</th><th>RxDart</th></tr></thead><tbody><tr><td>Stream</td><td>Observable</td></tr><tr><td>StreamController</td><td>Subject</td></tr></tbody></table><p>正如刚才所说，RxDart 扩展了原始的Dart Streams API并提供了StreamController的 3个主要变体：</p><h4 id="PublishSubject"><a href="#PublishSubject" class="headerlink" title="PublishSubject"></a>PublishSubject</h4><blockquote><p>PublishSubject是普通的广播 StreamController， 有一个例外：Stream返回一个Observable，而不是Stream。<br><img src="https://upload-images.jianshu.io/upload_images/699599-317db649dd785a8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><blockquote><p>如你所见，PublishSubject仅向监听器发送在订阅之后添加到Stream的事件。</p></blockquote><h4 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h4><blockquote><p>该BehaviorSubject也是广播 StreamController，它返回一个<strong>Observable</strong>，而不是<strong>Stream</strong>。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/699599-ec883ab1dc660e96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>与PublishSubject的主要区别在于BehaviorSubject还将最后发送的事件发送给刚刚订阅的监听器。</p></blockquote><h4 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h4><blockquote><p><strong>ReplaySubject</strong> 也是一个广播StreamController，它返回一个Observable，而不是Stream。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/699599-374b541a5bca7819.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>默认情况下，<strong>ReplaySubject</strong>将<strong>Stream</strong>已经发出的所有事件作为第一个事件发送给任何新的监听器。</p><h4 id="关于资源的重要说明"><a href="#关于资源的重要说明" class="headerlink" title="关于资源的重要说明"></a>关于资源的重要说明</h4><blockquote><p>经常释放不再需要的资源是一种非常好的做法。<br>本声明适用于：</p><ul><li>StreamSubscription - 当你不再需要监听Stream时，取消订阅;</li><li>StreamController - 当你不再需要StreamController时，关闭它;</li><li>这同样适用于RxDart主题，当你不再需要BehaviourSubject，PublishSubject …时，请将其关闭。</li></ul></blockquote><h3 id="如何基于由Stream提供的数据构建Widget？（重点）"><a href="#如何基于由Stream提供的数据构建Widget？（重点）" class="headerlink" title="如何基于由Stream提供的数据构建Widget？（重点）"></a>如何基于由Stream提供的数据构建Widget？（重点）</h3><p>Flutter提供了一个非常方便的StatefulWidget，名为<strong>StreamBuilder</strong>。</p><p>StreamBuilder监听Stream，每当某些数据输出<strong>Stream</strong>时，它会自动重建，调用其builder callback。</p><p>这是如何使用StreamBuilder：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">StreamBuilder&lt;T&gt;(</span><br><span class="line">    key: ...optional, the unique ID of <span class="keyword">this</span> Widget...</span><br><span class="line">    stream: ...the stream to listen to...</span><br><span class="line">    initialData: ...any initial data, <span class="keyword">in</span> <span class="keyword">case</span> the stream would initially be empty...</span><br><span class="line">    builder: (BuildContext context, AsyncSnapshot&lt;T&gt; snapshot)&#123;</span><br><span class="line">        <span class="keyword">if</span> (snapshot.hasData)&#123;</span><br><span class="line">            <span class="keyword">return</span> ...the Widget to be built based on snapshot.data</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ...the Widget to be built <span class="keyword">if</span> no data <span class="keyword">is</span> available</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>以下示例模仿默认的 “计数器” 应用程序，但使用Stream而不再使用任何setState。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _CounterPageState createState() =&gt; _CounterPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_CounterPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">CounterPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">final</span> StreamController&lt;<span class="built_in">int</span>&gt; _streamController = StreamController&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    _streamController.close();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">'Stream version of the Counter App'</span>)),</span><br><span class="line">      body: Center(</span><br><span class="line">      <span class="comment">// 我们正在监听流，每次有一个新值流出这个流时，我们用该值更新Text ;</span></span><br><span class="line">        child: StreamBuilder&lt;<span class="built_in">int</span>&gt;(</span><br><span class="line">          stream: _streamController.stream,</span><br><span class="line">          initialData: _counter,</span><br><span class="line">          builder: (BuildContext context, AsyncSnapshot&lt;<span class="built_in">int</span>&gt; snapshot)&#123;</span><br><span class="line">            <span class="keyword">return</span> Text(<span class="string">'You hit me: <span class="subst">$&#123;snapshot.data&#125;</span> times'</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        child: <span class="keyword">const</span> Icon(Icons.add),</span><br><span class="line">        onPressed: ()&#123;</span><br><span class="line">        <span class="comment">//当我们点击FloatingActionButton时，增加计数器并通过sink将其发送到Stream；</span></span><br><span class="line">        <span class="comment">//事实上 注入到stream中值会导致监听它(stream)的StreamBuilder重建并 ‘刷新’计数器;</span></span><br><span class="line">          _streamController.sink.add(++_counter);</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h5><blockquote><ul><li>24-30行： 我们不再需要state的概念，所有东西都通过Stream接受;</li></ul><p>第35行：当我们点击FloatingActionButton时，我们递增计数器并通过接收器将其发送到Stream; 在流中注入值的事实导致侦听它的StreamBuilder重建并“刷新”计数器;</p><ul><li><p>这是一个很大的改进，因为实际调用setState（）方法的，会强制整个 Widget（和任何子小部件）重建。这里，只有StreamBuilder被重建（当然它的子部件，被streamBuilder包裹的子控件）;</p></li><li><p>我们仍然在为页面使用StatefulWidget的唯一原因，仅仅是因为我们需要通过dispose方法第15行释放StreamController ;</p></li></ul></blockquote><h4 id="什么是反应式编程？"><a href="#什么是反应式编程？" class="headerlink" title="什么是反应式编程？"></a>什么是反应式编程？</h4><blockquote><p><strong>反应式编程是使用异步数据流进行编程。</strong><br>换句话说，任何东西比如从事件（例如点击），变量的变化，消息，……到构建请求，可能改变或发生的所有事件的所有内容都将被传送，由数据流触发。</p></blockquote><h5 id="很明显，所有这些意味着，通过反应式编程，应用程序："><a href="#很明显，所有这些意味着，通过反应式编程，应用程序：" class="headerlink" title="很明显，所有这些意味着，通过反应式编程，应用程序："></a>很明显，所有这些意味着，通过反应式编程，应用程序：</h5><blockquote><ul><li>变得异步</li><li>围绕Streams和listeners的概念进行架构</li><li>当某事发生在某处（事件，变量的变化……）时，会向Stream发送通知</li><li>如果 “某人” 监听该流（无论其在应用程序中的任何位置），它将被通知并将采取适当的行动.</li></ul></blockquote><h5 id="组件之间不再存在紧密耦合。"><a href="#组件之间不再存在紧密耦合。" class="headerlink" title="组件之间不再存在紧密耦合。"></a>组件之间不再存在紧密耦合。</h5><blockquote><p>简而言之，当Widget向Stream发送内容时，该Widget 不再需要知道：</p><ul><li>接下来会发生什么</li><li>谁可能使用这些信息（没有一个，一个或几个小部件……）</li><li>可能使用此信息的地方（无处，同一屏幕，另一个，几个…）</li><li>当这些信息可能被使用时（几乎是直接，几秒钟之后，永远不会……）</li><li></li><li>…… Widget只关心自己的事业，就是这样！</li></ul></blockquote><h5 id="乍一看，读到这个，这似乎会导致应用程序“-无法控制-”，但正如我们将看到的，情况正好相反。它给你："><a href="#乍一看，读到这个，这似乎会导致应用程序“-无法控制-”，但正如我们将看到的，情况正好相反。它给你：" class="headerlink" title="乍一看，读到这个，这似乎会导致应用程序“ 无法控制 ”，但正如我们将看到的，情况正好相反。它给你："></a>乍一看，读到这个，这似乎会导致应用程序“ 无法控制 ”，但正如我们将看到的，情况正好相反。它给你：</h5><blockquote><ul><li>构建仅负责特定活动的部分应用程序的机会</li><li>轻松模拟一些组件的行为，以允许更完整的测试覆盖</li><li>轻松重用组件（当前应用程序或其他应用程序中的其他位置），</li><li>重新设计应用程序，并能够在不进行太多重构的情况下将组件从一个地方移动到另一个地方，</li></ul></blockquote><p>我们将很快看到优势……但在我需要介绍最后一个主题之前：BLoC模式。</p><hr><h3 id="BLoC-模式"><a href="#BLoC-模式" class="headerlink" title="BLoC 模式"></a>BLoC 模式</h3><blockquote><p>BLoC模式由Paolo Soares 和 Cong Hui设计，并谷歌在2018的 DartConf 首次提出，可以在  <a href="https://www.youtube.com/watch?v=PLHln7wHgPE" target="_blank" rel="noopener">YouTube</a> 上观看。</p></blockquote><p>BLoC表示为业务逻辑组件 (Business Logic Component)</p><p>简而言之， Business Logic需要：</p><blockquote><ul><li>转移到一个或几个BLoC，</li><li>尽可能从表示层(Presentation Layer)中删除。换句话说，UI组件应该只关心UI事物而不关心业务</li><li>依赖 Streams 独家使用输入（Sink）和输出（stream）</li><li>保持平台独立</li><li>保持环境独立</li></ul></blockquote><p>事实上，BLoC模式最初被设想为允许独立于平台重用相同的代码：Web应用程序，移动应用程序，后端。</p><h4 id="它究竟意味着什么？"><a href="#它究竟意味着什么？" class="headerlink" title="它究竟意味着什么？"></a>它究竟意味着什么？</h4><blockquote><p>BLoC模式 是利用我们刚才上面所讨论的观念：<strong>Streams</strong> （流）</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/699599-2924b4cd35807a27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><ul><li>Widgets 通过 Sinks 向 BLoC 发送事件(event)</li><li>BLoC 通过流(stream)通知小部件(widgets)</li><li>由BLoC实现的业务逻辑不是他们关注的问题。</li></ul></blockquote><h5 id="从这个声明中，我们可以直接看到一个巨大的好处。"><a href="#从这个声明中，我们可以直接看到一个巨大的好处。" class="headerlink" title="从这个声明中，我们可以直接看到一个巨大的好处。"></a>从这个声明中，我们可以直接看到一个巨大的好处。</h5><blockquote><p>由于业务逻辑与UI的分离：</p><ul><li>我们可以随时更改业务逻辑，对应用程序的影响最小</li><li>我们可能会更改UI而不会对业务逻辑产生任何影响，</li><li>现在，测试业务逻辑变得更加容易。</li></ul></blockquote><h5 id="如何将此-BLoC-模式应用于-Counter-应用程序示例中"><a href="#如何将此-BLoC-模式应用于-Counter-应用程序示例中" class="headerlink" title="如何将此 BLoC 模式应用于 Counter 应用程序示例中"></a>如何将此 BLoC 模式应用于 Counter 应用程序示例中</h5><p>将 BLoC 模式应用于此计数器应用程序似乎有点矫枉过正，但让我先向你展示……</p><p>代码： streams_4.dart</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(<span class="keyword">new</span> MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">        title: <span class="string">'Streams Demo'</span>,</span><br><span class="line">        theme: <span class="keyword">new</span> ThemeData(</span><br><span class="line">          primarySwatch: Colors.blue,</span><br><span class="line">        ),</span><br><span class="line">        home: BlocProvider&lt;IncrementBloc&gt;(</span><br><span class="line">          bloc: IncrementBloc(),</span><br><span class="line">          child: CounterPage(),</span><br><span class="line">        ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> IncrementBloc bloc = BlocProvider.of&lt;IncrementBloc&gt;(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">'Stream version of the Counter App'</span>)),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: StreamBuilder&lt;<span class="built_in">int</span>&gt;(</span><br><span class="line">          stream: bloc.outCounter,</span><br><span class="line">          initialData: <span class="number">0</span>,</span><br><span class="line">          builder: (BuildContext context, AsyncSnapshot&lt;<span class="built_in">int</span>&gt; snapshot)&#123;</span><br><span class="line">            <span class="keyword">return</span> Text(<span class="string">'You hit me: <span class="subst">$&#123;snapshot.data&#125;</span> times'</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        child: <span class="keyword">const</span> Icon(Icons.add),</span><br><span class="line">        onPressed: ()&#123;</span><br><span class="line">          bloc.incrementCounter.add(<span class="keyword">null</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncrementBloc</span> <span class="keyword">implements</span> <span class="title">BlocBase</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Stream来处理计数器</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  StreamController&lt;<span class="built_in">int</span>&gt; _counterController = StreamController&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">  StreamSink&lt;<span class="built_in">int</span>&gt; <span class="keyword">get</span> _inAdd =&gt; _counterController.sink;</span><br><span class="line">  Stream&lt;<span class="built_in">int</span>&gt; <span class="keyword">get</span> outCounter =&gt; _counterController.stream;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Stream来处理计数器上的操作</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  StreamController _actionController = StreamController();</span><br><span class="line">  StreamSink <span class="keyword">get</span> incrementCounter =&gt; _actionController.sink;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Constructor</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  IncrementBloc()&#123;</span><br><span class="line">    _counter = <span class="number">0</span>;</span><br><span class="line">    _actionController.stream</span><br><span class="line">                     .listen(_handleLogic);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    _actionController.close();</span><br><span class="line">    _counterController.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleLogic(data)&#123;</span><br><span class="line">    _counter = _counter + <span class="number">1</span>;</span><br><span class="line">    _inAdd.add(_counter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我已经听到你说“ 哇……为什么这一切？这都是必要的吗？”。</p><h6 id="第一-是责任分离"><a href="#第一-是责任分离" class="headerlink" title="第一 是责任分离"></a>第一 是责任分离</h6><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如果你检查CounterPage（第<span class="number">21</span><span class="number">-45</span>行），其中绝对没有任何业务逻辑。</span><br><span class="line"></span><br><span class="line">此页面现在仅负责：</span><br><span class="line"></span><br><span class="line">&gt; * 显示计数器，现在只在必要时刷新（即使没有页面必须知道它）</span><br><span class="line">&gt; * 提供按钮，当按下时，将会在counter面板上请求一个动作</span><br><span class="line"></span><br><span class="line">此外，整个业务逻辑集中在一个单独的类“ IncrementBloc”中。</span><br><span class="line"></span><br><span class="line">如果现在，你需要更改业务逻辑，你只需更新方法_handleLogic（第<span class="number">77</span><span class="number">-80</span>行）。也许新的业务逻辑将要求做非常复杂的事情...... CounterPage永远不会知道它，这是非常好的！</span><br></pre></td></tr></table></figure><h6 id="第二-可测试性"><a href="#第二-可测试性" class="headerlink" title="第二 可测试性"></a>第二 可测试性</h6><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">现在，测试业务逻辑变得更加容易。</span><br><span class="line"></span><br><span class="line">无需再通过用户界面测试业务逻辑。只需要测试IncrementBloc类。</span><br></pre></td></tr></table></figure><h6 id="第三-自由组织布局"><a href="#第三-自由组织布局" class="headerlink" title="第三 自由组织布局"></a>第三 自由组织布局</h6><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">由于使用了Streams，你现在可以独立于业务逻辑组织布局。</span><br><span class="line"></span><br><span class="line">可以从应用程序中的任何位置启动任何操作：只需调用.incrementCounter sink即可。</span><br><span class="line"></span><br><span class="line">你可以在任何页面的任何位置显示计数器，只需听取.outCounter stream。</span><br></pre></td></tr></table></figure><h6 id="第四-减少“build”的次数"><a href="#第四-减少“build”的次数" class="headerlink" title="第四 减少“build”的次数"></a>第四 减少“build”的次数</h6><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不使用setState（）而是使用StreamBuilder这一事实大大减少了“ 构建 ”的次数，只减少了所需的次数。</span><br><span class="line"></span><br><span class="line">从性能角度来看，这是一个巨大的进步。</span><br></pre></td></tr></table></figure><h5 id="只有一个约束……-BLoC的可访问性"><a href="#只有一个约束……-BLoC的可访问性" class="headerlink" title="只有一个约束…… BLoC的可访问性"></a>只有一个约束…… BLoC的可访问性</h5><p>为了让所有这些工作，BLoC需要可访问。</p><blockquote><p>有几种方法可以访问它：</p><ul><li><p>通过全局单例<br>这种方式很有简单，但不是真的推荐。此外，由于Dart中没有类析构函数，因此你永远无法正确释放资源。</p></li><li><p>作为局部变量(本地实例)<br>你可以实例化BLoC的本地实例。在某些情况下，此解决方案完全符合某些需求。在这种情况下，你应该始终考虑在StatefulWidget中初始化，以便你可以利用dispose（）方法来释放它。</p><ul><li>由父类提供<br>使其可访问的最常见方式是通过祖先 Widget，实现为StatefulWidget。</li></ul></li></ul></blockquote><h5 id="以下代码显示了通用-BlocProvider的示例。"><a href="#以下代码显示了通用-BlocProvider的示例。" class="headerlink" title="以下代码显示了通用 BlocProvider的示例。"></a>以下代码显示了通用 BlocProvider的示例。</h5><p>代码： streams_5</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所有BLoC的通用接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BlocBase</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> dispose();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通用BLoC提供商</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlocProvider</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">BlocBase</span>&gt; <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  BlocProvider(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.child,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.bloc,</span><br><span class="line">  &#125;): <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> T bloc;</span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _BlocProviderState&lt;T&gt; createState() =&gt; _BlocProviderState&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> T of&lt;T <span class="keyword">extends</span> BlocBase&gt;(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">final</span> type = _typeOf&lt;BlocProvider&lt;T&gt;&gt;();</span><br><span class="line">    BlocProvider&lt;T&gt; provider = context.ancestorWidgetOfExactType(type);</span><br><span class="line">    <span class="keyword">return</span> provider.bloc;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">Type</span> _typeOf&lt;T&gt;() =&gt; T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_BlocProviderState</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">BlocProvider</span>&lt;<span class="title">BlocBase</span>&gt;&gt;</span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line"> <span class="comment">/// 便于资源的释放</span></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    widget.bloc.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> widget.child;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="关于这种通用BlocProvider的一些解释"><a href="#关于这种通用BlocProvider的一些解释" class="headerlink" title="关于这种通用BlocProvider的一些解释"></a>关于这种通用BlocProvider的一些解释</h5><p>首先，如何将其作为provider使用？</p><p>如果你查看示例代码“ streams_4.dart ”，你将看到以下代码行（第12-15行）</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">home: BlocProvider&lt;IncrementBloc&gt;(</span><br><span class="line">          bloc: IncrementBloc(),</span><br><span class="line">          child: CounterPage(),</span><br><span class="line">        ),</span><br></pre></td></tr></table></figure><p>通过这些代码，我们只需实例化一个新的BlocProvider，它将处理一个IncrementBloc，并将CounterPage作为子项呈现。</p><p>从那一刻开始，从BlocProvider开始的子树的任何小部件部分都将能够通过以下代码访问IncrementBloc：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IncrementBloc bloc = BlocProvider.of&lt;IncrementBloc&gt;(context);</span><br></pre></td></tr></table></figure><h5 id="可以使用多个BLoC吗？"><a href="#可以使用多个BLoC吗？" class="headerlink" title="可以使用多个BLoC吗？"></a>可以使用多个BLoC吗？</h5><blockquote><p>当然，这是非常可取的。建议是：</p></blockquote><blockquote><ul><li>（如果有任何业务逻辑）每页顶部有一个BLoC，</li><li>为什么不是ApplicationBloc来处理应用程序状态？</li><li>每个“足够复杂的组件”都有相应的BLoC。</li></ul></blockquote><p>以下示例代码在整个应用程序的顶部显示ApplicationBloc，然后在CounterPage顶部显示IncrementBloc。</p><p>该示例还显示了如何检索两个blocs。</p><p>代码 streams_6.dart </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(</span><br><span class="line">  BlocProvider&lt;ApplicationBloc&gt;(</span><br><span class="line">    bloc: ApplicationBloc(),</span><br><span class="line">    child: MyApp(),</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Streams Demo'</span>,</span><br><span class="line">      home: BlocProvider&lt;IncrementBloc&gt;(</span><br><span class="line">        bloc: IncrementBloc(),</span><br><span class="line">        child: CounterPage(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">final</span> IncrementBloc counterBloc = BlocProvider.of&lt;IncrementBloc&gt;(context);</span><br><span class="line">    <span class="keyword">final</span> ApplicationBloc appBloc = BlocProvider.of&lt;ApplicationBloc&gt;(context);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="为什么不使用InheritedWidget？"><a href="#为什么不使用InheritedWidget？" class="headerlink" title="为什么不使用InheritedWidget？"></a>为什么不使用InheritedWidget？</h5><p>在与BLoC相关的大多数文章中，你会看到通过InheritedWidget实现Provider。</p><blockquote><p>当然，没有什么能阻止这种类型的实现。然而，</p><ul><li>一个InheritedWidget没有提供任何dispose方法，记住，在不再需要资源时总是释放资源是一个很好的做法。</li><li>当然，没有什么能阻止你将InheritedWidget包装在另一个StatefulWidget中，但是，使用 <strong>InheritedWidget</strong> 增加了什么呢？</li><li>最后，如果不受控制，使用InheritedWidget经常会导致副作用（请参阅下面的InheritedWidget上的提醒）。</li></ul></blockquote><p>以上三点解释了我为什么选择通过StatefulWidget实现BlocProvider，这样做可以让我在Widget dispose时释放相关资源。</p><blockquote><p><strong>Flutter无法实例化泛型类型</strong><br>不幸的是，Flutter无法实例化泛型类型，我们必须将BLoC的实例传递给BlocProvider。为了在每个BLoC中强制执行dispose()方法，所有BLoC都必须实现BlocBase接口。</p></blockquote><h5 id="提醒InheritedWidget"><a href="#提醒InheritedWidget" class="headerlink" title="提醒InheritedWidget"></a>提醒InheritedWidget</h5><p>在使用InheritedWidget并通过context.inheritFromWidgetOfExactType（…）来获得指定类型最近的widget, 每次InheritedWidget的父级或者子布局发生变化时，这个方法会自动将当前“context”（= BuildContext）注册到要重建的widget当中。。</p><blockquote><p>请注意，为了完全正确，我刚才解释的与InheritedWidget相关的问题只发生在我们将InheritedWidget与StatefulWidget结合使用时。当你只使用没有State的InheritedWidget时，问题就不会发生。但是……我将在<a href="https://www.didierboelens.com/2018/12/reactive-programming---streams---bloc---practical-use-cases/" target="_blank" rel="noopener">下一篇文章</a> 中回到这句话。</p></blockquote><p>链接到BuildContext的Widget类型（Stateful或Stateless）无关紧要。</p><h5 id="关于BLoC的个人建议"><a href="#关于BLoC的个人建议" class="headerlink" title="关于BLoC的个人建议"></a>关于BLoC的个人建议</h5><p>与BLoC相关的第三条规则是：“依赖于Streams的输入（Sink）和输出（stream）的使用优势”。</p><p>我的个人经历稍微关系到这个说法……让我解释一下。</p><p>首先，BLoC模式被设想为跨平台共享相同的代码（AngularDart，……），并且从这个角度来看，该陈述完全有意义。</p><p>但是，如果你只打算开发一个Flutter应用程序，这是基于我的谦逊经验，有点矫枉过正。</p><p>如果我们坚持声明，没有可能的getter或setter，只有sink和stream。缺点是“所有这些都是异步的”。</p><p>让我们用2个样本来说明缺点：</p><p>你需要从BLoC中检索一些数据，以便将这些数据用作应该立即显示这些参数的页面的输入（例如，想一个参数页面），如果我们不得不依赖Streams，这使得页面的构建异步（这很复杂）。通过Streams使其工作的示例代码可能如下所示……很丑陋不是吗。</p><p><a href="https://gist.github.com/boeledi/4e802d0b28dffdc4c7a40cb8ba37f295#file-streams_7-dart" target="_blank" rel="noopener">代码 streams_7.dart </a>如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FiltersPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  FiltersPageState createState() =&gt; FiltersPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FiltersPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">FiltersPage</span>&gt; </span>&#123;</span><br><span class="line">  MovieCatalogBloc _movieBloc;</span><br><span class="line">  <span class="built_in">double</span> _minReleaseDate;</span><br><span class="line">  <span class="built_in">double</span> _maxReleaseDate;</span><br><span class="line">  MovieGenre _movieGenre;</span><br><span class="line">  <span class="built_in">bool</span> _isInit = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didChangeDependencies() &#123;</span><br><span class="line">    <span class="keyword">super</span>.didChangeDependencies();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 作为initState（）级别尚未提供的上下文，如果尚未初始化，我们将获得过滤器参数列表</span></span><br><span class="line">    <span class="keyword">if</span> (_isInit == <span class="keyword">false</span>)&#123;</span><br><span class="line">      _movieBloc = BlocProvider.of&lt;MovieCatalogBloc&gt;(context);</span><br><span class="line">      _getFilterParameters();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> _isInit == <span class="keyword">false</span></span><br><span class="line">      ? Container()</span><br><span class="line">      : Scaffold(</span><br><span class="line">    ...</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// 非常棘手.</span></span><br><span class="line">  <span class="comment">/// </span></span><br><span class="line">  <span class="comment">/// 由于我们希望100％符合BLoC标准，我们需要使用Streams从BLoCs中检索所有内容......</span></span><br><span class="line">  <span class="comment">/// </span></span><br><span class="line">  <span class="comment">/// 这很难看，但被视为一个研究案例。</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="keyword">void</span> _getFilterParameters() &#123;</span><br><span class="line">    StreamSubscription subscriptionFilters;</span><br><span class="line"></span><br><span class="line">    subscriptionFilters = _movieBloc.outFilters.listen((MovieFilters filters) &#123;</span><br><span class="line">        _minReleaseDate = filters.minReleaseDate.toDouble();</span><br><span class="line">        _maxReleaseDate = filters.maxReleaseDate.toDouble();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只需确保订阅已发布</span></span><br><span class="line">        subscriptionFilters.cancel();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 现在我们有了所有参数，我们可以构建实际的页面</span></span><br><span class="line">        <span class="keyword">if</span> (mounted)&#123;</span><br><span class="line">          setState(()&#123;</span><br><span class="line">            _isInit = <span class="keyword">true</span>;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在BLoC级别，您还需要转换某些数据的“假”注入，以触发提供您希望通过流接收的数据。使这项工作的示例代码可以是：</p><p><a href="https://gist.github.com/boeledi/2ca3880d69eead1b81ec5f06a2f16518#file-streams_8-dart" target="_blank" rel="noopener">代码streams_8.dart</a></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationBloc</span> <span class="keyword">implements</span> <span class="title">BlocBase</span> </span>&#123;</span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// 同步流来处理提供的电影类型</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  StreamController&lt;<span class="built_in">List</span>&lt;MovieGenre&gt;&gt; _syncController = StreamController&lt;<span class="built_in">List</span>&lt;MovieGenre&gt;&gt;.broadcast();</span><br><span class="line">  Stream&lt;<span class="built_in">List</span>&lt;MovieGenre&gt;&gt; <span class="keyword">get</span> outMovieGenres =&gt; _syncController.stream;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// 流处理假命令以通过Stream触发提供MovieGenres列表</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  StreamController&lt;<span class="built_in">List</span>&lt;MovieGenre&gt;&gt; _cmdController = StreamController&lt;<span class="built_in">List</span>&lt;MovieGenre&gt;&gt;.broadcast();</span><br><span class="line">  StreamSink <span class="keyword">get</span> getMovieGenres =&gt; _cmdController.sink;</span><br><span class="line"></span><br><span class="line">  ApplicationBloc() &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 如果我们通过此接收器接收任何数据，我们只需将MovieGenre列表提供给输出流</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    _cmdController.stream.listen((_)&#123;</span><br><span class="line">      _syncController.sink.add(UnmodifiableListView&lt;MovieGenre&gt;(_genresList.genres));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    _syncController.close();</span><br><span class="line">    _cmdController.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MovieGenresList _genresList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example of external call</span></span><br><span class="line">BlocProvider.of&lt;ApplicationBloc&gt;(context).getMovieGenres.add(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>我不知道你的意见，但就个人而言，如果我没有任何与代码移植/共享相关的限制，我发现这太重了，我宁愿在需要时使用常规的getter / setter并使用Streams / Sinks来保持分离责任并在需要的地方广播信息，这很棒。</p><h5 id="现在是时候在实践中看到这一切……"><a href="#现在是时候在实践中看到这一切……" class="headerlink" title="现在是时候在实践中看到这一切……"></a>现在是时候在实践中看到这一切……</h5><p>正如本文开头所提到的，我构建了一个伪应用程序来展示如何使用所有这些概念。 完整的源代码可以在 <a href="https://github.com/boeledi/Streams-Block-Reactive-Programming-in-Flutter" target="_blank" rel="noopener">Github</a> 上找到。</p><p>请谅解，因为这段代码远非完美，可能更好和/或更好的架构，但唯一的目标只是向您展示这一切是如何工作的。</p><p>由于源代码太多很多，我只会解释主要的几条。</p><h6 id="电影目录的来源"><a href="#电影目录的来源" class="headerlink" title="电影目录的来源"></a>电影目录的来源</h6><p>我使用免费的<a href="https://www.themoviedb.org/documentation/api" target="_blank" rel="noopener">TMDB API</a>来获取所有电影的列表，以及海报，评级和描述。</p><p>为了能够运行此示例应用程序，您需要注册并获取API密钥（完全免费），然后将您的API密钥放在文件“/api/tmdb_api.dart”第15行。</p><p>应用程序的架构如下：</p><p>该应用程序使用到了：</p><blockquote><p><strong>3个主要的BLoC：</strong></p><ul><li><ol><li>ApplicationBloc（在所有内容之上），负责提供所有电影类型的列表;</li></ol></li><li>2.FavoriteBloc（就在下面），负责处理“收藏夹”的概念;</li><li>3.MovieCatalogBloc（在2个主要页面之上），负责根据过滤器提供电影列表;</li></ul></blockquote><blockquote><p><strong>6个页面：</strong></p><ul><li>1.HomePage：登陆页面，允许导航到3个子页面;</li><li>2.ListPage：将电影列为GridView的页面，允许过滤，收藏夹选择，访问收藏夹以及在后续页面中显示电影详细信息;</li><li>3.ListOnePage：类似于ListPage，但电影列表显示为水平列表，下面是详细信息;</li><li><ol start="4"><li>FavoritesPage：列出收藏夹的页面，允许取消选择任何收藏夹;</li></ol></li><li>5.* Filters：允许定义过滤器的EndDrawer：流派和最小/最大发布日期。从ListPage或ListOnePage调用此页面;</li></ul><ol start="6"><li>Details*详细信息：页面仅由ListPage调用以显示电影的详细信息，但也允许选择/取消选择电影作为收藏;</li></ol></blockquote><blockquote><p> <strong>1个子BLoC:</strong></p><ul><li>1.FavoriteMovieBloc，链接到MovieCardWidget或MovieDetailsWidget，以处理作为收藏的电影的选择/取消选择</li></ul></blockquote><blockquote><p> <strong>5个主要Widget：</strong></p><ul><li>1.FavoriteButton：负责显示收藏夹的数量，实时，并在按下时重定向到FavoritesPage;</li><li>2.FavoriteWidget：负责显示一个喜欢的电影的细节并允许其取消选择;</li><li>3.FiltersSummary：负责显示当前定义的过滤器;</li><li>4.MovieCardWidget：负责将一部电影显示为卡片，电影海报，评级和名称，以及一个图标，表示该特定电影的选择是最喜欢的;</li><li>5.MovieDetailsWidget：负责显示与特定电影相关的详细信息，并允许其选择/取消选择作为收藏。</li></ul></blockquote><h6 id="不同BLoCs-Streams的编排"><a href="#不同BLoCs-Streams的编排" class="headerlink" title="不同BLoCs / Streams的编排"></a>不同BLoCs / Streams的编排</h6><p>下图显示了如何使用主要3个BLoC：</p><blockquote><ul><li>在BLoC的左侧，哪些组件调用Sink</li><li>在右侧，哪些组件监听流</li></ul></blockquote><p>例如，当MovieDetailsWidget调用inAddFavorite Sink时，会触发2个stream：</p><blockquote><ul><li>outTotalFavorites流强制重建FavoriteButton </li><li>outFavorites流<br>强制重建MovieDetailsWidget（“最喜欢的”图标）<br>强制重建_buildMoieCard（“最喜欢的”图标）<br>用于构建每个MovieDetailsWidget</li></ul></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/699599-0c134afe157126d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h5 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h5><p>大多数Widget和Page都是StatelessWidgets，这意味着：</p><blockquote><ul><li>强制重建的setState()几乎从未使用过。 例外情况是：<br>在ListOnePage中,当用户点击MovieCard时，刷新MovieDetailsWidget。 这也可能是由一个stream驱动的……<br>在FiltersPage中允许用户在接受筛选条件之前通过Sink更改过筛选条件。</li><li>应用程序不使用任何InheritedWidget</li><li>该应用程序几乎是100％BLoCs / Streams驱动，这意味着大多数小部件彼此独立，并且它们在应用程序中的位置</li></ul></blockquote><p>一个实际的例子是FavoriteButton，它显示徽章中所选收藏夹的数量。 该应用程序共有3个FavoriteButton实例，每个实例显示在3个不同的页面中。</p><h5 id="显示电影列表（显示无限列表的技巧说明）"><a href="#显示电影列表（显示无限列表的技巧说明）" class="headerlink" title="显示电影列表（显示无限列表的技巧说明）"></a>显示电影列表（显示无限列表的技巧说明）</h5><p>要显示符合过滤条件的电影列表，我们使用GridView.builder（ListPage）或ListView.builder（ListOnePage）作为无限滚动列表。</p><p>电影是通过TMDB API获取的，每次拉取20个。</p><p>提醒一下，GridView.builder和ListView.builder都将itemCount作为输入，如果提供了item数量，则表示要根据itemCount的数量来显示列表。itemBuilder的index从0到itemCount - 1不等。</p><p>正如您将在代码中看到的那样，我随意为GridView.builder添加了30多个。 理由是，在这个例子中，我们正在操纵假定的无限数量的项目（这不是完全正确但是又有谁关心这个例子）。 这将强制GridView.builder请求显示“最多30个”项目。</p><p>此外，GridView.builder和ListView.builder只在认为必须在视口中呈现某个项目（索引）时才调用itemBuilder。</p><p>MovieCatalogBloc.outMoviesList返回一个List <moviecard>，它被迭代以构建每个Movie Card。 第一次，这个List <moviecard>是空的，但是由于itemCount：… + 30，我们欺骗系统，它将要求通过_buildMovieCard（…）呈现30个不存在的项目。</moviecard></moviecard></p><p>正如您将在代码中看到的，此例程对Sink进行了一次奇怪的调用：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通知MovieCatalogBloc我们正在渲染MovieCard[index]</span></span><br><span class="line">movieBloc.inMovieIndex.add(index);</span><br></pre></td></tr></table></figure><p>这个调用告诉MovieCatalogBloc我们要渲染MovieCard [index]。</p><p>然后_buildMovieCard(…)继续验证与MovieCard [index]相关的数据是否存在。 如果是，则渲染后者，否则显示CircularProgressIndicator。</p><p>对StreamCatalogBloc.inMovieIndex.add(index)的调用由StreamSubscription监听，StreamSubscription将索引转换为某个pageIndex数字（一页最多可计20部电影）。 如果尚未从TMDB API获取相应页面，则会调用API。 获取页面后，所有已获取电影的新列表将发送到_moviesController。 当GridView.builder监听该Stream（= movieBloc.outMoviesList）时，后者请求重建相应的MovieCard。 由于我们现在拥有数据，我们可以渲染它了。</p><p>名单和其他链接<br>介绍PublishSubject，BehaviorSubject和ReplaySubject的图片由ReactiveX发布。<br>其他一些有趣的文章值得一读：</p><p><a href="https://www.burkharts.net/apps/blog/" target="_blank" rel="noopener">Fundamentals of Dart Streams</a> [Thomas Burkhart]</p><p><a href="https://pub.dartlang.org/packages/rx_command" target="_blank" rel="noopener">rx_command package</a> [Thomas Burkhart]</p><p><a href="https://medium.com/flutter-io/build-reactive-mobile-apps-in-flutter-companion-article-13950959e381" target="_blank" rel="noopener">Build reactive mobile apps in Flutter - companion article</a> [Filip Hracek]</p><p><a href="https://skillsmatter.com/skillscasts/12254-flutter-with-streams-and-rxdart" target="_blank" rel="noopener">Flutter with Streams and RxDart</a> [Brian Egan]</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>很长的文章，但还有更多的话要说，因为对我而言，这是展开Flutter应用程序的方法。 它提供了很大的灵活性。</p><p>很快就会继续关注新文章。 快乐写代码。</p><p>这篇文章也可以在 <a href="https://medium.com/flutter-community/reactive-programming-streams-bloc-6f0d2bd2d248" target="_blank" rel="noopener">Medium -Flutter Community</a> 找到。</p><p><a href="https://github.com/boeledi/Streams-Block-Reactive-Programming-in-Flutter" target="_blank" rel="noopener">本文源码</a></p><p>如需转载本译文，<a href="https://www.jianshu.com/p/4d5e712594b4" target="_blank" rel="noopener">请注明出处</a>.</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter之AppBar的部分定制</title>
      <link href="/2019/03/14/Flutter%E4%B9%8BAppBar%E7%9A%84%E9%83%A8%E5%88%86%E5%AE%9A%E5%88%B6/"/>
      <url>/2019/03/14/Flutter%E4%B9%8BAppBar%E7%9A%84%E9%83%A8%E5%88%86%E5%AE%9A%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/SilenceZhou/FlutterLearning/tree/master/3_flutter_myself/11_navigation_segment" target="_blank" rel="noopener">代码</a> 最终预览效果如下：</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/699599-be500484593d0313.gif?imageMogr2/auto-orient/strip" alt="AppBar定制-min.gif"></p><h3 id="一、定制Title"><a href="#一、定制Title" class="headerlink" title="一、定制Title"></a>一、定制Title</h3><blockquote><p>目标：App导航栏title换成需要切换条（iOS中叫Segment）<br>1、flutter提供的AppBar的title属性就是wigdet，所有我们可以直接把title设置为tabbar;<br>2、需要相应的页面来进行联动，所以需要关联SingleTickerProviderStateMixin, 且把tabbar的controller 和 TabBarView的controller设置为同一个controller</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> GlobalKey&lt;ScaffoldState&gt; _scaffoldKey = GlobalKey&lt;ScaffoldState&gt;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line"></span><br><span class="line">  MyHomePage(&#123;Key key, <span class="keyword">this</span>.title&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyHomePageState createState() =&gt; _MyHomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  TabController _controller;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _controller = TabController(length: <span class="number">3</span>, vsync: <span class="keyword">this</span>); <span class="comment">//初始化方法</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">        title: TabBar(</span><br><span class="line">          controller: _controller,</span><br><span class="line">          tabs: &lt;Widget&gt;[</span><br><span class="line">            Tab(</span><br><span class="line">              icon: Icon(Icons.directions_car),</span><br><span class="line">            ),</span><br><span class="line">            Tab(</span><br><span class="line">              icon: Icon(Icons.directions_transit),</span><br><span class="line">            ),</span><br><span class="line">            Tab(</span><br><span class="line">              icon: Icon(Icons.directions_bike),</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      body: TabBarView(</span><br><span class="line">        controller: _controller,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          HomePage(</span><br><span class="line">            title: <span class="string">"设置11111"</span>,</span><br><span class="line">          ),</span><br><span class="line">          HomePage(</span><br><span class="line">            title: <span class="string">"设置22222"</span>,</span><br><span class="line">          ),</span><br><span class="line">          HomePage(</span><br><span class="line">            title: <span class="string">"设置33333"</span>,</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>HomePage代码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line"></span><br><span class="line">  HomePage(&#123;Key key, <span class="keyword">this</span>.child, <span class="keyword">this</span>.title&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: Center(</span><br><span class="line">        child: Text(title),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、侧滑抽屉效果"><a href="#二、侧滑抽屉效果" class="headerlink" title="二、侧滑抽屉效果"></a>二、侧滑抽屉效果</h3><p>1、方法一:系统自带（局限性，图片不能更改）<br>仅仅设置Scaffold的drawer就好</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drawer: _buildDrawer(context),</span><br></pre></td></tr></table></figure><p>2、方法二:Builder</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">leading: Builder(</span><br><span class="line">          builder: (context) =&gt; IconButton(</span><br><span class="line">                icon: <span class="keyword">new</span> Icon(Icons.settings),</span><br><span class="line">                onPressed: () =&gt; Scaffold.of(context).openDrawer(),</span><br><span class="line">              ),</span><br><span class="line">        ),</span><br></pre></td></tr></table></figure><p>3、方法三:GlobalKey<scaffoldstate></scaffoldstate></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1.步奏一</span></span><br><span class="line"><span class="keyword">final</span> GlobalKey&lt;ScaffoldState&gt; _scaffoldKey = GlobalKey&lt;ScaffoldState&gt;();</span><br><span class="line"></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      key: _scaffoldKey,<span class="comment">// 2、步奏二</span></span><br><span class="line">      drawer: _buildDrawer(context),</span><br><span class="line">      leading: IconButton(</span><br><span class="line">          icon: Icon(Icons.account_box),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            <span class="comment">// 3、步奏三</span></span><br><span class="line">            _scaffoldKey.currentState.openDrawer();</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">       );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>4、方法四:改变源码（不推荐）</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/// 到AppBar源码，修改的部分code</span></span><br><span class="line">Widget leading = widget.leading;</span><br><span class="line"><span class="keyword">if</span> (<span class="comment">/*leading == null &amp;&amp; */</span>widget.automaticallyImplyLeading) &#123;</span><br><span class="line">  <span class="keyword">if</span> (hasDrawer) &#123;</span><br><span class="line">    leading = IconButton(</span><br><span class="line">      icon: <span class="comment">/*const Icon(Icons.menu)*/</span> leading ?? Icon(Icons.home), <span class="comment">// 如果leading指定了widget那么</span></span><br><span class="line">      onPressed: _handleDrawerButton,</span><br><span class="line">      tooltip: MaterialLocalizations.of(context).openAppDrawerTooltip,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (canPop)</span><br><span class="line">      leading = useCloseButton ? <span class="keyword">const</span> CloseButton() : <span class="keyword">const</span> BackButton();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (leading != <span class="keyword">null</span>) &#123;</span><br><span class="line">  leading = ConstrainedBox(</span><br><span class="line">    constraints: <span class="keyword">const</span> BoxConstraints.tightFor(width: _kLeadingWidth),</span><br><span class="line">    child: leading,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附录:代码汇总</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">Widget _buildDrawer(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Drawer(</span><br><span class="line">      child: ListView(</span><br><span class="line">        dragStartBehavior: DragStartBehavior.down,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          <span class="comment">// 1. 简单的头部</span></span><br><span class="line">          <span class="comment">// const DrawerHeader(</span></span><br><span class="line">          <span class="comment">//   child: Center(</span></span><br><span class="line">          <span class="comment">//     child: Text('我是侧边栏'),</span></span><br><span class="line">          <span class="comment">//   ),</span></span><br><span class="line">          <span class="comment">// ),</span></span><br><span class="line">          <span class="comment">// 2.复杂的用户头部</span></span><br><span class="line">          <span class="comment">// UserAccountsDrawerHeader 不能用const来修饰</span></span><br><span class="line">          UserAccountsDrawerHeader(</span><br><span class="line">            accountEmail: Text(</span><br><span class="line">              <span class="string">'13456@qq.com'</span>,</span><br><span class="line">              style: TextStyle(color: Colors.black),</span><br><span class="line">            ),</span><br><span class="line">            accountName: Text(</span><br><span class="line">              <span class="string">'HandsomeMen'</span>,</span><br><span class="line">              style: TextStyle(color: Colors.black),</span><br><span class="line">            ),</span><br><span class="line">            currentAccountPicture: GestureDetector(</span><br><span class="line">              onTap: () &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">'current user'</span>);</span><br><span class="line">              &#125;,</span><br><span class="line">              child: CircleAvatar(</span><br><span class="line">                backgroundImage: NetworkImage(</span><br><span class="line">                    <span class="string">'http://m.360buyimg.com/pop/jfs/t25441/342/232745157/35324/69b79175/5b696c57N739592b8.jpg'</span>),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            otherAccountsPictures: &lt;Widget&gt;[</span><br><span class="line">              GestureDetector(</span><br><span class="line">                onTap: () =&gt; <span class="built_in">print</span>(<span class="string">'点击了otherAccountsPictures 111111'</span>),</span><br><span class="line">                child: CircleAvatar(</span><br><span class="line">                  backgroundImage: NetworkImage(</span><br><span class="line">                      <span class="string">'https://pic.qqtn.com/up/2018-9/15367146917869444.jpg'</span>),</span><br><span class="line">                ),</span><br><span class="line">              ),</span><br><span class="line">              GestureDetector(</span><br><span class="line">                onTap: () =&gt; <span class="built_in">print</span>(<span class="string">'点击了otherAccountsPictures 222222'</span>),</span><br><span class="line">                child: CircleAvatar(</span><br><span class="line">                  backgroundImage: NetworkImage(</span><br><span class="line">                      <span class="string">'http://www.gx8899.com/uploads/allimg/160902/3-160Z2104544.jpg'</span>),</span><br><span class="line">                ),</span><br><span class="line">              ),</span><br><span class="line">            ],</span><br><span class="line">            decoration: BoxDecoration(</span><br><span class="line">              <span class="comment">//装饰器提供背景图片</span></span><br><span class="line">              image: DecorationImage(</span><br><span class="line">                  fit: BoxFit.fill,</span><br><span class="line">                  <span class="comment">//使用网络图片怎么有问题</span></span><br><span class="line">                  image: NetworkImage(</span><br><span class="line">                      <span class="string">'http://www.86ps.com/UpLoadFiles/jpg/2011-10/2011100912585215837.jpg'</span>)</span><br><span class="line">                  <span class="comment">// image: new ExactAssetImage('images/bg.jpg'),</span></span><br><span class="line">                  ),</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line"></span><br><span class="line">          <span class="keyword">const</span> ListTile(</span><br><span class="line">            leading: Icon(Icons.account_box),</span><br><span class="line">            title: Text(<span class="string">'选卡1'</span>),</span><br><span class="line">          ),</span><br><span class="line">          Divider(),</span><br><span class="line">          <span class="keyword">const</span> ListTile(</span><br><span class="line">            leading: Icon(Icons.account_box),</span><br><span class="line">            title: Text(<span class="string">'选卡1'</span>),</span><br><span class="line">          ),</span><br><span class="line">          Divider(),</span><br><span class="line">          <span class="keyword">const</span> ListTile(</span><br><span class="line">            leading: Icon(Icons.account_box),</span><br><span class="line">            title: Text(<span class="string">'选卡1'</span>),</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 网络请求的三种简单实现</title>
      <link href="/2019/02/23/Flutter-%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%89%E7%A7%8D%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/02/23/Flutter-%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%89%E7%A7%8D%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>概述：本文主要讲解了flutter网络请求三种方式 <strong>flutter自带的HttpClient</strong>、 <strong>第三方库http</strong> 和 <strong>第三方库Dio</strong>  的简单实现 GET 和 POST请求，本文是笔者学习Flutter网络模块知识总结，若有问题还望不腻赐教。 </p></blockquote><h3 id="一-系统自带HttpClient"><a href="#一-系统自带HttpClient" class="headerlink" title="一.系统自带HttpClient"></a>一.系统自带HttpClient</h3><h6 id="1-使用中温馨提示"><a href="#1-使用中温馨提示" class="headerlink" title="1.使用中温馨提示"></a>1.使用中温馨提示</h6><h6 id="1-1-导入库"><a href="#1-1-导入库" class="headerlink" title="1.1.导入库"></a>1.1.导入库</h6><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>; <span class="comment">// 网络请求</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:convert'</span>; <span class="comment">// 数据解析</span></span><br></pre></td></tr></table></figure><h6 id="1-2-Uri的多种初始化方式"><a href="#1-2-Uri的多种初始化方式" class="headerlink" title="1.2.Uri的多种初始化方式"></a>1.2.Uri的多种初始化方式</h6><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="built_in">Uri</span> uri = <span class="built_in">Uri</span>(scheme: <span class="string">'https'</span>, host: <span class="string">'app.xxx.com'</span>, path: homeNoviceListUrl);</span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="built_in">Uri</span> uri = <span class="built_in">Uri</span>.https(<span class="string">'app.xxx.com'</span>, homeNoviceListUrl);</span><br><span class="line"><span class="comment">// uri方法3</span></span><br><span class="line"><span class="built_in">Uri</span> uri = <span class="built_in">Uri</span>.parse(baseUrl + homeNoviceListUrl);</span><br></pre></td></tr></table></figure><h5 id="2-简单使用"><a href="#2-简单使用" class="headerlink" title="2.简单使用"></a>2.简单使用</h5><h6 id="2-1-GET请求"><a href="#2-1-GET请求" class="headerlink" title="2.1.GET请求"></a>2.1.GET请求</h6><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.1 HttpClient - get </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> loadData_sys_get() <span class="keyword">async</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'------loadData_sys_get--------'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line"><span class="keyword">var</span> params = <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// uri方法1</span></span><br><span class="line"><span class="built_in">Uri</span> uri =</span><br><span class="line">    <span class="built_in">Uri</span>(scheme: <span class="string">'https'</span>, host: <span class="string">'app.xxx.com'</span>, path: homeNoviceListUrl);</span><br><span class="line"></span><br><span class="line"><span class="comment">// uri方法2</span></span><br><span class="line"><span class="comment">// Uri uri = Uri.https(</span></span><br><span class="line"><span class="comment">//     'app.xxx.com', homeNoviceListUrl);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// uri方法3</span></span><br><span class="line"><span class="comment">// Uri uri = Uri.parse(baseUrl + homeNoviceListUrl);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">await</span> httpClient.getUrl(uri);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> headers = <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;();</span><br><span class="line">headers[<span class="string">'loginSource'</span>] = <span class="string">'IOS'</span>;</span><br><span class="line">headers[<span class="string">'useVersion'</span>] = <span class="string">'3.1.0'</span>;</span><br><span class="line">headers[<span class="string">'isEncoded'</span>] = <span class="string">'1'</span>;</span><br><span class="line">headers[<span class="string">'bundleId'</span>] = <span class="string">'com.xxx.xxx'</span>;</span><br><span class="line"></span><br><span class="line">request.headers.add(<span class="string">"loginSource"</span>, <span class="string">"IOS"</span>);</span><br><span class="line">request.headers.add(<span class="string">"useVersion"</span>, <span class="string">"3.1.0"</span>);</span><br><span class="line">request.headers.add(<span class="string">"isEncoded"</span>, <span class="string">"1"</span>);</span><br><span class="line">request.headers.add(<span class="string">"bundleId"</span>, <span class="string">"com.xxx.xxx"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> response = <span class="keyword">await</span> request.close();</span><br><span class="line"><span class="keyword">var</span> responseBody = <span class="keyword">await</span> response.transform(Utf8Decoder()).join();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (response.statusCode == HttpStatus.ok) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'请求头：<span class="subst">$&#123;response.headers&#125;</span>'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'111请求成功代发数据为:\n <span class="subst">$responseBody</span>'</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'--------------'</span>);</span><br><span class="line">  <span class="built_in">Map</span> data = jsonDecode(responseBody);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'222请求成功代发数据为:\n <span class="subst">$data</span>'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'\n\n\n11111==请求失败<span class="subst">$&#123;response.statusCode&#125;</span>'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-2-POST请求"><a href="#2-2-POST请求" class="headerlink" title="2.2.POST请求"></a>2.2.POST请求</h6><p><strong>注意点：请求参数需要编码后放在request中</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> loadData_sys_post() <span class="keyword">async</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'------loadData_sys_post--------'</span>);</span><br><span class="line"></span><br><span class="line">HttpClient httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line"></span><br><span class="line"><span class="comment">// queryParameters get请求的查询参数(适用于get请求？？？是吗？？？)</span></span><br><span class="line"><span class="comment">// Uri uri = Uri(</span></span><br><span class="line"><span class="comment">//     scheme: "https", host: "app.xxx.com", path: homeRegularListUrl);</span></span><br><span class="line"><span class="comment">// HttpClientRequest request = await httpClient.postUrl(uri);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> url = baseUrl + homeRegularListUrl;</span><br><span class="line">HttpClientRequest request = <span class="keyword">await</span> httpClient.postUrl(<span class="built_in">Uri</span>.parse(url));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求头</span></span><br><span class="line">request.headers.<span class="keyword">set</span>(<span class="string">"loginSource"</span>, <span class="string">"IOS"</span>);</span><br><span class="line">request.headers.<span class="keyword">set</span>(<span class="string">"useVersion"</span>, <span class="string">"3.1.0"</span>);</span><br><span class="line">request.headers.<span class="keyword">set</span>(<span class="string">"isEncoded"</span>, <span class="string">"1"</span>);</span><br><span class="line">request.headers.<span class="keyword">set</span>(<span class="string">"bundleId"</span>, <span class="string">"com.xxx.xxx"</span>);</span><br><span class="line"><span class="comment">// Content-Type大小写都ok</span></span><br><span class="line">request.headers.<span class="keyword">set</span>(<span class="string">'content-type'</span>, <span class="string">'application/json'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 添加请求体</span></span><br><span class="line"><span class="comment">/// https://stackoverflow.com/questions/50278258/http-post-with-json-on-body-flutter-dart/50295533</span></span><br><span class="line"><span class="built_in">Map</span> jsonMap = &#123;<span class="string">'currentPage'</span>: <span class="string">'1'</span>&#125;;</span><br><span class="line">request.add(utf8.encode(json.encode(jsonMap)));</span><br><span class="line"></span><br><span class="line">HttpClientResponse response = <span class="keyword">await</span> request.close();</span><br><span class="line"><span class="built_in">String</span> responseBody = <span class="keyword">await</span> response.transform(utf8.decoder).join();</span><br><span class="line"><span class="keyword">if</span> (response.statusCode == HttpStatus.ok) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'请求成功'</span>);</span><br><span class="line">  <span class="built_in">print</span>(response.headers);</span><br><span class="line">  <span class="built_in">print</span>(responseBody);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二-请求第三方库-http"><a href="#二-请求第三方库-http" class="headerlink" title="二.请求第三方库 http"></a>二.请求第三方库 http</h3><h5 id="1-使用中温馨提示-1"><a href="#1-使用中温馨提示-1" class="headerlink" title="1.使用中温馨提示"></a>1.使用中温馨提示</h5><h5 id="1-1-添加依赖"><a href="#1-1-添加依赖" class="headerlink" title="1.1.添加依赖"></a>1.1.添加依赖</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  http: ^<span class="number">0.12</span><span class="number">.0</span> #latest version</span><br></pre></td></tr></table></figure><h5 id="1-2-导入库"><a href="#1-2-导入库" class="headerlink" title="1.2.导入库"></a>1.2.导入库</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:http/http.dart'</span> <span class="keyword">as</span> http; <span class="comment">//导入前需要配置</span></span><br></pre></td></tr></table></figure><h5 id="2-简单使用-1"><a href="#2-简单使用-1" class="headerlink" title="2.简单使用"></a>2.简单使用</h5><h5 id="2-1-GET请求-1"><a href="#2-1-GET请求-1" class="headerlink" title="2.1. GET请求"></a>2.1. GET请求</h5><h6 id="2-2-1-http-get1"><a href="#2-2-1-http-get1" class="headerlink" title="2.2.1. http - get1"></a>2.2.1. http - get1</h6><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> loadData_http_get() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'------loadData_http_get--------'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> client = http.Client();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> uri = <span class="built_in">Uri</span>.parse(baseUrl + homeNoviceListUrl);</span><br><span class="line"></span><br><span class="line">  http.Response response = <span class="keyword">await</span> client.<span class="keyword">get</span>(uri);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (response.statusCode == HttpStatus.ok) &#123;</span><br><span class="line">    <span class="built_in">print</span>(response.body);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'请求失败 code 码为<span class="subst">$&#123;response.statusCode&#125;</span>'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-2-http-get简便方法（链式编程）"><a href="#2-2-http-get简便方法（链式编程）" class="headerlink" title="2.2. http - get简便方法（链式编程）"></a>2.2. http - get简便方法（链式编程）</h6><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> loadData_http_get_convenience() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'------简便方法loadData_http_get_convenience--------'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> uri = <span class="built_in">Uri</span>.parse(baseUrl + homeNoviceListUrl);</span><br><span class="line"></span><br><span class="line">    http.Client().<span class="keyword">get</span>(uri).then((http.Response response) &#123;</span><br><span class="line">      <span class="keyword">if</span> (response.statusCode == HttpStatus.ok) &#123;</span><br><span class="line">        <span class="built_in">print</span>(response.body);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'请求失败 code 码为<span class="subst">$&#123;response.statusCode&#125;</span>'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-POST请求-1"><a href="#2-2-POST请求-1" class="headerlink" title="2.2. POST请求"></a>2.2. POST请求</h5><h6 id="2-2-1-http-post"><a href="#2-2-1-http-post" class="headerlink" title="2.2.1.  http - post"></a>2.2.1.  http - post</h6><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> loadData_http_post() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'------ loadData_http_post --------'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> headers = <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;();</span><br><span class="line">  headers[<span class="string">"loginSource"</span>] = <span class="string">"IOS"</span>;</span><br><span class="line">  headers[<span class="string">"useVersion"</span>] = <span class="string">"3.1.0"</span>;</span><br><span class="line">  headers[<span class="string">"isEncoded"</span>] = <span class="string">"1"</span>;</span><br><span class="line">  headers[<span class="string">"bundleId"</span>] = <span class="string">"com.xxx.xxx"</span>;</span><br><span class="line">  headers[<span class="string">"loginSource"</span>] = <span class="string">"IOS"</span>;</span><br><span class="line">  headers[<span class="string">"Content\-Type"</span>] = <span class="string">"application/json"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Map</span> params = &#123;<span class="string">'currentPage'</span>: <span class="string">'1'</span>&#125;;</span><br><span class="line">  <span class="comment">// 嵌套两层都可以，但是具体哪个好还有待确认？？？？</span></span><br><span class="line">  <span class="keyword">var</span> jsonParams = utf8.encode(json.encode(params));</span><br><span class="line">  <span class="comment">// var jsonParams = json.encode(params);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> httpClient = http.Client();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> uri = <span class="built_in">Uri</span>.parse(baseUrl + homeNoviceListUrl);</span><br><span class="line"></span><br><span class="line">  http.Response response =</span><br><span class="line">      <span class="keyword">await</span> httpClient.post(uri, body: jsonParams, headers: headers);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (response.statusCode == HttpStatus.ok) &#123;</span><br><span class="line">    <span class="built_in">print</span>(response.body);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'请求失败 code 码���<span class="subst">$&#123;response.statusCode&#125;</span>'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-2-2-http-Post简便方法（链式编程）"><a href="#2-2-2-http-Post简便方法（链式编程）" class="headerlink" title="2.2.2. http - Post简便方法（链式编程）"></a>2.2.2. http - Post简便方法（链式编程）</h6><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> loadData_http_post_convenience() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'------ loadData_http_post --------'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> headers = <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;();</span><br><span class="line">  headers[<span class="string">"loginSource"</span>] = <span class="string">"IOS"</span>;</span><br><span class="line">  headers[<span class="string">"useVersion"</span>] = <span class="string">"3.1.0"</span>;</span><br><span class="line">  headers[<span class="string">"isEncoded"</span>] = <span class="string">"1"</span>;</span><br><span class="line">  headers[<span class="string">"bundleId"</span>] = <span class="string">"com.xxx.xxx"</span>;</span><br><span class="line">  headers[<span class="string">"loginSource"</span>] = <span class="string">"IOS"</span>;</span><br><span class="line">  headers[<span class="string">"Content\-Type"</span>] = <span class="string">"application/json"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Map</span> params = &#123;<span class="string">'currentPage'</span>: <span class="string">'1'</span>&#125;;</span><br><span class="line">  <span class="comment">// 嵌套两层都可以，但是具体哪个好还有待确认？？？？</span></span><br><span class="line">  <span class="keyword">var</span> jsonParams = utf8.encode(json.encode(params));</span><br><span class="line">  <span class="comment">// var jsonParams = json.encode(params);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> httpClient = http.Client();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> url = baseUrl + homeRegularListUrl;</span><br><span class="line"></span><br><span class="line">  httpClient.post(url, body: jsonParams, headers: headers).then((response) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Response status: <span class="subst">$&#123;response.statusCode&#125;</span>"</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Response body: <span class="subst">$&#123;response.body&#125;</span>"</span>);</span><br><span class="line">  &#125;).whenComplete(httpClient.close);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-请求第三方库-Dio"><a href="#三-请求第三方库-Dio" class="headerlink" title="三.请求第三方库 Dio"></a>三.请求第三方库 Dio</h3><h4 id="1-使用中温馨提示-2"><a href="#1-使用中温馨提示-2" class="headerlink" title="1.使用中温馨提示"></a>1.使用中温馨提示</h4><h5 id="1-1-添加依赖-1"><a href="#1-1-添加依赖-1" class="headerlink" title="1.1.添加依赖"></a>1.1.添加依赖</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  dio: ^<span class="number">2.0</span><span class="number">.11</span> #latest version</span><br></pre></td></tr></table></figure><h5 id="1-2-导入库-1"><a href="#1-2-导入库-1" class="headerlink" title="1.2.导入库"></a>1.2.导入库</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:dio/dio.dart'</span>;</span><br></pre></td></tr></table></figure><h4 id="2-简单使用-2"><a href="#2-简单使用-2" class="headerlink" title="2.简单使用"></a>2.简单使用</h4><h5 id="2-1-GET请求-2"><a href="#2-1-GET请求-2" class="headerlink" title="2.1. GET请求"></a>2.1. GET请求</h5><p><strong>注意：Dio的get请求（baseUrl都是在dio.option.baseUrl设置的） 请求头可以在dio.option上设置，也可以在新建的option上设置,新建option是可选的</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> loadData_dio_get() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> headers = <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;();</span><br><span class="line">    headers[<span class="string">'loginSource'</span>] = <span class="string">'IOS'</span>;</span><br><span class="line">    headers[<span class="string">'useVersion'</span>] = <span class="string">'3.1.0'</span>;</span><br><span class="line">    headers[<span class="string">'isEncoded'</span>] = <span class="string">'1'</span>;</span><br><span class="line">    headers[<span class="string">'bundleId'</span>] = <span class="string">'com.xxx.xxx'</span>;</span><br><span class="line">    headers[<span class="string">'Content-Type'</span>] = <span class="string">'application/json'</span>;</span><br><span class="line"></span><br><span class="line">    Dio dio = Dio();</span><br><span class="line">    dio.options.headers.addAll(headers);</span><br><span class="line">    dio.options.baseUrl = baseUrl;</span><br><span class="line"></span><br><span class="line">    Response response = <span class="keyword">await</span> dio.<span class="keyword">get</span>(homeNoviceListUrl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (response.statusCode == HttpStatus.ok) &#123;</span><br><span class="line">      <span class="built_in">print</span>(response.headers);</span><br><span class="line">      <span class="built_in">print</span>(response.data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-POST请求-2"><a href="#2-2-POST请求-2" class="headerlink" title="2.2. POST请求"></a>2.2. POST请求</h5><p>注意：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dio.options.method设置是无效</span><br><span class="line">Dio dio = Dio();</span><br><span class="line">dio.options.method = <span class="string">'post'</span>;</span><br><span class="line"></span><br><span class="line">办法：</span><br><span class="line">新建一个Options对象，然后在发起请求的时候进行设置：</span><br><span class="line">Options option = Options(method:<span class="string">'post'</span>);</span><br><span class="line">Response response = <span class="keyword">await</span> dio.request(homeRegularListUrl,data:&#123;<span class="string">"currentPage"</span>: <span class="string">"1"</span>&#125;, options: option);</span><br></pre></td></tr></table></figure><h6 id="2-2-1-dio-方式一（baseUrl都是在dio-option-baseUrl设置的）"><a href="#2-2-1-dio-方式一（baseUrl都是在dio-option-baseUrl设置的）" class="headerlink" title="2.2.1. dio - 方式一（baseUrl都是在dio.option.baseUrl设置的）"></a>2.2.1. dio - 方式一（baseUrl都是在dio.option.baseUrl设置的）</h6><p><strong>注意：直接在 dio.options设置除methods以外的 请求头参数</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> loadData_dio_dioOfOptionsSetting() <span class="keyword">async</span> &#123;</span><br><span class="line">    debugPrint(</span><br><span class="line">        <span class="string">' \n post请求 ======================= 开始请求 =======================\n'</span>);</span><br><span class="line">    <span class="keyword">var</span> headers = <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;();</span><br><span class="line">    headers[<span class="string">'loginSource'</span>] = <span class="string">'IOS'</span>;</span><br><span class="line">    headers[<span class="string">'useVersion'</span>] = <span class="string">'3.1.0'</span>;</span><br><span class="line">    headers[<span class="string">'isEncoded'</span>] = <span class="string">'1'</span>;</span><br><span class="line">    headers[<span class="string">'bundleId'</span>] = <span class="string">'com.xxx.xxx'</span>;</span><br><span class="line">    headers[<span class="string">'Content-Type'</span>] = <span class="string">'application/json'</span>;</span><br><span class="line"></span><br><span class="line">    Dio dio = Dio();</span><br><span class="line">    dio.options.baseUrl = baseUrl;</span><br><span class="line">    dio.options.connectTimeout = <span class="number">60000</span>;</span><br><span class="line">    dio.options.receiveTimeout = <span class="number">60000</span>;</span><br><span class="line">    dio.options.headers.addAll(headers);</span><br><span class="line">    dio.options.method = <span class="string">'post'</span>;</span><br><span class="line"></span><br><span class="line">    Options option = Options(method: <span class="string">'post'</span>);</span><br><span class="line">    <span class="comment">// Response response = await dio.request(homeRegularListUrl,</span></span><br><span class="line">    <span class="comment">//     data: &#123;"currentPage": "1"&#125;, options: option);</span></span><br><span class="line"></span><br><span class="line">    Response response = <span class="keyword">await</span> dio.post(homeRegularListUrl,</span><br><span class="line">        data: &#123;<span class="string">"currentPage"</span>: <span class="string">"1"</span>&#125;, options: option);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (response.statusCode == HttpStatus.ok) &#123;</span><br><span class="line">      debugPrint(<span class="string">'请求参数： <span class="subst">$&#123;response.request.queryParameters&#125;</span>'</span>);</span><br><span class="line">      debugPrint(</span><br><span class="line">          <span class="string">'-------------------请求成功,请求结果如下:-----------------\n \n===请求求url: <span class="subst">$&#123;response.request.uri.toString()&#125;</span> \n \n===请求 ���:   \n<span class="subst">$&#123;response.headers&#125;</span> \n \n===请求结果: \n<span class="subst">$&#123;response.data&#125;</span>\n'</span>);</span><br><span class="line">      debugPrint(<span class="string">'-------------------请求成功,请求结果打印完毕----------------'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'请求失败'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h6 id="2-2-2-dio-方式二（baseUrl都是在dio-option-baseUrl设置的）"><a href="#2-2-2-dio-方式二（baseUrl都是在dio-option-baseUrl设置的）" class="headerlink" title="2.2.2. dio - 方式二（baseUrl都是在dio.option.baseUrl设置的）"></a>2.2.2. dio - 方式二（baseUrl都是在dio.option.baseUrl设置的）</h6><p><strong>注意：在新建的option上设置请求头参数</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> loadData_dio_newOptionSetting() <span class="keyword">async</span> &#123;</span><br><span class="line">    debugPrint(<span class="string">' \n======================= 开始请求 =======================\n'</span>);</span><br><span class="line">    <span class="keyword">var</span> headers = <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;();</span><br><span class="line">    headers[<span class="string">'loginSource'</span>] = <span class="string">'IOS'</span>;</span><br><span class="line">    headers[<span class="string">'useVersion'</span>] = <span class="string">'3.1.0'</span>;</span><br><span class="line">    headers[<span class="string">'isEncoded'</span>] = <span class="string">'1'</span>;</span><br><span class="line">    headers[<span class="string">'bundleId'</span>] = <span class="string">'com.xxx.xxx'</span>;</span><br><span class="line">    headers[<span class="string">'Content-Type'</span>] = <span class="string">'application/json'</span>;</span><br><span class="line"></span><br><span class="line">    Options option = Options(method: <span class="string">'post'</span>);</span><br><span class="line">    option.connectTimeout = <span class="number">60000</span>;</span><br><span class="line">    option.receiveTimeout = <span class="number">60000</span>;</span><br><span class="line">    option.headers.addAll(headers);</span><br><span class="line"></span><br><span class="line">    Dio dio = Dio();</span><br><span class="line">    dio.options.baseUrl = baseUrl;</span><br><span class="line"></span><br><span class="line">    Response response = <span class="keyword">await</span> dio.post(homeRegularListUrl,</span><br><span class="line">        data: &#123;<span class="string">"currentPage"</span>: <span class="number">1</span>&#125;, options: option);</span><br><span class="line">    <span class="comment">// Response response = await dio.request(homeRegularListUrl,</span></span><br><span class="line">    <span class="comment">// data: &#123;"currentPage": 1&#125;, options: option);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (response.statusCode == HttpStatus.ok) &#123;</span><br><span class="line">      debugPrint(<span class="string">'请求参数： <span class="subst">$&#123;response.request.queryParameters&#125;</span>'</span>);</span><br><span class="line">      debugPrint(</span><br><span class="line">          <span class="string">'-------------------请求成功,请求结果如下:-----------------\n \n===请求url: <span class="subst">$&#123;response.request.uri.toString()&#125;</span> \n \n===请求 头:   \n<span class="subst">$&#123;response.headers&#125;</span> \n \n===请求结果: \n<span class="subst">$&#123;response.data&#125;</span>\n'</span>);</span><br><span class="line">      debugPrint(<span class="string">'-------------------请求成功,请求结果打印完毕----------------'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'请求失败'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则替换url字符串中的值</title>
      <link href="/2019/02/18/%E6%AD%A3%E5%88%99%E6%9B%BF%E6%8D%A2url%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%80%BC/"/>
      <url>/2019/02/18/%E6%AD%A3%E5%88%99%E6%9B%BF%E6%8D%A2url%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>1、方法一：键和值一起替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *) paramValueOfUrl:(NSString *) url withParam:(NSString *) param value:(NSString *)value&#123;</span><br><span class="line">    </span><br><span class="line">    NSError *error;</span><br><span class="line"></span><br><span class="line">    NSString *targetString = [NSString stringWithFormat:@&quot;%@=%@&quot;,param,value];</span><br><span class="line"></span><br><span class="line">    NSString *regTags = [[NSString alloc] initWithFormat:@&quot;%@=+([\\w]*)&quot;,param];</span><br><span class="line"></span><br><span class="line">    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:regTags options:0 error:&amp;error];</span><br><span class="line"></span><br><span class="line">    NSString *string = [regex stringByReplacingMatchesInString:url</span><br><span class="line">                                                       options:0</span><br><span class="line">                                                         range:NSMakeRange(0, [url length])</span><br><span class="line">                                                  withTemplate:targetString];</span><br><span class="line"></span><br><span class="line">    return string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、方法二： 值替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/// 方法二：</span><br><span class="line">- (NSString *) paramValueOfUrl2:(NSString *) url withParam:(NSString *) param value:(NSString *)value&#123;</span><br><span class="line"></span><br><span class="line">        NSError *error;</span><br><span class="line">    </span><br><span class="line">        //  (^|&amp;|\\?|#)+%@=+([^&amp;|#]*)(#|&amp;|$) ： range 取 [match rangeAtIndex:2]</span><br><span class="line">        //  %@=+([^&amp;|#]*)(#|&amp;|$)   ： range 取 [match rangeAtIndex:1]</span><br><span class="line">        //  通过numberOfRanges获取结果数量，然后分别打印获取值 [url substringWithRange:[match rangeAtIndex:i]]</span><br><span class="line">        NSString *regTags = [[NSString alloc] initWithFormat:@&quot;(^|&amp;|\\?|#)+%@=+([^&amp;|#]*)(#|&amp;|$)&quot;,param];</span><br><span class="line">        NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:regTags</span><br><span class="line">                                                                               options:NSRegularExpressionCaseInsensitive</span><br><span class="line">                                                                                 error:&amp;error];</span><br><span class="line">    </span><br><span class="line">        // 执行匹配的过程</span><br><span class="line">        NSArray *matches = [regex matchesInString:url</span><br><span class="line">                                          options:0</span><br><span class="line">                                            range:NSMakeRange(0, [url length])];</span><br><span class="line">        for (NSTextCheckingResult *match in matches) &#123;</span><br><span class="line">            NSRange range = [match rangeAtIndex:2];</span><br><span class="line">            NSString *tagValue = [url substringWithRange:range];  // 分组2所对应的串</span><br><span class="line">            if (![value isEqualToString:tagValue]) &#123;</span><br><span class="line">                url = [url stringByReplacingCharactersInRange:range withString:value];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发工具攻略(一)</title>
      <link href="/2018/08/07/Sublime%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2018/08/07/Sublime%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Sublime安装插件报错解决办法"><a href="#1-Sublime安装插件报错解决办法" class="headerlink" title="1. Sublime安装插件报错解决办法"></a>1. Sublime安装插件报错解决办法</h2><blockquote><p>错误：There are no packages available for installation</p></blockquote><p>解决办法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Step1:</span><br><span class="line"></span><br><span class="line">Preferences-&gt;PackageSettings-&gt;PackageControl-&gt;Settings-User</span><br><span class="line"></span><br><span class="line">Step2:</span><br><span class="line">在文件里面添加如下代码：</span><br><span class="line">&quot;debug&quot;: true,</span><br><span class="line">&quot;downloader_precedence&quot;: &#123;</span><br><span class="line">        &quot;windows&quot;: [&quot;wininet&quot;],</span><br><span class="line">        &quot;osx&quot;: [&quot;curl&quot;, &quot;wget&quot;],</span><br><span class="line">        &quot;linux&quot;: [&quot;urllib&quot;, &quot;curl&quot;, &quot;wget&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Step3:</span><br><span class="line">⁃command + shift + p 进行插件安装</span><br><span class="line"></span><br><span class="line">    首先的安装插件管理器： Install Package</span><br><span class="line">    然后输入要安装的插件名称</span><br></pre></td></tr></table></figure><h2 id="2-Github转移项目到Coding-net"><a href="#2-Github转移项目到Coding-net" class="headerlink" title="2. Github转移项目到Coding.net"></a>2. Github转移项目到Coding.net</h2><p>笔者的需求：个人博客部署系统代码不需要进行在github上进行公开，github私有项目又需要付费，感觉不值，所以有此次需求</p><p><a href="https://www.jianshu.com/p/93737d548a3d" target="_blank" rel="noopener">参考</a></p><h3 id="1-Coding-net上建立一个新的私有仓库（有就不用建立）"><a href="#1-Coding-net上建立一个新的私有仓库（有就不用建立）" class="headerlink" title="1. Coding.net上建立一个新的私有仓库（有就不用建立）"></a>1. Coding.net上建立一个新的私有仓库（有就不用建立）</h3><h3 id="2-Coding-net配置公钥-git操作需要权限"><a href="#2-Coding-net配置公钥-git操作需要权限" class="headerlink" title="2.Coding.net配置公钥,git操作需要权限"></a>2.Coding.net配置公钥,git操作需要权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Step1</span><br><span class="line">command+shift+. 展示隐藏文件，然后cd到.ssh文件下面找到.pub结尾的文件(即公钥文件)，拷贝私钥</span><br><span class="line"></span><br><span class="line">Step2</span><br><span class="line">coding个人中心 - SSH公钥 - 新增公钥  添加就好</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ps:补充如何生成SSH公钥</span><br><span class="line">1. 根目录下 执行</span><br><span class="line">ssh-keygen</span><br><span class="line">确认保存公钥的位置（.ssh/id_rsa）</span><br><span class="line">重复一个密码两次，如果不想在使用公钥的时候输入密码，可以留空</span><br><span class="line"></span><br><span class="line">2. 获取公钥 cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><h3 id="3-把github上的代码clone到指定路径"><a href="#3-把github上的代码clone到指定路径" class="headerlink" title="3. 把github上的代码clone到指定路径"></a>3. 把github上的代码clone到指定路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone --bare https://github.com/***/******.git</span><br><span class="line"></span><br><span class="line">ps: --bare 创建的克隆版本库都不包含工作区，直接就是版本库的内容，这样的版本库称为裸版本库。</span><br></pre></td></tr></table></figure><h4 id="4-使用镜像推送的方式上传代码到新的服务器"><a href="#4-使用镜像推送的方式上传代码到新的服务器" class="headerlink" title="4.使用镜像推送的方式上传代码到新的服务器"></a>4.使用镜像推送的方式上传代码到新的服务器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd xxxx.git</span><br><span class="line"></span><br><span class="line">git push --mirror https://git.coding.net/cc412/xxxx.git</span><br><span class="line"></span><br><span class="line">ps:  https://git.coding.net/cc412/xxxx.git  是coding.net仓库地址</span><br><span class="line">     如果https不行推荐用SSH</span><br></pre></td></tr></table></figure><h3 id="5-删除本地代码"><a href="#5-删除本地代码" class="headerlink" title="5.删除本地代码"></a>5.删除本地代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ..//返回上一路径</span><br><span class="line">rm -rf xxxx.git //干掉</span><br></pre></td></tr></table></figure><h3 id="6-从新服务器clone下来，就是你想要的库了"><a href="#6-从新服务器clone下来，就是你想要的库了" class="headerlink" title="6.从新服务器clone下来，就是你想要的库了"></a>6.从新服务器clone下来，就是你想要的库了</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://git.coding.net/cc412/xxxx.git</span><br><span class="line"></span><br><span class="line">ps： 如果https不行推荐用SSH</span><br></pre></td></tr></table></figure><h3 id="7-码云-也是一样的操作-笔者验证码云https和SSH都OK，最终用哪个看自己需要，笔者最终选择了码云！"><a href="#7-码云-也是一样的操作-笔者验证码云https和SSH都OK，最终用哪个看自己需要，笔者最终选择了码云！" class="headerlink" title="7. 码云 也是一样的操作,笔者验证码云https和SSH都OK，最终用哪个看自己需要，笔者最终选择了码云！"></a>7. <a href="https://gitee.com/" target="_blank" rel="noopener">码云</a> 也是一样的操作,笔者验证码云https和SSH都OK，最终用哪个看自己需要，笔者最终选择了码云！</h3>]]></content>
      
      
      <categories>
          
          <category> 开发工具攻略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 攻略 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Next主题博客功能完善</title>
      <link href="/2018/08/07/Next%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%96%84/"/>
      <url>/2018/08/07/Next%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%96%84/</url>
      
        <content type="html"><![CDATA[<p>前提为你已经搭建好hexo next博客<br>如果没有，则<a href="https://www.jianshu.com/p/5e9bd5e39ae6" target="_blank" rel="noopener">参考搭建吧😝</a><br>注意：下载next地址变了<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">next新地址</a><br>博客部署命令可以用&amp;&amp;操作：</p><ul><li>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</li><li>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br>！！！很多插件安装，网上的如果不行，请直接参考插件官网，最官方</li></ul><h1 id="一、配置问题注意点"><a href="#一、配置问题注意点" class="headerlink" title="一、配置问题注意点"></a>一、配置问题注意点</h1><h2 id="1-文章显示中文"><a href="#1-文章显示中文" class="headerlink" title="1. 文章显示中文"></a>1. 文章显示中文</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">根目录/_config.yml（不是next下面的哈）</span><br><span class="line">language: zh-CN # 是zh-CN 不是zh-Hans</span><br></pre></td></tr></table></figure><h2 id="2-首页显示阅读全文"><a href="#2-首页显示阅读全文" class="headerlink" title="2. 首页显示阅读全文"></a>2. 首页显示阅读全文</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">themes/next/_config.yml</span><br><span class="line"></span><br><span class="line">auto_excerpt:</span><br><span class="line">  enable: true # 设置是否显示阅读全文，文章较多的话，有必要设置为 true</span><br><span class="line">  length: 200 #预览展示多少文字</span><br></pre></td></tr></table></figure><h2 id="3-分享功能"><a href="#3-分享功能" class="headerlink" title="3. 分享功能"></a>3. 分享功能</h2><p>ps:微信图片加载不出来，所以去掉了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Step1</span><br><span class="line"></span><br><span class="line">source/lib</span><br><span class="line">git clone https://github.com/theme-next/theme-next-needmoreshare2 source/lib/needsharebutton</span><br><span class="line">ps：名字不是随便的needsharebutton</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Step2</span><br><span class="line"></span><br><span class="line">needmoreshare2:</span><br><span class="line">  enable: true</span><br><span class="line">  postbottom:</span><br><span class="line">    enable: true</span><br><span class="line">    options:</span><br><span class="line">      iconStyle: box</span><br><span class="line">      boxForm: horizontal</span><br><span class="line">      position: bottomCenter</span><br><span class="line">      networks: Weibo,Douban,QQZone,Twitter,Facebook</span><br><span class="line">  float:</span><br><span class="line">    enable: true</span><br><span class="line">    options:</span><br><span class="line">      iconStyle: box</span><br><span class="line">      boxForm: horizontal</span><br><span class="line">      position: middleRight</span><br><span class="line">      networks: Weibo,Douban,QQZone,Twitter,Facebook</span><br></pre></td></tr></table></figure><h2 id="4-添加分类和标签"><a href="#4-添加分类和标签" class="headerlink" title="4. 添加分类和标签"></a>4. 添加分类和标签</h2><p><a href="https://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">官方链接</a><br><a href="https://linlif.github.io/2017/05/27/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/" target="_blank" rel="noopener">参考链接</a> </p><h3 id="4-1-添加分类"><a href="#4-1-添加分类" class="headerlink" title="4.1. 添加分类"></a>4.1. 添加分类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Step1</span><br><span class="line"></span><br><span class="line">进入博客所在文件夹</span><br><span class="line">执行 ： hexo new page categories</span><br><span class="line">成功提示 ： INFO  Created: ~/Documents/blog/source/categories/index.md</span><br><span class="line">根据上面的路径，找到index.md这个文件，打开后默认内容是这样的：</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2017-05-27 13:47:40</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">添加type: &quot;categories&quot;到内容中，添加后是这样的：</span><br><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2017-05-27 13:47:40</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">新建文章后 hexo new [post] 文章标题</span><br><span class="line">添加categories属性，再部署之后就可以在分类页看到分类了</span><br><span class="line">---</span><br><span class="line">title: hexo next 为文章添加分类</span><br><span class="line">date: 2016-03-16 08:12:43</span><br><span class="line">tags:</span><br><span class="line">categories: 前端</span><br><span class="line">---</span><br><span class="line">或则这样但是分类只能添加一个</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">title: hexo next 为文章添加分类</span><br><span class="line">date: 2016-03-16 08:12:43</span><br><span class="line">tags:</span><br><span class="line">categories: </span><br><span class="line">- 前端</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="4-2-添加标签"><a href="#4-2-添加标签" class="headerlink" title="4.2. 添加标签"></a>4.2. 添加标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Step1</span><br><span class="line">进入博客所在文件夹</span><br><span class="line">hexo new page tags</span><br><span class="line"></span><br><span class="line">成功后提示</span><br><span class="line">INFO  Created: ~/Documents/blog/source/tags/index.md</span><br><span class="line"></span><br><span class="line">根据上面的路径，找到index.md这个文件，打开后默认内容是这样的：</span><br><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2017-05-27 14:22:08</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">添加type: &quot;tags&quot;到内容中，添加后是这样的：</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2017-05-27 13:47:40</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">Step2</span><br><span class="line">新建文章或者想给某个文件添加tags，则如下操作</span><br><span class="line">---</span><br><span class="line">title: jQuery对表单的操作及更多应用</span><br><span class="line">date: 2017-05-26 12:12:57</span><br><span class="line">categories: </span><br><span class="line">- web前端</span><br><span class="line">tags:</span><br><span class="line">- jQuery</span><br><span class="line">- 表格</span><br><span class="line">- 表单验证</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>注意：<br> 1.只有添加了tags: xxx的文章才会被收录到首页的“标签”中。<br> 2.在categories和tags的index.m文件里面添加<br>    comments: false ，把评论关了</p><p>细心的朋友可能已经发现，这两个的设置几乎一模一样！是的，没错，思路都是一样的。所以我们可以打开scaffolds/post.md文件，在tages:上面加入categories:,保存后，之后执行hexo new 文章名命令生成的文件，页面里就有categories:项了。</p><p>scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。</p><h2 id="5-文章侧边栏控制"><a href="#5-文章侧边栏控制" class="headerlink" title="5. 文章侧边栏控制"></a>5. 文章侧边栏控制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 这个地方控制自动打开文章目录条</span><br><span class="line"># #sidebar: 注释掉则表示一打开详情页不会自动弹出sidebar</span><br><span class="line">    sidebar:</span><br></pre></td></tr></table></figure><h2 id="6-不要Next自动添加序号"><a href="#6-不要Next自动添加序号" class="headerlink" title="6. 不要Next自动添加序号"></a>6. 不要Next自动添加序号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">themes/next/_config.yml 修改 number: false</span><br><span class="line"></span><br><span class="line">toc:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line">  # Automatically add list number to toc.</span><br><span class="line">  # 不要next系统添加序号</span><br><span class="line">  number: false #true</span><br><span class="line"></span><br><span class="line">  # If true, all words will placed on next lines if header width longer then sidebar width.</span><br><span class="line">  wrap: false</span><br></pre></td></tr></table></figure><h2 id="7-代码高亮主题色"><a href="#7-代码高亮主题色" class="headerlink" title="7.代码高亮主题色"></a>7.代码高亮主题色</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">需要写明语言才会真正有效果</span><br><span class="line">hexo next highlight_theme 设置</span><br></pre></td></tr></table></figure><h2 id="8-安装与卸载插件"><a href="#8-安装与卸载插件" class="headerlink" title="8. 安装与卸载插件"></a>8. 安装与卸载插件</h2><h3 id="8-1-安装"><a href="#8-1-安装" class="headerlink" title="8.1. 安装"></a>8.1. 安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install xxx –save</span><br><span class="line">做相应配置（官网）</span><br></pre></td></tr></table></figure><h3 id="8-2-卸载"><a href="#8-2-卸载" class="headerlink" title="8.2. 卸载"></a>8.2. 卸载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall 插件名称 --save</span><br><span class="line">去掉相应配置(安装时候配置的)</span><br><span class="line"></span><br><span class="line">例： 卸载hexo s上传图片到的七牛插件（个人安装又卸载了）</span><br><span class="line">npm uninstall hexo-qiniu-sync --save</span><br><span class="line">去掉根目录/_config.yml下配置</span><br></pre></td></tr></table></figure><h2 id="9-网页加载动画效果"><a href="#9-网页加载动画效果" class="headerlink" title="9.网页加载动画效果"></a>9.网页加载动画效果</h2><p>PS： next 已经集成好动画了，如果对速度有要求的话直接关闭，个人选择关闭,加载太慢了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 加载有点慢 关掉</span><br><span class="line">motion:</span><br><span class="line">  enable: false #true</span><br></pre></td></tr></table></figure><h2 id="10-如何在首页添加图片"><a href="#10-如何在首页添加图片" class="headerlink" title="10. 如何在首页添加图片"></a>10. 如何在首页添加图片</h2><p><a href="https://segmentfault.com/q/1010000004840061" target="_blank" rel="noopener">参考链接</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">每篇文章里面添加photos: —&quot;图片链接&quot;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">layout: &apos;[post]&apos;</span><br><span class="line">title: Next主题博客功能完善</span><br><span class="line">date: 2018-08-07 00:25:53</span><br><span class="line">tags:</span><br><span class="line">- 博客</span><br><span class="line">- 技巧</span><br><span class="line">categories: 博客搭建</span><br><span class="line">photos: </span><br><span class="line">    - &quot;http://oz2tkq0zj.bkt.clouddn.com/17-11-9/52323298.jpg&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h1 id="二、-添加功能插件"><a href="#二、-添加功能插件" class="headerlink" title="二、 添加功能插件"></a>二、 添加功能插件</h1><h2 id="1-图片浏览放大功能fancybox"><a href="#1-图片浏览放大功能fancybox" class="headerlink" title="1. 图片浏览放大功能fancybox"></a>1. 图片浏览放大功能fancybox</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Step1:</span><br><span class="line"></span><br><span class="line">cd next/source/lib</span><br><span class="line">git clone https://github.com/theme-next/theme-next-fancybox3 fancybox</span><br><span class="line"></span><br><span class="line">ps:注意fancybox和next/_config.uml里面的名字保持一致</span><br><span class="line"></span><br><span class="line">step2：</span><br><span class="line">更改next/_config.uml文件</span><br><span class="line"></span><br><span class="line">fancybox： true</span><br></pre></td></tr></table></figure><h2 id="2-阅读次数"><a href="#2-阅读次数" class="headerlink" title="2. 阅读次数"></a>2. 阅读次数</h2><p>ps: 仅限于博文详情页面显示阅读数，在首页不显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">step1</span><br><span class="line">更改next/_config.uml文件enable: true,如下：</span><br><span class="line"></span><br><span class="line">busuanzi_count:</span><br><span class="line">  enable: true #false</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  post_views: true</span><br><span class="line">  post_views_icon: eye</span><br></pre></td></tr></table></figure><h2 id="3-hexo-s-顺便上传图片到七牛云服务器参考"><a href="#3-hexo-s-顺便上传图片到七牛云服务器参考" class="headerlink" title="3. hexo s 顺便上传图片到七牛云服务器参考"></a>3. hexo s 顺便上传图片到七牛云服务器<a href="https://marvae.github.io/2017-12-01/qiqiu/" target="_blank" rel="noopener">参考</a></h2><p>ps:这个插件感觉可添加也可不用添加，用到图片的时候自己上传到七牛服务器就好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">step1:</span><br><span class="line">自己注册七牛服务器（目前笔者觉得够用了）</span><br><span class="line"></span><br><span class="line">step2:</span><br><span class="line">hexo主目录，下载插件</span><br><span class="line">npm install hexo-qiniu-sync --save</span><br><span class="line"></span><br><span class="line">step3:</span><br><span class="line">配置next/_config.yml</span><br><span class="line">#七牛云存储设置</span><br><span class="line">##offline       是否离线. 离线状态将使用本地地址渲染</span><br><span class="line">##sync          是否同步</span><br><span class="line">##bucket        空间名称.</span><br><span class="line">##access_key    上传密钥AccessKey</span><br><span class="line">##secret_key    上传密钥SecretKey</span><br><span class="line">##secret_file   秘钥文件路径，可以将上述两个属性配置到文件内，防止泄露，json格式。绝对路径相对路径均可</span><br><span class="line">##dirPrefix     上传的资源子目录前缀.如设置，需与urlPrefix同步 </span><br><span class="line">##urlPrefix     外链前缀.</span><br><span class="line">##up_host      上传服务器路径,如选择华北区域的话配置为http://up-z1.qiniu.com</span><br><span class="line">##local_dir     本地目录.</span><br><span class="line">##update_exist  是否更新已经上传过的文件(仅文件大小不同或在上次上传后进行更新的才会重新上传)</span><br><span class="line">##image/js/css  子参数folder为不同静态资源种类的目录名称，一般不需要改动</span><br><span class="line">##image.extend  这是个特殊参数，用于生成缩略图或加水印等操作。具体请参考http://developer.qiniu.com/docs/v6/api/reference/fop/image/ </span><br><span class="line">##              可使用基本图片处理、高级图片处理、图片水印处理这3个接口。例如 ?imageView2/2/w/500 即生成宽度最多500px的缩略图</span><br><span class="line">qiniu:</span><br><span class="line">  offline: false</span><br><span class="line">  sync: true</span><br><span class="line">  bucket: bucket_name</span><br><span class="line">  secret_file: sec/qn.json or C:</span><br><span class="line">  access_key: AccessKey</span><br><span class="line">  secret_key: SecretKey</span><br><span class="line">  dirPrefix: static</span><br><span class="line">  urlPrefix: http://bucket_name.qiniudn.com/static</span><br><span class="line">  up_host: http://upload.qiniu.com</span><br><span class="line">  local_dir: static</span><br><span class="line">  update_exist: true</span><br><span class="line">  image: </span><br><span class="line">    folder: images</span><br><span class="line">    extend: </span><br><span class="line">  js:</span><br><span class="line">    folder: js</span><br><span class="line">  css:</span><br><span class="line">    folder: css</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">step4:</span><br><span class="line">在hexo目录下,运行一下hexo s，图片直接上传到七牛云存储上去了</span><br></pre></td></tr></table></figure><blockquote><p>注意:备份发布系统代码不会上传hexo-qiniu-sync，不过在重新下载了部署系统，则直接运行<code>npm install hexo —save</code>就好,不需要再次执行 <code>npm install hexo-qiniu-sync --save</code> 因为在第一次下载的时候已经在配置文件记录了</p></blockquote><h2 id="4-畅言评论插件集成参考"><a href="#4-畅言评论插件集成参考" class="headerlink" title="4. 畅言评论插件集成参考"></a>4. <a href="http://changyan.kuaizhan.com/" target="_blank" rel="noopener">畅言</a>评论插件<a href="https://www.jianshu.com/p/5888bd91d070" target="_blank" rel="noopener">集成参考</a></h2><p>功能：博客下面进行各种登陆评论，首页及详情页顶部评论量显示</p><h3 id="4-1-畅言集成步骤"><a href="#4-1-畅言集成步骤" class="headerlink" title="4.1.畅言集成步骤"></a>4.1.畅言集成步骤</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">step1：</span><br><span class="line">注册畅言:http://changyan.kuaizhan.com/</span><br><span class="line">获取畅言评论的APP ID 和APP KEY</span><br><span class="line">ICP备案：自己有最好,网上随便找一个</span><br><span class="line"></span><br><span class="line">step2：</span><br><span class="line">集成就不详叙，直接参考：https://www.jianshu.com/p/5888bd91d070</span><br></pre></td></tr></table></figure><p>遇到的坑 ：<br>a. 显示不全<br><img src="http://pd1cmfwy2.bkt.clouddn.com/chanyan.jpg" alt></p><p>解决办法：<br>更改next/layout/_partials/comments.swig代码<br>原来的代码： 34行处</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;comments&quot; id=&quot;comments&quot;&gt;</span><br><span class="line">      &lt;/style&gt;</span><br><span class="line">      &lt;div id=&quot;SOHUCS&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure><p>改完后的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;comments&quot; id=&quot;comments&quot;&gt;</span><br><span class="line">      &lt;style&gt;</span><br><span class="line">        #comments &#123;</span><br><span class="line">          transform: none !important;</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;/style&gt;</span><br><span class="line">      &lt;div id=&quot;SOHUCS&quot;&gt;&lt;/div&gt;</span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure><p>b. 首页显示评论出现问题<a href="http://www.chaixuhong.com/article/NEXT%E4%BD%BF%E7%94%A8%E7%95%85%E8%A8%80%E7%9A%84%E9%97%AE%E9%A2%98.html" target="_blank" rel="noopener">参考解法</a></p><p>解决办法：<br>next/layout/_mavro/post.swig:175～178行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;#SOHUCS&quot; itemprop=&quot;discussionUrl&quot;&gt;</span><br><span class="line">                 &lt;span id=&quot;url::&#123;&#123; post.permalink &#125;&#125;&quot; class=&quot;cy_cmt_count&quot; data-xid=&quot;&#123;&#123; post.path &#125;&#125;&quot; itemprop=&quot;commentsCount&quot; &gt;&lt;/span&gt;</span><br><span class="line">               &lt;/a&gt;</span><br></pre></td></tr></table></figure><p>将post.permalink这个值包一层encodeURI方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span id=&quot;url::&#123;&#123; encodeURI(post.permalink) &#125;&#125;&quot; class=&quot;cy_cmt_count&quot; data-xid=&quot;&#123;&#123; post.path &#125;&#125;&quot; itemprop=&quot;commentsCount&quot; &gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure><h3 id="4-2-我为什么最终选畅言而不其他评论插件，其他评论插件我都集成过？"><a href="#4-2-我为什么最终选畅言而不其他评论插件，其他评论插件我都集成过？" class="headerlink" title="4.2. 我为什么最终选畅言而不其他评论插件，其他评论插件我都集成过？"></a>4.2. 我为什么最终选畅言而不其他评论插件，其他评论插件我都集成过？</h3><p>（ps:下面的言论不代表其余的评论插件做的不行，很可能是我的集成姿势不对）</p><p>先说说我集成评论系统的要求：<br>登陆评论方便、首页/详情页评论数显示正确</p><h4 id="4-2-1-gitment集成参考-id获取问题导致如果同时发布两篇文章，两篇文章下显示的评论都是两篇文章的总合"><a href="#4-2-1-gitment集成参考-id获取问题导致如果同时发布两篇文章，两篇文章下显示的评论都是两篇文章的总合" class="headerlink" title="4.2.1. gitment集成参考: id获取问题导致如果同时发布两篇文章，两篇文章下显示的评论都是两篇文章的总合"></a>4.2.1. gitment<a href="https://ryanluoxu.github.io/2017/11/27/Hexo-Next-%E6%B7%BB%E5%8A%A0-Gitment-%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/" target="_blank" rel="noopener">集成参考</a>: id获取问题导致如果同时发布两篇文章，两篇文章下显示的评论都是两篇文章的总合</h4><p><a href="https://github.com/imsun/gitment/issues/66" target="_blank" rel="noopener">Error：validation failed </a>解决办法如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">文件:themes\next\layout_third-party\comments\gitments.swig</span><br><span class="line">替换 id: window.location.pathname,</span><br><span class="line">方法一：id: &apos;&#123;&#123; page.date &#125;&#125;’,</span><br><span class="line">方法二：id: (window.location.pathname.length &lt; 50) ? window.location.pathname : &apos;&lt;%= page.date %&gt;&apos;,</span><br><span class="line"></span><br><span class="line">function renderGitment()&#123;</span><br><span class="line">    var gitment = new &#123;&#123;CommentsClass&#125;&#125;(&#123;</span><br><span class="line">        id: window.location.pathname,</span><br><span class="line">        owner: &apos;&#123;&#123; theme.gitment.github_user &#125;&#125;&apos;,</span><br><span class="line">        repo: &apos;&#123;&#123; theme.gitment.github_repo &#125;&#125;&apos;,</span><br><span class="line">        &#123;% if theme.gitment.mint %&#125;</span><br><span class="line">            lang: &quot;&#123;&#123; theme.gitment.language &#125;&#125;&quot; || navigator.language || navigator.systemLanguage || navigator.userLanguage,</span><br><span class="line">            &#123;% endif %&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-来必得集成参考"><a href="#4-2-2-来必得集成参考" class="headerlink" title="4.2.2. 来必得集成参考"></a>4.2.2. 来必得<a href="https://blog.csdn.net/qwerty200696/article/details/78836421" target="_blank" rel="noopener">集成参考</a></h4><p>插件集成最简单，但是因为是韩国的所以加载比较慢，首页没有评论数量显示所以没<br>用。</p><h4 id="4-2-3-valine集成参考"><a href="#4-2-3-valine集成参考" class="headerlink" title="4.2.3. valine集成参考"></a>4.2.3. valine<a href="https://shup.cn/2017/11/21/valine.html" target="_blank" rel="noopener">集成参考</a></h4><p>集成也挺简单，但是评论的时候让用户直接选择留下联系方式，然后没有首页显示评论数量所以没用，且评论管理不知道在哪里管理；</p><h2 id="5-本地搜索功能"><a href="#5-本地搜索功能" class="headerlink" title="5. 本地搜索功能"></a>5. 本地搜索功能</h2><p>local_search</p><p>方法一：<a href="https://github.com/theme-next/hexo-generator-searchdb" target="_blank" rel="noopener">推荐官方教程</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Step1: </span><br><span class="line">cd 到博客根目录</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br><span class="line"></span><br><span class="line">Step2:</span><br><span class="line">根目录/_config.yml 文件下添加下面代码</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br><span class="line">  </span><br><span class="line">Step3:</span><br><span class="line">next/_config.yml 文件下更改以下代码:改false为true</span><br><span class="line">local_search:</span><br><span class="line">  enable: true #false</span><br></pre></td></tr></table></figure><p>方法二：民间教程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">step1： 安装插件</span><br><span class="line"></span><br><span class="line">插件管理方法一：自己管理</span><br><span class="line">cd next/source/lib</span><br><span class="line">git clone https://github.com/theme-next/hexo-generator-searchdb.git local_search </span><br><span class="line">ps:local_search名字和里面对应</span><br><span class="line"></span><br><span class="line">方法二：直接让npm给你管理插件-- 推荐</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Step2</span><br><span class="line">your root _config.yml 添加：</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br><span class="line">  </span><br><span class="line">step3</span><br><span class="line">/next/_config.yml 改local_search为true</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><h2 id="6-文字数量和阅读时长"><a href="#6-文字数量和阅读时长" class="headerlink" title="6.  文字数量和阅读时长"></a>6.  文字数量和阅读时长</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Step1</span><br><span class="line">npm install hexo-symbols-count-time --save</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">Step2</span><br><span class="line"></span><br><span class="line">your root _config.yml</span><br><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true</span><br><span class="line">  time: true</span><br><span class="line">  total_symbols: true</span><br><span class="line">  total_time: true</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">/next/_config.yml 不用动</span><br></pre></td></tr></table></figure><h2 id="7-开启RRS订阅"><a href="#7-开启RRS订阅" class="headerlink" title="7. 开启RRS订阅"></a>7. 开启RRS订阅</h2><p>ps:Next主题默认就支持<a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">插件git</a> <a href="https://mritd.me/2016/03/08/Hexo%E6%B7%BB%E5%8A%A0Rss%E8%AE%A2%E9%98%85/" target="_blank" rel="noopener">参考链接</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Step1</span><br><span class="line">cd博客根目录安装 RSS 插件</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line"></span><br><span class="line">Step2</span><br><span class="line">开启网站 RSS 支持</span><br><span class="line"></span><br><span class="line">编辑网站根目录下的 _config.yml，添加以下代码开启</span><br><span class="line"></span><br><span class="line"># RSS订阅</span><br><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: 20</span><br><span class="line">  hub:</span><br><span class="line">  content:</span><br><span class="line">  content_limit: 140</span><br><span class="line">  content_limit_delim: &apos; &apos;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS Developer Skills Matrix</title>
      <link href="/2018/08/06/iOS%20Developer%20Skills%20Matrix/"/>
      <url>/2018/08/06/iOS%20Developer%20Skills%20Matrix/</url>
      
        <content type="html"><![CDATA[<p><strong>一线开发者应该定时整理下自己应该掌握哪些技能树，并思考如何规划以后横向或纵向的学习路线，以为下鄙人在学习过程中发现库<a href="https://github.com/BohdanOrlov/iOS-Developer-Roadmap" target="_blank" rel="noopener">iOS-Developer-Roadmap</a>，感觉挺有价值所以用进行记录并翻译技能树。</strong></p><p>PS:<a href="https://github.com/BohdanOrlov/iOS-Developer-Roadmap" target="_blank" rel="noopener">iOS-Developer-Roadmap</a>项目发现的地方为Chrome的一个推荐Github项目插件 GitHunt Dark（寻找最受欢迎的GitHub项目）</p><p>BohdanOrlov的Github库<a href="https://github.com/BohdanOrlov/iOS-Developer-Roadmap" target="_blank" rel="noopener">iOS-Developer-Roadmap</a>上技能树翻译[<a href="https://raw.githubusercontent.com/BohdanOrlov/ios-skills-matrix/master/matrix.png" target="_blank" rel="noopener">原技能树图谱</a>][<a href="https://coding.net/u/SilenceZhou/p/PictureLib/git/raw/master/iOSDevRoadmap.png" target="_blank" rel="noopener">翻译图谱</a>]</p><table><thead><tr><th align="left"></th><th>Junior</th><th>Middle</th><th>Senior</th></tr></thead><tbody><tr><td align="left">能力</td><td>Json做新闻类App</td><td>能够及时设计和交付快速可靠的聊天模块</td><td>可以用非狂热的想法建立团队行为标准</td></tr><tr><td align="left">代码集成</td><td>使用git来移动代码</td><td>对GitFlow发表了看法</td><td>有想法如何建立CI过程和自动化</td></tr><tr><td align="left">范式</td><td>有面向对象（OOP）的思想</td><td>能够处理比较难的FRP（响应式编程）</td><td>从其他平台和范例中获取价值</td></tr><tr><td align="left">依赖</td><td>知道使用CocoaPods</td><td>知道使用苹果的包管理器 Swift Package Manager(SPM)，但是Carthage 也是一个选项</td><td>知道减少和拥有依赖关系的重要性</td></tr><tr><td align="left">平台</td><td>会使用 Array/Dictionay/Set</td><td>道值/引用类型和Equatable / Hashable</td><td>知道swift和Objc-C的方法调度的细节</td></tr><tr><td align="left">客户服务器协议</td><td>从互联网上获取JSON是件小事</td><td>进行基于WebSocket的实时聊天是可行的</td><td>建立视频聊天是一项可以实现的挑战</td></tr><tr><td align="left">参考</td><td>使用StackOverFlow作为单一的事实来源</td><td>经常使用官方文档</td><td>询问平台开发人员并可以进行逆向工程</td></tr><tr><td align="left">内存</td><td>知道如何避免和修复内存泄漏</td><td>知道NSPointterArray以及结构增加二进制的原因</td><td>有一个减少内存不足崩溃的策略</td></tr><tr><td align="left">UI</td><td>可以在Interface Builder中构建基本UI</td><td>可以在代码中创建UI</td><td>可以对非主线程进行布局和差异计算</td></tr><tr><td align="left">多线程</td><td>asyncAfter是朋友@synchronize所有的东西</td><td>asyncAfter是敌人，线程同步是个问题</td><td>理解多线程多余死锁</td></tr><tr><td align="left">态度</td><td>期望他人在开发过程中进行教学和指导</td><td>与团队讨论设计以分享决策</td><td>负责设计决策的队友</td></tr><tr><td align="left">设计模式</td><td>理解代理、target-action、mvc</td><td>精通Observe，Facade和Mediator模式</td><td>知道依赖注入和服务定位器之间的最佳位置</td></tr><tr><td align="left">产品质量</td><td>如果应用程序在我的手机上运行，则会对其进测试</td><td>编写单元测试并尝试TDD和UI测试</td><td>定义了具有非重叠覆盖区域的可维护测试金字塔</td></tr></tbody></table><p>部分学习参考知识点：</p><p>1、 <a href="https://www.jianshu.com/p/5aa75cd5e13e" target="_blank" rel="noopener">Equatable / Hashable</a></p><p>2、 NSPointerArray、NSHashTable、NSMapTable[<a href="(https://blog.csdn.net/shaohua_lv/article/details/70257053)">参考链接1</a> ][<a href="http://www.saitjr.com/ios/nspointerarray-nsmaptable-nshashtable.html" target="_blank" rel="noopener">参考链接2</a>] : 添加一个对象集合,但不想集合创建一个强引用</p><p>3、 <a href="http://www.cocoachina.com/ios/20161020/17800.html" target="_blank" rel="noopener">Facade(iOS外观设计模式)</a></p><p>4、 <a href="https://www.jianshu.com/p/6f2b915355c2" target="_blank" rel="noopener">Mediator</a>中介者模式</p><p>4.1. 目前用到casatwy的<a href="https://github.com/casatwy/CTMediator" target="_blank" rel="noopener">CTMediator</a>]用来进行路由设计，主要思想是动态进行方法调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:methodSig];</span><br><span class="line">[invocation setArgument:&amp;params atIndex:2];</span><br><span class="line">[invocation setSelector:action];</span><br><span class="line">[invocation setTarget:target];</span><br><span class="line">[invocation invoke];</span><br></pre></td></tr></table></figure><p>4.2. 参考链接：<br>    <a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="noopener">!!!iOS应用架构谈 组件化方案 - 重点学习</a><br>    <a href="https://www.jianshu.com/p/196f66d31543" target="_blank" rel="noopener">iOS组件化实践方案－LDBusMediator炼就</a><br>    <a href="http://jackliu17.github.io/2016/06/06/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85/" target="_blank" rel="noopener">iOS设计模式-中介者 </a><br>    <a href="https://www.jianshu.com/p/76132c91be47" target="_blank" rel="noopener">Target-Action 实现组件解耦 —— CTMediator使用教程</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈 ReactiveCocoa 之 MVVM</title>
      <link href="/2017/10/24/%E6%B5%85%E8%B0%88%20ReactiveCocoa%20%E4%B9%8B%20MVVM/"/>
      <url>/2017/10/24/%E6%B5%85%E8%B0%88%20ReactiveCocoa%20%E4%B9%8B%20MVVM/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>简介</strong> ：</p><ol><li><p>ReactiveCocoa(简称：RAC)为一个开源函数响应式编程框架；</p></li><li><p>使用场景：通过RAC可以更加方便编程进行MVVM设计模式编程；</p></li><li><p>核心机制为信号（信号流）。</p></li><li><p><a href="https://github.com/SilenceZhou/ReactiveCocoaDemo" target="_blank" rel="noopener">Demo地址</a></p></li><li><p>由于Swift和OC版本存在的差异性比较大，维护团队直接给拆了一下： Swift版本（<a href="https://github.com/ReactiveCocoa/ReactiveSwift" target="_blank" rel="noopener">ReactiveSwift</a>）和 OC版本（<a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="noopener">ReactiveCocoa</a>）</p></li><li><p>写该篇文章的初衷： 如何使用RAC 和 如何借助RAC来逐步实现MVC到MVVM的迁移。</p></li></ol></blockquote><p><strong>一、ReactiveCocoa初见</strong></p><p><strong><em>1、编程思想</em></strong><br><a href="https://github.com/ReactiveCocoa" target="_blank" rel="noopener">ReactiveCocoa</a>是函数式编程（Functional Programming）和响应式编程（Reactive Programming）集大成者；</p><p><strong>*2、实现关键： *</strong><br>2.1. 每个方法必须有返回值（本身对象）<br>2.2. 把函数或者Block当做参数, block参数（需要操作的值）block返回值（操作结果）；</p><p><strong><em>3、ReactiveCocoa初见</em></strong></p><p><strong><em>0、如何集成就略了（直接拉入项目或者CocoaPods）</em></strong></p><p><strong><em>1、 RACSiganl</em></strong></p><blockquote><p>最基本的信号类，默认为冷信号，表示当数据改变时，信号内部会发出数据，只有订阅了（subscribeNext）才会进被触发(编程热信号)，代码演示如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 1.创建信号</span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        // 3、发送信号信号 </span><br><span class="line">        NSLog(@&quot;信号被订阅 发送信号&quot;); </span><br><span class="line">        // 4、执行了这一步 订阅信号才会发触发</span><br><span class="line">        [subscriber sendNext:@&quot;heheh&quot;];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // 2.订阅信号 ---必须为订阅</span><br><span class="line">    [signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">        // 发送信号的内容</span><br><span class="line">        NSLog(@&quot;====%@&quot;, x);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><p><strong>*2、RACSubscriber *</strong></p><blockquote><p>订阅者，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。(示例也如上所示)</p></blockquote><p><strong>*3、RACDisposable : *</strong></p><blockquote><p>用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。<br>使用场景:不想监听某个信号时，可以通过它主动取消订阅信号</p></blockquote><p>代码演示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 1.创建</span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        // 3、发送信号信号</span><br><span class="line">        NSLog(@&quot;信号被订阅 发送信号&quot;); </span><br><span class="line">        [subscriber sendNext:@&quot;heheh&quot;];</span><br><span class="line">        return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">            // 只要信号取消就会来这里</span><br><span class="line">            // 默认一个信号发送数据完毕就会主动取消订阅</span><br><span class="line">            NSLog(@&quot;信号被取消了&quot;);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    // 2.订阅信号 ---必须为订阅</span><br><span class="line">    RACDisposable *disposable = [signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">        // 发送信号的内容</span><br><span class="line">        NSLog(@&quot;====%@&quot;, x); </span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    // 3.取消订阅</span><br><span class="line">    [disposable dispose];</span><br></pre></td></tr></table></figure><p><strong><em>4、RACSubject</em></strong></p><blockquote><p>4.1. RACSubject:信号提供者，自己可以充当信号，又能发送信号。<br>4.2. 用场景:通常用来代替代理，有了它，就不必要定义代理了。</p></blockquote><p><strong><em>5、RACTuple</em></strong></p><blockquote><p>元组类,类似NSArray,用来包装值.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RACTuple *tuple = [RACTuple tupleWithObjectsFromArray:@[@&quot;hello111&quot;, @&quot;hello222&quot;,@&quot;hello333&quot;]];</span><br><span class="line">    </span><br><span class="line">NSLog(@&quot;%@&quot;, [tuple objectAtIndex:0]);</span><br></pre></td></tr></table></figure><p><strong><em>6、RACSequence</em></strong></p><blockquote><p>6.1、RAC中的集合类，用于代替NSArray,NSDictionary,可以使用它来快速遍历数组和字典。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1、RACSequence代替数组</span><br><span class="line">- (void)testRACSequenceArr</span><br><span class="line">&#123;</span><br><span class="line">    NSArray * arr = @[@&quot;123&quot;, @&quot;asdfas&quot;, @1];</span><br><span class="line">    // 订阅集合信号，内部会自动便利所有的元素发出来</span><br><span class="line">    [arr.rac_sequence.signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2、RACSequence代替字典</span><br><span class="line">- (void)testRACSequenceDict</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    NSDictionary *dict = @&#123; @&quot;name&quot; : @&quot;张三&quot;, @&quot;age&quot; : @22&#125;;</span><br><span class="line">    </span><br><span class="line">    [dict.rac_sequence.signal subscribeNext:^(RACTuple * _Nullable x) &#123;</span><br><span class="line">        </span><br><span class="line">        // 方法一、</span><br><span class="line">        // NSLog(@&quot;%@  %@&quot;, x[0], x[1]);</span><br><span class="line">        </span><br><span class="line">        // 方法二、</span><br><span class="line">        // 用来解析元组， 宏里面的参数，传需要解析出来的变量名</span><br><span class="line">        // = 右边，放需要解析的元组</span><br><span class="line">        RACTupleUnpack(NSString *key, NSString *value) = x;</span><br><span class="line">        NSLog(@&quot;%@ %@&quot;, key, value );</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>7、RACCommand</em></strong></p><blockquote><p>7.1、直译为命令，只是一个继承自 NSObject 的类，但是它却可以用来创建和订阅用于响应某些事件的信号。<br>7.2、相对而言比较复杂<br>7.3、使用场景：网络请求（MVVM设计模式中网络模块）<br>7.4、在默认情况下 RACCommand 都是不支持并发操作的，需要在上一次命令执行之后才可以发送下一次操作，如果直接execute:两次，最终也只会执行第一个execute：； 所以谨记 在使用应用中推荐一个网络请求对应一个command；</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">简单使用 - 用于网络请求</span><br><span class="line">- (void)RACCommandSimpleUse</span><br><span class="line">&#123;</span><br><span class="line">    RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(NSNumber * _Nullable input) &#123;</span><br><span class="line">        </span><br><span class="line">        return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">            [subscriber sendNext:input];</span><br><span class="line">            // 每次sendNext 记得sendCompleted</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">    [[command.executionSignals switchToLatest] subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    // 在默认情况下 RACCommand 都是不支持并发操作的，需要在上一次命令执行之后才可以发送下一次操作，如果直接execute:两次，最终也只会执行第一个execute：</span><br><span class="line">    // 所以谨记: 一个command对应一个网络请求</span><br><span class="line">    [command execute:@&quot;网络请求1&quot;];</span><br><span class="line">    // [command execute:@&quot;网络请求2&quot;];</span><br><span class="line"></span><br><span class="line">    [RACScheduler.mainThreadScheduler afterDelay:0.5</span><br><span class="line">                                        schedule:^&#123;</span><br><span class="line">                                            [command execute:@&quot;网络请求2&quot;];</span><br><span class="line">                                        &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>8、RACMulticastConnection</em></strong></p><blockquote><p>8.1、直译为多播连接;<br>8.2、存在的问题普通的信号在执行sendNext:的时候，都会重新再执行以下信号的创建，当你想在一个请求完成后 进行分多级刷新UI 或者 做一些别的操作，如果直接用普通的信号进行sendNext：时候，则会进行多次网络请求操作；<br>8.3、项目中使用到的场景比较少；</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-(void)RACMulticastConnectionUse</span><br><span class="line">&#123;</span><br><span class="line">    // 1、通过信号创建链接</span><br><span class="line">    RACMulticastConnection *connection = [[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        NSLog(@&quot;完毕&quot;);</span><br><span class="line">        </span><br><span class="line">        [subscriber sendNext:@&quot;Send Request&quot;];</span><br><span class="line">        // 每次sendNext 记得sendCompleted</span><br><span class="line">        // [subscriber sendCompleted];</span><br><span class="line">        </span><br><span class="line">        return nil;</span><br><span class="line">    &#125;] publish];</span><br><span class="line">    </span><br><span class="line">    //  订阅信号（通过链接转换的信号）一次</span><br><span class="line">    [connection.signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">        NSLog(@&quot;一次 x : %@&quot;, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    //  订阅信号（通过链接转换的信号）二次</span><br><span class="line">    [connection.signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;二次 x : %@&quot;, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    [connection connect];</span><br><span class="line">    </span><br><span class="line">    // 且只有第一次连接才会有效果</span><br><span class="line">    //    [connection.signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    //        NSLog(@&quot;重新连接第一次 x : %@&quot;, x);</span><br><span class="line">    //    &#125;];</span><br><span class="line">    //    [connection.signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    //        NSLog(@&quot;重新连接第二次 x : %@&quot;, x);</span><br><span class="line">    //    &#125;];</span><br><span class="line">    //    [connection connect];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二、ReactiveCocoa使用场景</strong></p><p><strong><em>1、代替代理</em></strong></p><blockquote><p>1、对象持有signal， 推荐用这种</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Code eg.:</span><br><span class="line">- (void)useRACInstandDelegate</span><br><span class="line">&#123;</span><br><span class="line">    [self.redView.btnClickSignal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2、使用rac_signalForSelector来进行方方法的执行，类似于系统自带方法performSelector:withObject:，不推荐(硬编码 和 警告)；</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Code eg.:</span><br><span class="line"></span><br><span class="line">- (void)useRACInstandDelegate2</span><br><span class="line">&#123;</span><br><span class="line">    [[self.redView rac_signalForSelector:@selector(btnClick:)] subscribeNext:^(id  _Nullable x) &#123;       </span><br><span class="line">        NSLog(@&quot;红色view上面的按钮点击了&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>2、代替KVO：</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)insteadKVO</span><br><span class="line">&#123;</span><br><span class="line">    // 需手动导入：#import &quot;NSObject+RACKVOWrapper.h&quot;</span><br><span class="line">    //  1.代替KVO 方法一</span><br><span class="line">    [self.redView rac_observeKeyPath:@&quot;frame&quot;</span><br><span class="line">                             options:NSKeyValueObservingOptionNew</span><br><span class="line">                            observer:nil block:^(id value,</span><br><span class="line">                                                 NSDictionary *change,</span><br><span class="line">                                                 BOOL causedByDealloc,</span><br><span class="line">                                                 BOOL affectedOnlyLastComponent) &#123;</span><br><span class="line">                                //</span><br><span class="line">                                </span><br><span class="line">                            &#125;];</span><br><span class="line">    // 2.替代KVO 方法二</span><br><span class="line">    [[self.redView rac_valuesForKeyPath:@&quot;frame&quot; observer:nil] subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">        // 打印的是NSRect</span><br><span class="line">        NSLog(@&quot;%@&quot;, x);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><p><strong><em>3、监听按钮的点击事件：</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)monitorBtnClick</span><br><span class="line">&#123;</span><br><span class="line">    UIButton *btn;</span><br><span class="line">    </span><br><span class="line">    [[btn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl * _Nullable x) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>4、代替通知：</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)insteadNotification</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    [[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardWillShowNotification object:nil] subscribeNext:^(NSNotification * _Nullable x) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>5、监听文本框文案：</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)insteadTextInput</span><br><span class="line">&#123;</span><br><span class="line">    UITextField *textField;</span><br><span class="line">    [textField.rac_textSignal subscribeNext:^(NSString * _Nullable x) &#123; </span><br><span class="line">        // 监听到文本的改变      </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>6、处理当界面有多次请求时，需要都获取到数据时，才能展示界面</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)multiRequestData</span><br><span class="line">&#123;</span><br><span class="line">    RACSignal *signal1 = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;发送木块一的数据&quot;);</span><br><span class="line">        [subscriber sendNext:@&quot;发送木块一的数据&quot;];</span><br><span class="line">        </span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    RACSignal *signal2 = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;发送模块二的数据&quot;);</span><br><span class="line">        [subscriber sendNext:@&quot;发送模块二的数据&quot;];</span><br><span class="line">        </span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // 数组：存放信号</span><br><span class="line">    // 当数组中的所有信号都发送完成的时候，才会执行Selector</span><br><span class="line">    // 方法的参数： 必须跟数组一一对应</span><br><span class="line">    // 方法的参数：就是每一个信号发送的数据</span><br><span class="line">    </span><br><span class="line">    [self rac_liftSelector:@selector(updateUIFirstPartData:secondPartData:)</span><br><span class="line">      withSignalsFromArray:@[signal1, signal2]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)updateUIFirstPartData:(NSString *)firstPartData secondPartData:(NSString *)secondPartData</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;更新 UI%@ %@&quot;,firstPartData , secondPartData);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>三、浅谈MVVM</strong></p><blockquote><p>简介：MVVM,个人理解他就是MVC的升级版，解耦版，它是一种双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然； MVVM设计模式并不一定要借助RAC来实现，但若使用RAC来实现会更加的简单(因为所有的操作和响应都通过信号来完成对接)；<br>M : 最基本的模型数据<br>V : 视图 / 控制器<br>VM : 处理业务的逻辑（eg:操作事件、数据请求等）</p></blockquote><p><strong><em>1.项目目录结构的体现（给你一种既视感😆）：</em></strong></p><p>Module<br>├── Controllers<br>├── Views<br>├── Models<br>└── VM</p><p><strong><em>2.具体的实操（由于比较简单的实现，model数据就放在VM里面）</em></strong></p><p>2.1. V(控制器或者视图)里面的写法： 提前对数据进行绑定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">备注： LoginVc.m 文件， LoginVc.h文件可忽略</span><br><span class="line"></span><br><span class="line">#import &quot;LoginVc.h&quot;</span><br><span class="line">#import &quot;LogingVM.h&quot;</span><br><span class="line"></span><br><span class="line">@interface LoginVc ()</span><br><span class="line"></span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *userNameTF;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *pwdTF;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UIButton *LoginBtn;</span><br><span class="line">@property (nonatomic, strong) LogingVM *loginVM;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation LoginVc</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [self initRac];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)initRac</span><br><span class="line">&#123;</span><br><span class="line">    // 1. 绑定信号</span><br><span class="line">    RAC(self.loginVM, account) = self.userNameTF.rac_textSignal;</span><br><span class="line">    RAC(self.loginVM, pwd) = self.pwdTF.rac_textSignal;</span><br><span class="line">    </span><br><span class="line">    // 2. 登陆按钮能否点击</span><br><span class="line">    RAC(_LoginBtn,enabled) = self.loginVM.loginEnableSiganl;</span><br><span class="line">    </span><br><span class="line">    // 3. 监听登录按钮点击</span><br><span class="line">    [[_LoginBtn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) &#123;</span><br><span class="line">        // 处理登录事件 =&gt; 发送登陆请求</span><br><span class="line">        [self.loginVM.loginCommand execute:nil];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (LogingVM *)loginVM</span><br><span class="line">&#123;</span><br><span class="line">    if (!_loginVM) &#123;</span><br><span class="line">        _loginVM = [[LogingVM alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    return _loginVM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>2.2. VM （数据的交互），由于比较简单直接把model放到了VM里面了, 一些数据的逻辑处理， 按钮是否可点击，网络是否要请求等；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">头文件：LogingVM.h</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface LogingVM : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSString *account;</span><br><span class="line">@property (nonatomic, strong) NSString *pwd;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong, readonly) RACSignal *loginEnableSiganl; /**&lt; 处理登录按钮是否允许点击 */</span><br><span class="line">@property (nonatomic, strong, readonly) RACCommand *loginCommand;/** 登录按钮命令 */</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">实现文件： LogingVM.m</span><br><span class="line"></span><br><span class="line">#import &quot;LogingVM.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation LogingVM</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        [self setUp];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 初始化操作</span><br><span class="line">- (void)setUp</span><br><span class="line">&#123;</span><br><span class="line">    // 1.登录按钮是否能点击 的信号</span><br><span class="line">    _loginEnableSiganl = [RACSignal combineLatest:@[RACObserve(self, account),</span><br><span class="line">                                                    RACObserve(self, pwd)]</span><br><span class="line">                                           reduce:^id(NSString *account,NSString *pwd)&#123;</span><br><span class="line">                                               </span><br><span class="line">                                               return @(account.length &amp;&amp; pwd.length);</span><br><span class="line">                                               </span><br><span class="line">                                           &#125;];</span><br><span class="line">    </span><br><span class="line">    // 2.登录点击 信号</span><br><span class="line">    _loginCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123;</span><br><span class="line">        </span><br><span class="line">        return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">            </span><br><span class="line">            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                </span><br><span class="line">                // 发送数据</span><br><span class="line">                [subscriber sendNext:@&quot;请求登录的数据&quot;];</span><br><span class="line">                [subscriber sendCompleted];</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            return nil;</span><br><span class="line">            </span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    // 3.处理登录请求返回的结果</span><br><span class="line">    [_loginCommand.executionSignals.switchToLatest subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    // 4.处理登录执行过程</span><br><span class="line">    [[_loginCommand.executing skip:1] subscribeNext:^(id x) &#123;</span><br><span class="line">        </span><br><span class="line">        if ([x boolValue] == YES) &#123;</span><br><span class="line">            NSLog(@&quot;登陆成功&quot;);</span><br><span class="line">            </span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            NSLog(@&quot;登陆时报&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><strong><em>3、 通过上面的<a href="https://github.com/SilenceZhou/ReactiveCocoaDemo" target="_blank" rel="noopener">登陆示例</a>，可以感受到RAC在MVVM的便捷性，可测试性（VM）都有一定的提高。</em></strong></p><p><strong><em>4、如果项目把设计模式由MVC迁移为MVVM，可以分步走，可以理解MVVM是升级版的MVC， 其实就是把以前放在VC 里面处理的逻辑有条理的放到VM里面，Code可测性变高。</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> iOS学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARKit解读</title>
      <link href="/2017/06/07/ARKit%E8%A7%A3%E8%AF%BB/"/>
      <url>/2017/06/07/ARKit%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.apple.com/documentation/arkit" target="_blank" rel="noopener">官网地址</a></p><p><strong>一、了解：</strong></p><ol><li>ARSession  ： 管理设备相机和增强现实体验所需的运动处理的共享对象。</li></ol><p><strong>二、配置：</strong></p><ol><li>ARSessionConfiguration： 仅跟踪设备方向的基本配置。</li><li>ARWorldTrackingSessionConfiguration : 跟踪设备的方向和位置以及检测设备相机所看到的实际表面的配置。</li></ol><p><strong>三、标准视图：</strong> 建立基本的AR经验 （配置AR会话，并使用SceneKit或SpriteKit显示AR内容。）</p><ol><li>ARSKView ：用于显示使用2D SpriteKit内容增强相机视图的AR体验的视图。</li><li>ARSCNView :用于显示使用3D SceneKit内容增强相机视图的AR体验的视图。</li></ol><p><strong>四、自定义视图：</strong>  用Metal显示AR体验</p><ol><li>通过渲染相机图像和使用位置跟踪信息来显示叠加内容来构建自定义AR视图。</li></ol><p><strong>五、现实世界的对象和位置</strong></p><ol><li>ARAnchor : 可用于将对象放置在AR场景中的现实世界的位置和方向。</li><li>ARPlaneAnchor : 有关AR会话中检测到的真实平面的位置和方向的信息。</li><li>ARHitTestResult : 通过检查AR会话的设备摄像头视图中的一个点找到有关现实世界表面的信息。</li></ol><p><strong>六、相机和场景细节</strong></p><ol><li>ARFrame : 作为AR会话的一部分捕获的视频图像和位置跟踪信息。</li><li>ARCamera : 有关AR会话中捕获的视频帧的摄像机位置和成像特性的信息。</li><li>ARLightEstimate : 与AR会话中捕获的视频帧相关联的估计场景照明信息。</li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尼康D5200的使用</title>
      <link href="/2016/09/05/%E5%B0%BC%E5%BA%B7D5200%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2016/09/05/%E5%B0%BC%E5%BA%B7D5200%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="http://v.youku.com/v_show/id_XODIxNTU2MDk2.html?beta&sharefrom=iphone" target="_blank" rel="noopener">蚂蚁摄影视屏教程</a></p><p>1、镜头和机身主要按键介绍：<br> 1.1、镜头和机身上的按键的熟悉<br> 1.2、新手应该了解的知识：光圈、快门、感光度<br> 1.3、机身和镜头的拆卸和组装（咔的一声）<br> 1.4、VR:光学防抖（一般开启）<br> 1.5、A/M 自动或者手动（一般设置为A）<br> 1.6、镜头锁（有些有有些没有，旋转至18的时候开启了锁，这个锁是便于携带）<br> 1.7、fn 自定义设定；（设置为感光ISO） menu-&gt;自定义菜单-&gt;f控制 -&gt; 指定fn控制  —&gt; 然后选择（自己想要的选项：ISO感光度）<br>  调节的时候 长按 fn + 滚动轮<br> 1.8、闪电符号： 闪光灯<br> 1.9、对焦辅助灯<br> 2.0、开关机拨杆 / 快门键<br> 2.1、红点：录像<br> 2.2、右边曝光补偿键（光圈的标识：调节光圈大小  + / — ）<br> 2.3、info ： 屏幕的开关机键<br> 2.4、单张拍摄、连拍、自拍<br> 2.5、显示屏取景和取景器取景  （LV方向：显示屏取景 再按下info键则显示一些信息）  反之切换<br> 2.6、顶部转盘-&gt;模式转盘：（顺时针方向命名）<br>  P ： 程序自动模式<br>  S ：快门优先 （佳能上叫tv）<br>  A :   光圈优先模式<br>  M:   全手动模式<br>  AUTO:全自动<br>  闪光灯关闭<br>  SCENE 场景模式 （夜景、室内、海滩等11种场景模式）<br>  人像模式<br>  风景模式<br>  儿童照模式<br>  运动模式<br>  小花：微距模式<br>  EFFECTS: 滤镜特效模式（模型效果、剪影等一些特俗的效果）<br> 2.7、取景器<br> 2.8、显示屏<br> 2.9、I 键 ： 尼康相机设置参数通用按钮键  ，操作方式：I —&gt; 上下左右键 —&gt;OK —&gt; 需要选择的项目 —&gt;  OK确定<br> 3.0、拨盘：调节参数<br> 3.1、相册<br> 3.2、上下左右 / 确认 键 （看照片的时候： 左右键切换、上下键可以显示更多的信息）<br> 3.3、放大 和 缩小  ：  查看照片 放大   （缩小：帮助菜单键，选择某个选项的时候，按下缩小键 会出现更多信息便于我们理解，灯光较<br>  暗的时候，左下角会出现一个 ？在一直闪烁，这时候按  缩小键 则会提示你打开闪光灯进行补光 ）<br> 3.4、menu键：一些设置</p><p> 光圈  D5200 是39点对焦<br> 曝光指示表（0的找出来的照片： 左边暗、右边亮）<br> 屏幕指示意义：</p><p><img src="http://pd1cmfwy2.bkt.clouddn.com/pic1.jpg" alt="picture"></p><p>2、闪光灯：较暗就开灯<br>3、变焦： 旋转变焦环（调成显示屏取景、或者取景器取景）<br>4、连拍/自拍（抓拍： 按下上面的连拍按钮（高速：5 ；低速：3）；  自拍：10秒延时自拍）<br>5、视频录制：可以录制 全高清视频（先切换为显示屏取景正在录制，且上面的意义：录制模式：全高清）新手用A ： 光圈优先<br>6、光圈（用来控制进光大小）： 大光圈： 人物 （视角窄）； 小光圈：大场景，适合拍风景（视角大）；<br>   中间光圈调整： 按住 上面的曝光补偿 + 转动拨盘  就可以调整了 （往右边转：F后面年数字越大，光圈越小；<br>   左边:F后面数字越来越小，光圈越来越大）<br>7、快门：控制进光时间  （S 和 M 模式下才可以调节）仅仅拨动拨盘就能调整: 左慢右快<br>  高速快门：抓拍小宝宝 和运动员的 精彩瞬间<br>  慢速快门：记录汽车尾灯拉丝 和 星空流星轨迹效果<br>8、感光度ISO：对光线的敏感度，P S M A 模式下都可以调整（可以设置快捷键，或者按 I键进行）<br> 感光度越低  画面越整体越暗 画质越清楚（在光线充足的情况下，推荐尽量使用低感光ISO白天推荐使用100就好；）    感光度越高 画面整体越亮  但是噪点高，画质会更粗糙）</p><p>9、对焦方式： P S A M模式下可以调整<br>  对焦方式 : 4 种<br>  AF - A  :  自动伺服对焦 （动静对焦方式的自动切换）<br>  AF - S  ：单次伺服对焦（适合拍摄静止的物体）<br>  AF - C  ：连续伺服对焦 （适合拍摄动态的物体） 马拉松赛事<br>  MF   :  手动对焦</p><p>  对焦区域：选择 派人物  拍眼睛 ，人更加有神，<br>  在对焦区域模式里面选择 单点对焦 —&gt; 通过上下左右键 从39个对焦点钟任意选择一个对焦点<br>  对焦区域： 推荐使用39点对焦  +  连续对焦  ===&gt; 更好的抓拍</p><p>10、测光模式：（P S A M模式下都可以调节） M<br>  如何操作： I 键 —&gt; 测光模式 —&gt; OK —&gt;  测光模式的选择界面</p><p>  矩阵测光、中央重点测光、点测光</p><p>  曝光准确的照片：避免曝光不足太暗、 曝光太足引起抓拍太亮<br>  风景和合影， 平价测光<br>  逆光中的人物 推荐  使用  点测光<br>  把 需要  拍摄的物体放在中间的时候 就需要 中央重点测光</p><p>优雅的拍照姿势：<br>1、 双脚与双肩齐平；<br>2、蹲着：单膝跪地，用后胳膊肘放腿上；<br>3、依靠： 三角形具有稳定性；</p><p>保养：<br>清洁镜头 ： 用拭擦布向一个方向拭擦<br>换镜头：  需要 向下 换 防止灰尘</p>]]></content>
      
      
      <categories>
          
          <category> 爱好 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS开发成长之道</title>
      <link href="/2015/12/28/iOS%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/"/>
      <url>/2015/12/28/iOS%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>1、创作（写有深度的博客、仿制优秀的项目、随时记录理解）；</p><p>2、做有难度的项目；</p><p>3、“不用则废”不只是针对技能，还针对理解；</p><p>4、尽量少抱大腿,或者压根就别抱大腿；</p><p>5、多读源码(用五柳先生的话就是,不求甚解. 但是读源码也不能盲目的看,最好是看和最近的工作相关的)；</p><p>6、多读国外的iOS开发网站和blog：Raywenderlich 和 nshipster 还有 objc.io</p><p>7、要孜孜不倦的学习： （学习第二门开发语言：推荐python）；</p>]]></content>
      
      
      <categories>
          
          <category> 感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人成长 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
